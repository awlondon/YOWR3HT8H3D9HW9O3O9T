<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HLSF Cognition Engine v2.0</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0a0a;
      --panel: #111;
      --text: #e0e0e0;
      --accent: #00ff88;
      --error: #ff4444;
      --success: #44ff44;
      --warning: #ffd54f;
      --scrollbar: #1f1f1f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Fira Code', Consolas, Monaco, 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
      width: 100%;
    }

    #header {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      font-weight: normal;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .stat-value {
      font-weight: bold;
      color: var(--accent);
    }

    #log {
      flex: 1;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
      min-height: 400px;
    }

    #log::-webkit-scrollbar { width: 10px; }
    #log::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 10px; }

    #input-area {
      margin-top: 1rem;
      display: flex;
      gap: 0.75rem;
    }

    #command-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      transition: border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    #command-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn-primary { background: var(--accent); color: #022d15; }
    .btn-secondary { background: #333; color: var(--text); }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.25);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .hidden { display: none !important; }

    #hlsf-log-progress { background: #222; }
    #hlsf-log-bar { background: #6cf; height: 6px; width: 0%; transition: width 0.15s; }
    #hlsf-batch-log { max-height: 280px; overflow: auto; }

    .log-entry {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      animation: fadeIn 0.3s ease;
    }

    .log-entry .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .log-entry.status { font-style: italic; }
    .log-entry.error { border-left-color: var(--error); color: var(--error); }
    .log-entry.success { border-left-color: var(--success); color: var(--success); }
    .log-entry.warning { border-left-color: var(--warning); color: var(--warning); }

    .cost-estimate {
      background: rgba(255, 213, 79, 0.1);
      border: 1px solid var(--warning);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
    }

    .section-divider {
      margin: 1.5rem 0 0.5rem 0;
      border-top: 2px solid #222;
      padding-top: 1rem;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .thought-stream {
      background: rgba(0, 255, 136, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 8px;
      padding: 1rem;
      font-style: italic;
      line-height: 1.6;
    }

    .adjacency-insight {
      background: rgba(255, 213, 79, 0.05);
      border: 1px solid rgba(255, 213, 79, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .token-highlight {
      background: rgba(0, 255, 136, 0.2);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: bold;
    }

    .final-output {
      border-left: 3px solid var(--success);
      padding: 1rem;
      background: rgba(68, 255, 68, 0.05);
      border-radius: 8px;
    }

    .final-output h3 {
      margin-top: 0;
      color: var(--success);
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #222;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin: 0.5rem 0;
      transition: border 0.2s ease;
    }

    details[open] {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.25);
    }

    summary {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      list-style: none;
      font-weight: 600;
      padding: 0.3rem 0;
    }

    summary::-webkit-details-marker { display: none; }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0.5rem 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: #111;
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2rem;
      width: min(420px, 90vw);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-content h2 { margin: 0; color: var(--accent); }

    .hlsf-canvas-container {
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
    }

    #hlsf-canvas {
      width: 100%;
      height: 600px;
      background: transparent;
      border-radius: 8px;
      cursor: grab;
    }

    #hlsf-canvas:active {
      cursor: grabbing;
    }

    .hlsf-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .hlsf-control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .hlsf-control-group.full-span {
      grid-column: 1 / -1;
    }

    .hlsf-mental-state {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid #222;
      border-radius: 6px;
      padding: 0.75rem 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .hlsf-mental-name {
      font-weight: 700;
      color: var(--accent);
      font-size: 0.95rem;
    }

    .hlsf-mental-summary {
      font-size: 0.85rem;
      font-style: italic;
      opacity: 0.8;
    }

    .hlsf-mental-desc,
    .hlsf-mental-mechanics {
      font-size: 0.8rem;
      line-height: 1.3;
    }

    .hlsf-mental-mechanics {
      opacity: 0.75;
    }

    .hlsf-dimension-stats {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid #222;
      border-radius: 6px;
      padding: 0.5rem 0.6rem;
    }

    .hlsf-dimension-stats span {
      color: var(--accent);
      font-weight: 600;
    }

    .hlsf-control-group label {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .hlsf-control-group input[type="range"],
    .hlsf-control-group select {
      width: 100%;
    }

    .hlsf-control-group input[type="number"],
    .hlsf-control-group select {
      padding: 0.5rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 6px;
      color: var(--text);
    }

    .hlsf-button-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hlsf-button-row button {
      flex: 1;
      min-width: 80px;
    }

    .hlsf-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      margin-top: 0.5rem;
    }

    .hlsf-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .hlsf-legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .hlsf-node-info {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      font-size: 0.85rem;
      display: none;
    }

    .hlsf-node-info.visible {
      display: block;
    }

    .modal-content input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #222;
      background: #0c0c0c;
      color: var(--text);
      font-size: 1rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .pill-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pill-button.primary { background: var(--accent); color: #022d15; }
    .pill-button.secondary { background: transparent; border: 1px solid #333; color: var(--text); }

    .pill-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.18);
    }

    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 136, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    .processing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      #app { padding: 1rem; }
      #header { flex-direction: column; align-items: flex-start; }
      .header-stats { flex-direction: column; gap: 0.5rem; }
      #input-area { flex-direction: column; }
      .button-group { flex-direction: column; }
      .btn { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="api-modal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true">
      <h2>Enter OpenAI API Key</h2>
      <p>Provide your OpenAI API key (sk-...) to begin using the HLSF Cognition Engine.</p>
      <input id="api-key-input" type="password" placeholder="sk-..." />
      <div class="modal-actions">
        <button id="api-cancel" class="pill-button secondary">Continue offline</button>
        <button id="api-confirm" class="pill-button primary">Save key</button>
      </div>
      <small style="opacity:0.65">⚠️ Note: Download this HTML file and run locally for API calls to work.</small>
    </div>
  </div>

  <div id="app">
    <div id="header">
      <div>HLSF Cognition Engine v2.0</div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">Cache Hit Rate</span>
          <span class="stat-value" id="cache-hit-rate">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Cached Tokens</span>
          <span class="stat-value" id="cached-tokens">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Session Cost</span>
          <span class="stat-value" id="session-cost">$0.00</span>
        </div>
      </div>
    </div>
    <div id="log"></div>
    <div id="input-area">
      <input id="command-input" type="text" placeholder="> Enter a prompt or /command" maxlength="600" autocomplete="off" />
      <div class="button-group">
        <button id="cancel-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
        <button id="send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
    <input id="db-file" type="file" accept=".json,application/json" style="display:none">
    <div class="hlsf-canvas-container hidden" id="hlsf-canvas-container">
      <div class="section-title">🔭 HLSF Matrix Visualizer</div>
      <details id="hlsf-batch-log" open>
        <summary>Batch log</summary>
        <div id="hlsf-log-progress">
          <div id="hlsf-log-bar"></div>
        </div>
        <pre id="hlsf-log-stream"></pre>
        <button id="hlsf-log-download">Download log</button>
      </details>
      <canvas id="hlsf-canvas"></canvas>
      <div class="hlsf-controls">
        <div class="hlsf-control-group">
          <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
          <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
          <input id="hlsf-alpha" type="range" min="0.005" max="0.99" step="0.01" value="0.70">
        </div>
        <div class="hlsf-control-group">
          <label>Edge width <span id="edgew-val">0.02</span></label>
          <input id="edgew" type="range" min="0.01" max="1.00" step="0.005" value="0.02">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
          <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-color-mode">Edge coloring</label>
          <select id="hlsf-edge-color-mode">
            <option value="theme">Theme</option>
            <option value="weight">Weight</option>
            <option value="relation">Relation</option>
          </select>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">50</span></label>
          <input id="hlsf-relation-cap" type="number" min="1" max="50" step="1" value="50">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
          <input id="hlsf-edges-per-type" type="number" min="1" max="10" step="1" value="3">
        </div>
        <div class="hlsf-control-group">
          <label>Display options</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
            <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
            <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
            <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
            <button id="hlsf-toggle-layout" class="btn btn-secondary">Layout: Affinity</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-aff-thresh">Affinity threshold <span id="hlsf-aff-thresh-val">0.35</span></label>
          <input id="hlsf-aff-thresh" type="range" min="0.1" max="0.8" step="0.01" value="0.35">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-aff-iters">Affinity iterations <span id="hlsf-aff-iters-val">8</span></label>
          <input id="hlsf-aff-iters" type="range" min="1" max="20" step="1" value="8">
        </div>
        <div class="hlsf-control-group full-span">
          <em id="hlsf-affinity-summary" class="hlsf-mental-summary">Current mental state: Focused yet flexible attention.</em>
        </div>
        <div class="hlsf-control-group">
          <label>Rotation modes</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
            <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergence</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>View</label>
          <div class="hlsf-button-row">
            <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
            <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
            <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
            <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      MAX_TOKENS_PER_PROMPT: 500,
      MAX_TOKENS_PER_RESPONSE: 500,
      MAX_CONCURRENCY: 5,
      MAX_RETRY_ATTEMPTS: 3,
      RETRY_BASE_DELAY_MS: 500,
      DEFAULT_MODEL: 'gpt-4o-mini',
      MODEL_PRICING: {
        default: { inputPerMillion: 0.15, outputPerMillion: 0.60 },
        'gpt-4o-mini': { inputPerMillion: 0.15, outputPerMillion: 0.60 },
      },
      ESTIMATED_COMPLETION_RATIO: 0.7,
      ADJACENCY_TOKEN_ESTIMATES: {
        prompt: 220,
        completion: 320,
      },
    };

    const METRIC_SCOPE = { RUN: 'run', DB: 'db' };

    // Canonical 50-type display names
    const REL_EN = {
      "≡":"Identity","⊃":"Contains","⊂":"Is Contained By","≈":"Variant","∈":"Is Instance Of","∋":"Has Instance",
      "⊤":"Is Type Of","⊥":"Has Type","⊏":"Part Of","⊐":"Composes","↔":"Mirrors","⇌":"Inverts","∥":"Parallel To",
      "∼":"Adjacent To","→":"Next","⇒":"Sequence Of","⇐":"Preceded By","↠":"Follows","↗":"Spatially Above","↘":"Spatially Below",
      "↝":"Symbolically Supports","↧":"Symbolically Depends","≠":"Contrasts","⊕":"Complements","⊛":"Associated With","∝":"Correlates With",
      "⇝":"Causes","↼":"Caused By","*":"Evokes","≜":"Represents","★":"Symbolizes","↦":"Refers To","⊢":"Defines","⊣":"Is Defined By",
      "↷":"Transforms To","↶":"Transformed From","∘":"Functions As","⊨":"Interpreted As","◁":"Used With","⇄":"Co-occurs With",
      "⊗":"Synthesizes","÷":"Divides Into","⊘":"Opposes","↳":"Leads To","↲":"Results In","⟂":"Orthogonal To","≉":"Diverges From",
      "≍":"Equivalent In Form","≓":"Approximately Equals","≔":"Defined As"
    };

    // Return "∼ Adjacent To"
    const relDisplay = k => `${k} ${REL_EN[k] ?? ''}`.trim();

    const RELKEY_ALIASES = (() => {
      const map = new Map();
      for (const [glyph, name] of Object.entries(REL_EN)) {
        map.set(`${glyph} ${name}`, glyph);
        map.set(name, glyph);
        map.set(name.toLowerCase(), glyph);
      }
      map.set('∗', '*');
      map.set('*', '*');
      map.set('⋆', '*');
      return map;
    })();

    const BatchLog = (() => {
      const buf = [];
      let lastFlush = 0;
      let ui = null;
      let bar = null;
      const max = 5000;
      const loggingEnabled = () => window.HLSF?.config?.batchLogging !== false;

      function mount() {
        ui = document.getElementById('hlsf-log-stream');
        bar = document.getElementById('hlsf-log-bar');
      }

      function push(ev) {
        if (!loggingEnabled()) return;
        const t = performance.now();
        buf.push({ t, ...ev });
        if (buf.length > max) buf.shift();
        flush(120);
      }

      function phase(name, evt = 'mark', meta) {
        push({ phase: name, evt, meta });
      }

      function progress(done, total) {
        if (!bar) return;
        if (!loggingEnabled()) {
          bar.style.width = '0%';
          return;
        }
        const pct = Math.floor((100 * done) / Math.max(1, total));
        bar.style.width = `${Math.min(100, Math.max(0, pct))}%`;
      }

      function flush(ms = 120) {
        if (!loggingEnabled()) return;
        const now = performance.now();
        if (!ui || now - lastFlush < ms) return;
        lastFlush = now;
        const tail = buf.slice(-200).map(e => {
          const dt = (e.t / 1000).toFixed(3);
          const tag = e.phase ? `[${e.phase}:${e.evt || 'mark'}]` : '';
          const meta = e.meta ? ` ${JSON.stringify(e.meta)}` : '';
          const msg = e.msg ? ` ${e.msg}` : '';
          return `${dt} ${tag}${msg}${meta}`.trimEnd();
        }).join('\n');
        ui.textContent = tail;
      }

      function toJSON() {
        return JSON.stringify(buf);
      }

      function clear() {
        buf.length = 0;
        lastFlush = 0;
        if (ui) ui.textContent = '';
        if (bar) bar.style.width = '0%';
      }

      function download() {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([toJSON()], { type: 'application/json' }));
        a.download = `hlsf_batch_log_${Date.now()}.json`;
        a.click();
      }

      window.addEventListener('load', () => {
        mount();
        document.getElementById('hlsf-log-download')?.addEventListener('click', download);
      });

      return { push, phase, progress, flush, clear, toJSON, mount };
    })();

    function normRelKey(k) {
      const cleaned = (k || '').trim();
      if (!cleaned) return null;
      if (REL_EN[cleaned]) return cleaned;
      const normalized = cleaned.replace(/\s+/g, ' ');
      const alias = RELKEY_ALIASES.get(normalized)
        || RELKEY_ALIASES.get(normalized.toLowerCase())
        || RELKEY_ALIASES.get(normalized.split(' ')[0]);
      return REL_EN[alias] ? alias : null;
    }

    function normalizeRelKeyForStats(k){
      const g = normRelKey(k);
      return REL_EN[g] ? g : null;
    }

    function renderRelTypeRow(glyph, count){
      return `${relDisplay(glyph)}: ${count} instances`;
    }

    // ---------------- HLSF matrix builder ----------------
    function buildMatrixForRecord(rec) {
      const edges = [];
      const rels = rec?.relationships || {};
      const keys = Object.keys(rels);
      for (const rawKey of keys) {
        const key = normRelKey(rawKey);
        if (!key) continue;
        const arr = Array.isArray(rels[rawKey]) ? rels[rawKey] : [];
        const items = arr
          .filter(x => x && typeof x.weight === 'number')
          .sort((a, b) => b.weight - a.weight);
        if (!items.length) continue;
        const agg = {
          rtype: key,
          aggWeight: items[0].weight,
          sizeWeight: items.reduce((s, x) => s + x.weight, 0),
          count: items.length,
          items
        };
        edges.push(agg);
      }
      const freq = typeof rec?.f === 'number'
        ? rec.f
        : typeof rec?.frequency === 'number'
          ? rec.frequency
          : typeof rec?.freq === 'number'
            ? rec.freq
            : 1;
      return { token: rec?.token || '', edges, f: freq };
    }

    function buildHLSFMatrices(db) {
      const raw = db?.full_token_data || [];
      const matrices = new Map();
      const freqs = [];
      for (const rec of raw) {
        const matrix = buildMatrixForRecord(rec);
        matrices.set(matrix.token, matrix);
        if (typeof matrix.f === 'number') freqs.push(matrix.f);
      }

      freqs.sort((a, b) => a - b);
      const freqStats = freqs.length
        ? {
            min: freqs[0],
            max: freqs[freqs.length - 1],
            p90: freqs[Math.max(0, Math.floor(freqs.length * 0.9) - 1)]
          }
        : { min: 0, max: 1, p90: 1 };

      window.HLSF = window.HLSF || {};
      window.HLSF.matrices = matrices;
      window.HLSF.metrics = Object.assign({}, window.HLSF.metrics, { freqStats });

      return matrices;
    }

    function parseHlsfArgs(str) {
      const out = { mode: 'full', tokens: [], glyphs: [], depth: 3.0 };
      const s = (str || '').trim();
      if (!s) return out;
      if (/^--conversation$/i.test(s)) { out.mode = 'conversation'; return out; }
      const m = s.match(/^--\[(.*)\]$/s);
      if (!m) return out;
      const parts = m[1].split(/\s*,\s*/).filter(Boolean);
      for (const p of parts) {
        const kv = p.split(/\s*=\s*/);
        if (kv.length === 2 && /^recursionDepth$/i.test(kv[0])) {
          out.depth = Math.max(0, parseFloat(kv[1]) || 0);
          continue;
        }
        if (/^[\u2200-\u2BFF\u{1F300}-\u{1FAFF}]+$/u.test(p)) out.glyphs.push(p);
        else out.tokens.push(p);
      }
      out.mode = out.glyphs.length ? 'glyphs' : 'tokens';
      return out;
    }

    function extractHlsfFlags(str) {
      const raw = (str || '').trim();
      if (!raw) return { text: '', flags: {} };

      const parts = raw.split(/\s+/);
      const remain = [];
      const flags = {};

      const parseValue = (part, index) => {
        const eqIdx = part.indexOf('=');
        if (eqIdx >= 0) return part.slice(eqIdx + 1);
        if (index + 1 < parts.length) return parts[index + 1];
        return '';
      };

      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const lower = part.toLowerCase();

        if (lower === '--nolog') { flags.batchLogging = false; continue; }
        if (lower === '--nowait') { flags.deferredRender = false; continue; }

        if (lower.startsWith('--scope')) {
          const value = parseValue(part, i).toLowerCase();
          if (!part.includes('=')) i += 1;
          if (value === METRIC_SCOPE.DB) flags.metricScope = METRIC_SCOPE.DB;
          else if (value === METRIC_SCOPE.RUN) flags.metricScope = METRIC_SCOPE.RUN;
          continue;
        }

        if (lower.startsWith('--depth')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const depth = parseFloat(value);
          if (Number.isFinite(depth)) flags.depth = depth;
          continue;
        }

        if (lower.startsWith('--types')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const valLower = typeof value === 'string' ? value.toLowerCase() : '';
          if (valLower === 'all' || valLower === 'infinity' || valLower === 'inf' || valLower === '∞') {
            flags.relationTypeCap = Infinity;
          } else {
            const n = parseInt(value, 10);
            if (Number.isFinite(n)) flags.relationTypeCap = n;
          }
          continue;
        }

        if (lower.startsWith('--ept')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const valLower = typeof value === 'string' ? value.toLowerCase() : '';
          if (valLower === 'all' || valLower === 'infinity' || valLower === 'inf' || valLower === '∞') {
            flags.edgesPerType = Infinity;
          } else {
            const n = parseInt(value, 10);
            if (Number.isFinite(n)) flags.edgesPerType = n;
          }
          continue;
        }

        remain.push(part);
      }

      const text = remain.join(' ').trim();
      return { text, flags };
    }

    function buildIndex(db) {
      const idx = new Map();
      (db?.full_token_data || []).forEach(rec => {
        if (rec?.token) idx.set(rec.token, rec);
      });
      return idx;
    }

    async function loadOrGetIndex() {
      const db = getDb();
      if (!db) throw new Error('No DB loaded');
      if (window.HLSF.indexCache && window.HLSF.indexCacheSource === window.HLSF.dbCache) {
        return window.HLSF.indexCache;
      }
      loadGlyphMaps(db);
      const idx = buildIndex(db);
      window.HLSF.indexCache = idx;
      window.HLSF.indexCacheSource = window.HLSF.dbCache;
      return idx;
    }

    function getAnchorCap(idx) {
      const configuredCap = Number(window.HLSF?.config?.fullAnchorCap);
      if (Number.isFinite(configuredCap) && configuredCap > 0) {
        const size = idx instanceof Map ? idx.size : configuredCap;
        return Math.min(configuredCap, size);
      }
      return idx instanceof Map ? idx.size : 0;
    }

    function adjacencyStats(rec) {
      let relTypes = 0;
      let edges = 0;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          relTypes += 1;
          edges += arr.length;
        }
      }
      return { relTypes, edges };
    }

    function defaultAnchors(idx, k = 64) {
      const recs = Array.from(idx.values());
      recs.sort((a, b) => {
        const A = adjacencyStats(a);
        const B = adjacencyStats(b);
        return (B.edges - A.edges) || (B.relTypes - A.relTypes);
      });
      return recs.slice(0, k).map(r => r.token);
    }

    function signatureFor(rec) {
      const S = { weights: new Map(), neigh: new Set() };
      for (const arr of Object.values(rec?.relationships || {})) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const token = rel?.token;
          if (!token) continue;
          const weight = Number.isFinite(rel?.weight)
            ? rel.weight
            : Number.isFinite(rel?.w)
              ? rel.w
              : 1;
          S.weights.set(token, (S.weights.get(token) || 0) + weight);
          S.neigh.add(token);
        }
      }
      return S;
    }

    function cosine(a, b) {
      if (!a || !b) return 0;
      let dot = 0;
      let na = 0;
      let nb = 0;
      for (const [token, wa] of a.weights) {
        na += wa * wa;
        const wb = b.weights.get(token) || 0;
        if (wb) dot += wa * wb;
      }
      for (const wb of b.weights.values()) nb += wb * wb;
      const denom = Math.sqrt(na * nb);
      return denom ? dot / denom : 0;
    }

    function jaccard(a, b) {
      if (!a || !b) return 0;
      const A = a.neigh;
      const B = b.neigh;
      let inter = 0;
      const small = A.size <= B.size ? A : B;
      const big = A.size <= B.size ? B : A;
      for (const x of small) if (big.has(x)) inter += 1;
      const uni = A.size + B.size - inter;
      return uni ? inter / uni : 0;
    }

    function affinity(a, b) {
      return 0.6 * cosine(a, b) + 0.4 * jaccard(a, b);
    }

    function candidateMap(graph) {
      const nbr = new Map();
      const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
      for (const edge of edges) {
        const fromSet = nbr.get(edge.from) || (() => {
          const set = new Set();
          nbr.set(edge.from, set);
          return set;
        })();
        const toSet = nbr.get(edge.to) || (() => {
          const set = new Set();
          nbr.set(edge.to, set);
          return set;
        })();
        fromSet.add(edge.to);
        toSet.add(edge.from);
      }
      for (const [a, set] of nbr) {
        for (const b of [...set]) {
          const second = nbr.get(b) || new Set();
          for (const c of second) {
            if (c !== a) set.add(c);
          }
        }
      }
      return nbr;
    }

    function clusterByAffinity(graph, index, { thresh = 0.35, iters = 8 } = {}) {
      if (!graph || !index) return 0;
      const sig = new Map();
      for (const [token] of graph.nodes) {
        sig.set(token, signatureFor(index.get(token) || {}));
      }
      const cand = candidateMap(graph);
      for (const token of graph.nodes.keys()) {
        if (!cand.has(token)) cand.set(token, new Set());
      }
      const label = new Map();
      for (const token of graph.nodes.keys()) label.set(token, token);
      const limit = Math.max(1, Math.floor(iters));
      const threshold = Math.max(0, Math.min(1, Number(thresh) || 0));
      for (let i = 0; i < limit; i++) {
        let moved = 0;
        for (const [a, neighbors] of cand) {
          let best = label.get(a);
          let bestScore = 0;
          const scores = new Map();
          for (const b of neighbors) {
            const score = affinity(sig.get(a), sig.get(b));
            if (score < threshold) continue;
            const lbl = label.get(b);
            scores.set(lbl, (scores.get(lbl) || 0) + score);
          }
          for (const [lbl, total] of scores) {
            if (total > bestScore) {
              bestScore = total;
              best = lbl;
            }
          }
          if (best !== label.get(a)) {
            label.set(a, best);
            moved += 1;
          }
        }
        if (!moved) break;
      }
      const ids = [...new Set(label.values())].sort();
      const idMap = new Map(ids.map((k, idx) => [k, idx]));
      for (const [token, node] of graph.nodes) {
        node.cluster = idMap.get(label.get(token));
      }
      return idMap.size;
    }

    function applyAffinityClusters(graph, index) {
      if (!graph || !index) return 0;
      const config = window.HLSF?.config?.affinity || {};
      const threshold = Number.isFinite(config.threshold) ? config.threshold : 0.35;
      const iterations = Number.isFinite(config.iterations) ? config.iterations : 8;
      const count = clusterByAffinity(graph, index, { thresh: threshold, iters: iterations });
      graph.clusterCount = count;
      return count;
    }

    function recomputeAndRender() {
      const graph = window.HLSF?.currentGraph;
      const idx = window.HLSF?.lastCommand?.idx;
      if (graph && idx) {
        applyAffinityClusters(graph, idx);
      }
      debouncedLegacyRender();
    }

    function getRelationTypeCap() {
      const raw = window.HLSF?.config?.relationTypeCap;
      if (raw === Infinity) return Infinity;
      return clampRelationTypeCap(raw);
    }

    function getEdgesPerType() {
      const raw = window.HLSF?.config?.edgesPerType;
      if (raw === Infinity) return Infinity;
      return clampEdgesPerType(raw);
    }

    async function assembleGraphFromAnchorsLogged(anchorsInput, depthFloat, index, options = {}) {
      const opts = options || {};
      const fallbackAnchors = Array.isArray(options?.anchors) ? options.anchors : undefined;
      const legacySeeds = Array.isArray(options?.seeds) ? options.seeds : undefined;
      const anchors = anchorsInput ?? fallbackAnchors ?? legacySeeds ?? [];
      const graph = { nodes: new Map(), links: [], anchors: [...anchors] };
      const outSet = new Set();
      const inSet = new Set();
      let edgeTypeEnums = 0;
      const queue = [];
      let head = 0;
      let expanded = 0;
      let enqueued = 0;
      const tick = Math.max(1, Math.round(Number(window.HLSF?.config?.progressTick) || 250));
      const maxDepth = Math.floor(depthFloat);
      const frac = depthFloat - maxDepth;
      const loggingActive = !opts.silent && window.HLSF?.config?.batchLogging !== false;
      const logPhase = (evt, meta) => { if (loggingActive) BatchLog.phase('graph', evt, meta); };
      const logProgress = (done, total) => { if (loggingActive) BatchLog.progress(done, total); };
      const seenTriple = new Set();
      const visitedSrc = new Set();
      const fractionalNodes = new Set();
      const freqFor = (rec) => {
        if (!rec) return 1;
        if (Number.isFinite(rec.f)) return rec.f;
        if (Number.isFinite(rec.frequency)) return rec.frequency;
        if (Number.isFinite(rec.freq)) return rec.freq;
        return 1;
      };
      const ensureNode = (token, layer) => {
        if (!token) return null;
        const existing = graph.nodes.get(token);
        if (existing) {
          if (Number.isFinite(layer)) {
            const currentLayer = Number(existing.layer);
            if (!Number.isFinite(currentLayer) || layer < currentLayer) existing.layer = layer;
          }
          return existing;
        }
        const rec = index.get(token);
        if (!rec) return null;
        const node = { token, f: freqFor(rec), layer: Number.isFinite(layer) ? layer : 0, degree: 0 };
        graph.nodes.set(token, node);
        return node;
      };
      const pushLink = (from, to, rtype, weight, hiddenTokens = []) => {
        const key = `${from}|${rtype}|${to}`;
        if (seenTriple.has(key)) return false;
        seenTriple.add(key);
        const hidden = Array.isArray(hiddenTokens) ? hiddenTokens.filter(Boolean) : [];
        graph.links.push({ from, to, rtype, w: weight, hiddenTokens: hidden });
        outSet.add(from);
        inSet.add(to);
        const fromNode = graph.nodes.get(from);
        const toNode = graph.nodes.get(to);
        if (fromNode) fromNode.degree = (fromNode.degree || 0) + 1;
        if (toNode) toNode.degree = (toNode.degree || 0) + 1;
        expanded += 1;
        if (loggingActive && expanded % tick === 0) {
          logProgress(expanded, expanded + Math.max(0, queue.length - head));
        }
        return true;
      };
      const queueNext = (from, to, rtype, weight, depth) => {
        queue.push({ from, to, rtype, w: weight, depth });
        enqueued += 1;
      };
      const expandSource = (token, depth) => {
        const rec = index.get(token);
        if (!rec) return;
        ensureNode(token, depth);
        const matrix = buildMatrixForRecord(rec);
        const relations = Array.isArray(matrix?.edges) ? matrix.edges.slice(0, getRelationTypeCap()) : [];
        for (const relation of relations) {
          const rawItems = Array.isArray(relation?.items)
            ? relation.items.slice()
            : [];
          if (!rawItems.length) continue;
          const limit = getEdgesPerType();
          const visibleItems = limit === Infinity ? rawItems : rawItems.slice(0, limit);
          if (!visibleItems.length) continue;
          const hiddenItems = limit === Infinity ? [] : rawItems.slice(visibleItems.length);
          const hiddenTokens = hiddenItems.map(item => item?.token).filter(Boolean);
          let enumerated = false;
          const nextDepth = depth + 1;
          for (const item of visibleItems) {
            const target = item?.token;
            if (!target) continue;
            const targetRec = index.get(target);
            if (!targetRec) continue;
            ensureNode(target, nextDepth);
            const weight = Number.isFinite(item?.weight)
              ? item.weight
              : Number.isFinite(item?.w)
                ? item.w
                : relation?.aggWeight;
            const normalizedWeight = Number(weight) || 0;
            const added = pushLink(token, target, relation?.rtype, normalizedWeight, hiddenTokens);
            if (added) {
              enumerated = true;
              if (depth < maxDepth) {
                queueNext(token, target, relation?.rtype, normalizedWeight, nextDepth);
              } else if (frac > 0) {
                fractionalNodes.add(target);
              }
            }
          }
          if (enumerated) edgeTypeEnums += 1;
        }
      };

      for (const anchor of anchors) {
        if (!index.get(anchor)) continue;
        ensureNode(anchor, 0);
        expandSource(anchor, 0);
        visitedSrc.add(anchor);
      }

      logPhase('anchored', { anchors: anchors.length, queued: enqueued });

      while (head < queue.length) {
        const edge = queue[head++];
        if (!edge) break;
        if (edge.depth > maxDepth) continue;
        if (visitedSrc.has(edge.to)) continue;
        expandSource(edge.to, edge.depth);
        visitedSrc.add(edge.to);
        if (!opts.silent && expanded % 1000 === 0) {
          logPhase('tick', { expanded, queued: Math.max(0, queue.length - head), nodes: graph.nodes.size, link_instances: graph.links.length });
          await microtask();
        }
      }

      if (frac > 0 && fractionalNodes.size) {
        logPhase('fractional', { added: fractionalNodes.size });
      }

      logProgress(1, 1);
      const metrics = {
        nodes: outSet.size,
        edges: edgeTypeEnums,
        relationships: graph.links.length,
        anchors: [...outSet].filter((t) => inSet.has(t)).length,
      };
      graph._metrics = metrics;
      logPhase('summary', metrics);
      return graph;
    }

    function computeDbStats(index) {
      if (!(index instanceof Map)) {
        return {
          tokens: 0,
          edges: 0,
          relationships: 0,
          nodes: 0,
          anchors: 0,
          minEdges: { count: 0, tokens: [] },
          maxEdges: { count: 0, tokens: [] },
        };
      }

      const outSet = new Set();
      const inSet = new Set();
      let relInstances = 0;
      let edgeTypeEnums = 0;
      let minEdgeCount = Infinity;
      let maxEdgeCount = 0;
      const minEdgeTokens = new Set();
      const maxEdgeTokens = new Set();

      for (const [src, rec] of index) {
        if (!rec || typeof rec !== 'object') continue;
        const rels = rec.relationships || {};
        let srcHasType = 0;
        let srcEdgeCount = 0;
        for (const [rtype, arr] of Object.entries(rels)) {
          if (!Array.isArray(arr) || arr.length === 0) continue;
          srcHasType += 1;
          srcEdgeCount += arr.length;
          for (const rel of arr) {
            const tgt = rel?.token;
            if (!tgt) continue;
            relInstances += 1;
            outSet.add(src);
            inSet.add(tgt);
          }
        }
        edgeTypeEnums += srcHasType;

        if (srcEdgeCount < minEdgeCount) {
          minEdgeCount = srcEdgeCount;
          minEdgeTokens.clear();
          minEdgeTokens.add(src);
        } else if (srcEdgeCount === minEdgeCount) {
          minEdgeTokens.add(src);
        }

        if (srcEdgeCount > maxEdgeCount) {
          maxEdgeCount = srcEdgeCount;
          maxEdgeTokens.clear();
          maxEdgeTokens.add(src);
        } else if (srcEdgeCount === maxEdgeCount) {
          maxEdgeTokens.add(src);
        }
      }

      const tokens = index.size;
      const anchors = [...outSet].filter((t) => inSet.has(t)).length;

      if (minEdgeCount === Infinity) {
        minEdgeCount = 0;
      }

      const limitTokenList = (set) => {
        if (!(set instanceof Set) || set.size === 0) return [];
        const out = [];
        for (const token of set) {
          out.push(token);
          if (out.length >= 50) break;
        }
        return out;
      };

      return {
        tokens,
        edges: edgeTypeEnums,
        relationships: relInstances,
        nodes: outSet.size,
        anchors,
        minEdges: {
          count: minEdgeCount,
          tokens: limitTokenList(minEdgeTokens),
        },
        maxEdges: {
          count: maxEdgeCount,
          tokens: limitTokenList(maxEdgeTokens),
        },
      };
    }

    function ensureGraphMetrics(graph) {
      if (!graph) {
        return { nodes: 0, relationships: 0, anchors: 0, edges: 0 };
      }
      if (graph._metrics && typeof graph._metrics === 'object') return graph._metrics;
      const out = new Set();
      const inn = new Set();
      const links = Array.isArray(graph.links)
        ? graph.links
        : (Array.isArray(graph.edges) ? graph.edges : []);
      const edgeTypes = new Set();
      const triples = new Set();
      for (const edge of links) {
        if (edge?.from) out.add(edge.from);
        if (edge?.to) inn.add(edge.to);
        if (edge?.from && edge?.rtype) edgeTypes.add(`${edge.from}|${edge.rtype}`);
        if (edge?.from && edge?.to && edge?.rtype) triples.add(`${edge.from}|${edge.rtype}|${edge.to}`);
      }
      const anchors = [...out].filter((t) => inn.has(t)).length;
      return {
        nodes: out.size,
        relationships: triples.size || links.length,
        anchors,
        edges: edgeTypes.size || links.length,
      };
    }

    function microtask() {
      return new Promise(resolve => queueMicrotask(resolve));
    }

    function activeRelationTypes(index, scope, stateRelTypes) {
      const cap = clampRelationTypeCap(window.HLSF?.config?.relationTypeCap);
      if (scope === 'state' && stateRelTypes && Number.isFinite(stateRelTypes.maxPresent)) {
        return Math.min(cap, Math.max(0, stateRelTypes.maxPresent | 0));
      }
      return cap;
    }

    function nonEmptyTypes(index) {
      const has = new Set();
      if (index instanceof Map) {
        for (const [, rec] of index) {
          const rels = rec?.relationships;
          if (!rels || typeof rels !== 'object') continue;
          for (const [rtype, arr] of Object.entries(rels)) {
            if (Array.isArray(arr) && arr.length) has.add(rtype);
          }
        }
      }
      return [...has].sort((a, b) => a.localeCompare(b));
    }

    function computeDimension(index, scope, stateRelTypes) {
      const types = nonEmptyTypes(index);
      const Treq = activeRelationTypes(index, scope, stateRelTypes);
      const limited = types.slice(0, Math.max(0, Treq));
      return { D: 2 * limited.length, types: limited };
    }

    function degrees(rec) {
      let out = 0;
      let in_ = 0;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          out += 1;
          for (const rel of arr) {
            in_ += rel?.incoming ? 1 : 0;
          }
        }
      }
      return { out, in_ };
    }

    function signature(rec) {
      const weights = new Map();
      for (const arr of Object.values(rec?.relationships || {})) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const token = rel?.token;
          if (!token) continue;
          const weight = Number.isFinite(rel?.weight)
            ? rel.weight
            : Number.isFinite(rel?.w)
              ? rel.w
              : 1;
          weights.set(token, (weights.get(token) || 0) + weight);
        }
      }
      return weights;
    }

    function cosineSignature(a, b) {
      let dot = 0;
      let na = 0;
      let nb = 0;
      for (const [k, va] of a.entries()) {
        na += va * va;
        const vb = b.get(k) || 0;
        if (vb) dot += va * vb;
      }
      for (const vb of b.values()) nb += vb * vb;
      const denom = Math.sqrt(Math.max(na, 0) * Math.max(nb, 0));
      return denom ? dot / denom : 0;
    }

    function selectAnchors(index, D) {
      if (!(index instanceof Map) || D <= 0) return [];
      const sigs = new Map();
      const tokens = [...index.keys()].sort((a, b) => a.localeCompare(b));
      const allSigs = tokens.map(token => {
        const rec = index.get(token) || {};
        const sig = signature(rec);
        sigs.set(token, sig);
        return [token, sig];
      });
      const sample = allSigs.slice(0, Math.min(512, allSigs.length));
      const scored = tokens.map(token => {
        const rec = index.get(token) || {};
        const { out, in_ } = degrees(rec);
        const freq = Number.isFinite(rec?.frequency)
          ? rec.frequency
          : Number.isFinite(rec?.f)
            ? rec.f
            : Number.isFinite(rec?.freq)
              ? rec.freq
              : 0;
        let ac = 0;
        const sig = sigs.get(token) || new Map();
        for (const [, otherSig] of sample) {
          ac += cosineSignature(sig, otherSig);
        }
        ac /= Math.max(1, sample.length);
        const score = 0.4 * freq + 0.3 * out + 0.2 * in_ + 0.1 * ac;
        return { token, score, out, in_ };
      });
      scored.sort((a, b) => (b.score - a.score) || a.token.localeCompare(b.token));
      return scored.slice(0, D).map(entry => entry.token);
    }

    function clusterToAnchors(index, anchors) {
      const groups = new Map();
      if (!(index instanceof Map) || !Array.isArray(anchors)) return groups;
      const orderedAnchors = [...anchors];
      for (const anchor of orderedAnchors) {
        groups.set(anchor, []);
      }
      if (!orderedAnchors.length) return groups;
      const anchorSigs = new Map(orderedAnchors.map(a => [a, signature(index.get(a) || {})]));
      for (const [token, rec] of index.entries()) {
        if (anchorSigs.has(token)) continue;
        const sig = signature(rec || {});
        let best = orderedAnchors[0];
        let bestScore = -Infinity;
        for (const anchor of orderedAnchors) {
          const c = cosineSignature(sig, anchorSigs.get(anchor) || new Map());
          if (c > bestScore) {
            bestScore = c;
            best = anchor;
          }
        }
        groups.get(best).push(token);
      }
      for (const [anchor, list] of groups) {
        list.sort((a, b) => a.localeCompare(b));
      }
      return groups;
    }

    function packLevels(index, scope, state) {
      const stateRelTypes = state?.relationTypes || {};
      const { D, types } = computeDimension(index, scope, stateRelTypes);
      const tokensCount = scope === 'state'
        ? (state?.tokens instanceof Set ? state.tokens.size : index.size)
        : index.size;
      const anchors = selectAnchors(index, Math.min(D || tokensCount, tokensCount));
      const effectiveD = Math.min(D, Math.max(anchors.length, 0));
      const levels = [];
      levels.push({ cells: [{ anchor: null, tokens: anchors.slice(0, Math.min(effectiveD || anchors.length, anchors.length)) }] });

      if (!effectiveD || tokensCount <= effectiveD) {
        return { D, effectiveD: Math.min(tokensCount, effectiveD), levels, anchors, types };
      }

      const clusters = clusterToAnchors(index, anchors);
      const cells = [];
      for (const anchor of anchors) {
        const list = clusters.get(anchor) || [];
        const combined = [anchor, ...list];
        const cellTokens = combined.slice(0, effectiveD || combined.length);
        cells.push({ anchor, tokens: cellTokens });
      }
      levels.push({ cells });

      const pool = [];
      for (const anchor of anchors) {
        const list = clusters.get(anchor) || [];
        const combined = [anchor, ...list];
        if (combined.length > (effectiveD || combined.length)) {
          pool.push(...combined.slice(effectiveD));
        }
      }

      if (pool.length) {
        const L2cells = [];
        const span = Math.max(1, effectiveD || 1);
        const blocks = Math.ceil(pool.length / span);
        for (let i = 0; i < blocks; i++) {
          const anchor = cells[i % cells.length]?.anchor ?? null;
          const start = i * span;
          const slice = pool.slice(start, start + span);
          if (!slice.length) continue;
          L2cells.push({ anchor, tokens: slice });
        }
        if (L2cells.length) levels.push({ cells: L2cells });
      }

      return { D, effectiveD, levels, anchors, types };
    }

    function layoutPolygon(tokens, angles, radius, levelIndex) {
      const tau = Math.PI * 2;
      const out = [];
      if (!Array.isArray(tokens) || !tokens.length) return out;
      const useAngles = Array.isArray(angles) && angles.length ? angles : tokens.map((_, i) => (tau * i) / Math.max(1, tokens.length));
      for (let i = 0; i < tokens.length; i++) {
        const angle = useAngles[i % useAngles.length];
        const normAngle = normalizeAngle(angle);
        out.push({ token: tokens[i], angle: normAngle, radius, level: levelIndex, cellIndex: 0 });
      }
      return out;
    }

    function layoutSectorPolygon(tokens, baseAngle, sectorSpan, radius, levelIndex, cellIndex) {
      const tau = Math.PI * 2;
      const out = [];
      if (!Array.isArray(tokens) || !tokens.length) return out;
      if (tokens.length === 1) {
        out.push({ token: tokens[0], angle: normalizeAngle(baseAngle), radius, level: levelIndex, cellIndex });
        return out;
      }
      const step = sectorSpan / Math.max(tokens.length, 1);
      const start = baseAngle - (sectorSpan / 2) + step / 2;
      for (let i = 0; i < tokens.length; i++) {
        const angle = normalizeAngle(start + i * step);
        out.push({ token: tokens[i], angle, radius, level: levelIndex, cellIndex });
      }
      return out;
    }

    function normalizeAngle(angle) {
      const tau = Math.PI * 2;
      let a = angle % tau;
      if (a < 0) a += tau;
      return a;
    }

    function computeActiveAngles(types) {
      const count = Math.max(0, types.length * 2);
      if (!count) return [];
      const tau = Math.PI * 2;
      const step = tau / count;
      return Array.from({ length: count }, (_, i) => normalizeAngle(i * step));
    }

    function placeLevels(levels, effectiveD, activeAngles) {
      const positions = new Map();
      const cellsGeom = [];
      const placed = new Set();
      const anchorAngles = new Map();
      const levelCount = Array.isArray(levels) ? levels.length : 0;
      const tau = Math.PI * 2;
      let maxRadius = 0;

      if (!levelCount) {
        return { positions, cells: cellsGeom, maxRadius: 0, anchorAngles };
      }

      const first = levels[0]?.cells?.[0]?.tokens || [];
      const radius0 = 1;
      const l0 = layoutPolygon(first, activeAngles.slice(0, first.length), radius0, 0);
      maxRadius = Math.max(maxRadius, radius0);
      const cell0 = [];
      for (let i = 0; i < l0.length; i++) {
        const entry = l0[i];
        if (!positions.has(entry.token)) {
          positions.set(entry.token, entry);
          placed.add(entry.token);
          anchorAngles.set(entry.token, entry.angle);
        }
        cell0.push(entry);
      }
      cellsGeom.push({ level: 0, index: 0, anchor: null, tokens: cell0 });

      for (let levelIndex = 1; levelIndex < levelCount; levelIndex++) {
        const level = levels[levelIndex];
        const cells = Array.isArray(level?.cells) ? level.cells : [];
        const isLast = levelIndex === levelCount - 1;
        const radius = levelIndex + 1;
        maxRadius = Math.max(maxRadius, radius);
        const components = isLast ? cells.length : Math.max(activeAngles.length, cells.length, 1);
        const step = components ? tau / components : tau;
        for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
          const cell = cells[cellIndex];
          const anchor = cell?.anchor ?? null;
          let baseAngle;
          if (isLast) {
            baseAngle = cellIndex * step;
          } else if (levelIndex === 1 && anchor != null && anchorAngles.has(anchor)) {
            baseAngle = anchorAngles.get(anchor);
          } else if (activeAngles.length) {
            baseAngle = activeAngles[cellIndex % activeAngles.length];
          } else {
            baseAngle = cellIndex * step;
          }
          const tokens = Array.isArray(cell?.tokens) ? cell.tokens : [];
          const fresh = tokens.filter(token => !placed.has(token));
          const sectorSpan = step;
          const placedEntries = layoutSectorPolygon(fresh, baseAngle, sectorSpan, radius, levelIndex, cellIndex);
          for (const entry of placedEntries) {
            positions.set(entry.token, entry);
            placed.add(entry.token);
          }
          const geomTokens = tokens.map(token => {
            const existing = positions.get(token);
            if (existing) {
              return Object.assign({}, existing, { cellIndex });
            }
            const angle = normalizeAngle(baseAngle);
            return { token, angle, radius, level: levelIndex, cellIndex };
          });
          cellsGeom.push({ level: levelIndex, index: cellIndex, anchor, tokens: geomTokens });
        }
      }

      return { positions, cells: cellsGeom, maxRadius, anchorAngles };
    }

    function computeLayout(graph, index, options = {}) {
      if (!graph) return { nodes: 0, edges: 0 };
      const idx = index instanceof Map ? index : window.HLSF?.lastCommand?.idx;
      const baseIndex = idx instanceof Map ? idx : new Map();
      const config = window.HLSF?.config || {};
      const desiredScope = (options?.scope || config.hlsfScope || 'db').toLowerCase();
      let scope = desiredScope === 'state' ? 'state' : 'db';

      const sessionTokens = window.Session?.tokens instanceof Set ? window.Session.tokens : new Set();
      const scopedTokens = new Set();
      if (scope === 'state') {
        for (const token of sessionTokens) {
          if (baseIndex.has(token)) scopedTokens.add(token);
        }
        if (!scopedTokens.size) scope = 'db';
      }

      let scopedIndex;
      if (scope === 'state') {
        scopedIndex = new Map();
        for (const token of scopedTokens) {
          scopedIndex.set(token, baseIndex.get(token));
        }
      } else {
        scopedIndex = baseIndex;
        for (const token of baseIndex.keys()) scopedTokens.add(token);
      }

      if (!(scopedIndex instanceof Map) || scopedIndex.size === 0) {
        scopedIndex = baseIndex;
        for (const token of baseIndex.keys()) scopedTokens.add(token);
      }

      const typeList = nonEmptyTypes(scopedIndex);
      const packed = packLevels(scopedIndex, scope, { relationTypes: { maxPresent: typeList.length }, tokens: scopedTokens });
      const activeAngles = computeActiveAngles(packed.types || []);
      const placed = placeLevels(packed.levels, packed.effectiveD, activeAngles);
      const metrics = computeDbStats(scopedIndex);

      const positions = placed.positions;
      const ensurePosition = (token) => {
        if (positions.has(token)) return;
        const radius = (placed.maxRadius || 1) + 1;
        positions.set(token, { token, angle: 0, radius, level: packed.levels.length, cellIndex: 0 });
      };
      for (const token of scopedIndex.keys()) ensurePosition(token);

      const newNodes = new Map();
      for (const [token, rec] of scopedIndex.entries()) {
        const node = graph.nodes.get(token) || {};
        const freq = Number.isFinite(rec?.frequency)
          ? rec.frequency
          : Number.isFinite(rec?.f)
            ? rec.f
            : Number.isFinite(rec?.freq)
              ? rec.freq
              : node.f;
        node.token = token;
        if (Number.isFinite(freq)) node.f = freq;
        const pos = positions.get(token);
        if (pos) {
          node.layer = pos.level;
          node.cluster = pos.cellIndex;
        }
        newNodes.set(token, node);
      }
      graph.nodes = newNodes;

      const levelCount = Array.isArray(packed.levels) ? packed.levels.length : 0;
      const lastLevelComponents = levelCount ? (packed.levels[levelCount - 1]?.cells?.length || 0) : 0;
      const layout = {
        scope,
        dimension: packed.D,
        effectiveDimension: packed.effectiveD,
        anchors: packed.anchors,
        levels: packed.levels,
        cells: placed.cells,
        activeAngles,
        positions,
        maxRadius: placed.maxRadius || levelCount || 1,
        anchorAngles: placed.anchorAngles,
        metrics,
        levelCount,
        lastLevelComponents,
        types: packed.types,
      };

      graph.dimensionLayout = layout;
      graph.anchors = Array.isArray(packed.anchors) ? packed.anchors : graph.anchors;
      graph._metrics = metrics;

      const linkCount = Array.isArray(graph.links)
        ? graph.links.length
        : (Array.isArray(graph.edges) ? graph.edges.length : 0);
      return {
        nodes: newNodes.size,
        edges: linkCount,
        layout,
        metrics,
      };
    }

    function prepareBuffers(graph, layout, options = {}) {
      const glyphOnly = options?.glyphOnly === true;
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly;
      window.HLSF.currentLayoutSnapshot = layout;
      if (window.HLSF?.state) {
        window.HLSF.state.patches = new Map();
        window.HLSF.state.emergentRot = 0;
      }
    }

    function anchorsForMode(args, idx){
      let index = idx;
      if (!(index instanceof Map)) {
        const db = getDb();
        if (!db) throw new Error('No DB loaded');
        loadGlyphMaps(db);
        index = buildIndex(db);
      }

      if (args.mode === 'conversation') {
        const conv = [...(Session?.tokens || [])].filter(t => index.has(t));
        const anchors = conv.length ? conv : defaultAnchors(index, 32);
        return { anchors, idx: index };
      }

      if (args.mode === 'tokens') {
        let anchors = args.tokens.filter(t => index.has(t));
        if (!anchors.length) anchors = defaultAnchors(index, 32);
        return { anchors, idx: index };
      }

      if (args.mode === 'glyphs') {
        const glyphTokens = [];
        for (const glyph of args.glyphs) {
          const val = GlyphToToken.get(glyph);
          if (!val) continue;
          if (val instanceof Set) glyphTokens.push(...val);
          else if (Array.isArray(val)) glyphTokens.push(...val);
          else glyphTokens.push(val);
        }
        const toks = glyphTokens.filter(t => index.has(t));
        const anchors = toks.length ? toks : defaultAnchors(index, 32);
        return { anchors, idx: index, glyphOnly: true };
      }

      const cap = getAnchorCap(index);
      const limit = cap > 0 ? cap : index.size;
      return { anchors: defaultAnchors(index, limit), idx: index };
    }

    function nodeLabel(token, glyphOnly = false) {
      const glyph = TokenToGlyph.get(token);
      if (glyphOnly && glyph) return glyph;
      return glyph || token;
    }

    function edgeLabel(rtype) {
      if (typeof rtype !== 'string') return '';
      const cleaned = rtype.trim();
      if (!cleaned) return '';

      const normalized = normRelKey(cleaned);
      if (normalized) return REL_EN[normalized] || '';

      const withoutGlyph = cleaned.replace(/^[\p{S}\p{P}]+\s*/u, '');
      return withoutGlyph || cleaned;
    }

    function legacyPositions(graph, width, height, scale, centerX, centerY) {
      const anchorList = Array.isArray(graph?.anchors) && graph.anchors.length
        ? graph.anchors
        : Array.isArray(graph?.seeds) && graph.seeds.length
          ? graph.seeds
          : [...graph.nodes.keys()].slice(0, 1);
      const pos = new Map();
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;
      const Rc = Math.min(width, height) * 0.35 * scale;
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;

      anchorList.forEach((token, idx) => {
        const angle = (idx / Math.max(1, anchorList.length)) * Math.PI * 2 + rotation;
        const x = cx + Rc * Math.cos(angle);
        const y = cy + Rc * Math.sin(angle);
        pos.set(token, { x, y });
      });

      const groupByRoot = new Map();
      const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
      edges.forEach(edge => {
        if (!groupByRoot.has(edge.from)) groupByRoot.set(edge.from, []);
        groupByRoot.get(edge.from).push(edge);
      });

      for (const [root, edges] of groupByRoot.entries()) {
        const base = pos.get(root) || { x: cx, y: cy };
        const R = Math.min(width, height) * 0.18 * scale;
        const sorted = [...edges].sort((a, b) => b.w - a.w);
        const denom = Math.max(1, sorted.length - 1);
        sorted.forEach((edge, i) => {
          const theta = Math.PI * (i / denom);
          const x = base.x + R * Math.cos(theta);
          const y = base.y - R * Math.sin(theta);
          if (!pos.has(edge.to)) pos.set(edge.to, { x, y });
        });
      }

      return pos;
    }

    function clusterLevelLayout(graph, width, height, scale, centerX, centerY) {
      const rot = window.HLSF.state?.globalRot || 0;
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;
      let Lmax = 0;
      for (const node of graph.nodes.values()) {
        const layer = node?.layer;
        if (Number.isFinite(layer)) Lmax = Math.max(Lmax, layer | 0);
      }

      const layerCluster = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        const arr = layerCluster.get(key) || [];
        arr.push(token);
        layerCluster.set(key, arr);
      }

      const layers = Array.from({ length: Lmax + 1 }, () => new Map());
      for (const [key, toks] of layerCluster.entries()) {
        const [layerStr, clusterStr] = key.split(':');
        const layer = Number(layerStr) || 0;
        const cluster = Number(clusterStr) || 0;
        const bucket = layers[layer];
        toks.sort();
        bucket.set(cluster, toks);
      }

      const Rmax = Math.min(width, height) * 0.45 * scale;
      const dr = Rmax / Math.max(1, Lmax + 1);
      const pos = new Map();

      for (let layer = 0; layer < layers.length; layer++) {
        const entries = [...layers[layer].entries()]
          .sort((a, b) => b[1].length - a[1].length || a[0] - b[0]);
        const R = Math.max(20, dr * (layer + 1));
        const sectors = Math.max(1, entries.length);
        for (let s = 0; s < entries.length; s++) {
          const tokens = entries[s][1];
          const phi0 = rot + (s / sectors) * Math.PI * 2;
          const span = (Math.PI * 2) / sectors;
          const N = tokens.length;
          for (let i = 0; i < N; i++) {
            const theta = phi0 + (i / Math.max(1, N)) * span;
            const wobble = i % 2 ? 0.92 : 0.98;
            const r = R * wobble;
            pos.set(tokens[i], {
              x: cx + r * Math.cos(theta),
              y: cy + r * Math.sin(theta)
            });
          }
        }
      }
      return pos;
    }

    function ringPositions(graph, width, height, scale, centerX, centerY) {
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;
      let L = 0;
      for (const node of graph.nodes.values()) {
        const rawLayer = node && Number.isFinite(node.layer) ? node.layer : 0;
        const layer = Math.max(0, Math.floor(rawLayer));
        if (layer > L) L = layer;
      }

      const rings = Array.from({ length: L + 1 }, () => []);
      for (const [token, node] of graph.nodes.entries()) {
        const layer = node && Number.isFinite(node.layer)
          ? Math.max(0, Math.floor(node.layer))
          : 0;
        rings[layer].push({ token, node });
      }

      for (const ring of rings) {
        ring.sort((a, b) => ((b.node?.degree || 0) - (a.node?.degree || 0)) || a.token.localeCompare(b.token));
      }

      const Rmax = Math.min(width, height) * 0.42 * scale;
      const dr = Rmax / Math.max(1, L + 1);
      const pos = new Map();
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;

      for (let layer = 0; layer < rings.length; layer++) {
        const ring = rings[layer];
        if (!ring.length) continue;
        const R = Math.max(20, dr * (layer + 1));
        const N = ring.length;
        for (let i = 0; i < N; i++) {
          const theta = (i / N) * 2 * Math.PI + rotation;
          pos.set(ring[i].token, {
            x: cx + R * Math.cos(theta),
            y: cy + R * Math.sin(theta)
          });
        }
      }

      return pos;
    }

    function drawClusterOverlays(ctx, graph, positions) {
      const byLC = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        const arr = byLC.get(key) || [];
        arr.push(token);
        byLC.set(key, arr);
      }
      ctx.save();
      for (const [key, tokens] of byLC) {
        if (tokens.length < 3) continue;
        const pts = tokens.map(t => positions.get(t)).filter(Boolean);
        if (pts.length < 3) continue;
        const color = paletteColor(`cluster-${key}`);
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawComposite(graph, opts = {}) {
      const cfg = window.HLSF.config;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found');
        return;
      }
      const ctx = window.HLSF.ctx || (window.HLSF.ctx = canvas.getContext('2d'));
      const dpr = window.devicePixelRatio || 1;
      const displayWidth = canvas.clientWidth || canvas.width || 0;
      const displayHeight = canvas.clientHeight || canvas.height || 0;
      const bufferWidth = Math.max(1, Math.round(displayWidth * dpr));
      const bufferHeight = Math.max(1, Math.round(displayHeight * dpr));
      if (canvas.width !== bufferWidth || canvas.height !== bufferHeight) {
        canvas.width = bufferWidth;
        canvas.height = bufferHeight;
      }
      const width = displayWidth || canvas.width / dpr;
      const height = displayHeight || canvas.height / dpr;
      const theme = cfg.whiteBg
        ? { bg: '#fff', fg: '#000', hint: '#444' }
        : { bg: '#000', fg: '#fff', hint: '#bbb' };
      const edgeColorMode = normalizeEdgeColorMode(cfg.edgeColorMode);
      const edgeWidthControl = document.getElementById('edgew');
      const edgeWidth = clampEdgeWidth(cfg.edgeWidth);
      const nodeScale = clampNodeSize(cfg.nodeSize);
      const showGlow = cfg.showNodeGlow === true;

      if (!window.HLSF.__centerInit) {
        window.HLSF.view.x = width / 2;
        window.HLSF.view.y = height / 2;
        syncViewToConfig();
        window.HLSF.__centerInit = true;
      }

      syncViewToConfig();
      const view = window.HLSF.view;
      const zoom = Number.isFinite(view.scale) ? view.scale : 1;

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.translate(view.x, view.y);
      ctx.scale(zoom, zoom);
      ctx.strokeStyle = theme.fg;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const controlValue = edgeWidthControl ? parseFloat(edgeWidthControl.value) : NaN;
      const edgeWidthValue = Number.isFinite(controlValue) ? controlValue : edgeWidth;
      const safeZoom = Math.max(zoom, 1e-4);
      const zoomAttenuation = Math.max(0.2, Math.min(5, 1 / Math.sqrt(safeZoom)));
      ctx.lineWidth = Math.max(0.01, edgeWidthValue * zoomAttenuation) * dpr;
      const fontScale = Math.max(0.35, Math.min(3, zoomAttenuation));
      ctx.font = `${Math.max(9, Math.round(12 * fontScale))}px 'Fira Code', monospace`;

      const layoutScale = 1;
      const layoutMode = normalizeLayout(window.HLSF.config.layout);
      let pos;
      if (layoutMode === 'dimension' && graph.dimensionLayout) {
        const dim = graph.dimensionLayout;
        const radialMax = Math.max(1, dim.maxRadius || 1);
        const radiusScale = Math.min(width, height) * 0.42 * layoutScale;
        pos = new Map();
        for (const [token, entry] of dim.positions.entries()) {
          const radius = (entry?.radius || 1) / radialMax * radiusScale;
          const angle = entry?.angle || 0;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          pos.set(token, { x, y });
        }
      } else if (layoutMode === 'affinity') {
        pos = clusterLevelLayout(graph, width, height, layoutScale, 0, 0);
      } else if (layoutMode === 'layered') {
        pos = ringPositions(graph, width, height, layoutScale, 0, 0);
      } else {
        pos = legacyPositions(graph, width, height, layoutScale, 0, 0);
      }

      const patches = computePatches(graph, pos);
      window.HLSF.state.patches = patches;
      const rotatedPositions = new Map();
      for (const [token, base] of pos.entries()) {
        const node = graph.nodes.get(token);
        rotatedPositions.set(token, rotatedPos(token, base, node));
      }

      if (layoutMode === 'affinity') {
        drawClusterOverlays(ctx, graph, rotatedPositions);
      }

      if (layoutMode === 'dimension' && graph.dimensionLayout) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        const polyWidth = Math.max(0.01, Math.min(1, edgeWidthValue * zoomAttenuation)) * dpr;
        ctx.lineWidth = polyWidth;
        ctx.strokeStyle = theme.hint;
        const cells = Array.isArray(graph.dimensionLayout.cells) ? graph.dimensionLayout.cells : [];
        for (const cell of cells) {
          const tokens = Array.isArray(cell?.tokens) ? cell.tokens : [];
          const pts = tokens
            .map(t => rotatedPositions.get(t.token))
            .filter(Boolean);
          if (pts.length < 3) continue;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          ctx.closePath();
          ctx.stroke();
        }
        ctx.restore();
      }

      const glyphOnly = opts.glyphOnly === true;

      ctx.lineWidth = Math.max(0.01, edgeWidthValue * zoomAttenuation) * dpr;

      if (cfg.showEdges !== false) {
        const batches = new Map();
        const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
        for (const edge of edges) {
          const fromPos = rotatedPositions.get(edge.from) || rotatedPositions.get(edge.to);
          const toPos = rotatedPositions.get(edge.to);
          if (!fromPos || !toPos) continue;
          const viewScale = window.HLSF?.view?.scale ?? zoom;
          const dx = (toPos.x - fromPos.x) * viewScale;
          const dy = (toPos.y - fromPos.y) * viewScale;
          if ((dx * dx + dy * dy) < 0.25) continue;
          const strokeColor = compositeEdgeStrokeColor(edge, edgeColorMode) || theme.fg;
          if (!batches.has(strokeColor)) batches.set(strokeColor, []);
          batches.get(strokeColor).push({ from: fromPos, to: toPos, edge });
        }
        for (const [color, edges] of batches.entries()) {
          ctx.strokeStyle = color;
          for (const { from, to, edge } of edges) {
            ctx.globalAlpha = edgeAlphaFromWeight(edge.w);
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
            if (cfg.showLabels !== false) {
              const mx = (from.x + to.x) / 2;
              const my = (from.y + to.y) / 2;
              ctx.globalAlpha = baseAlpha();
              const glyph = edgeLabel(edge.rtype);
              if (glyph) {
                ctx.fillStyle = theme.hint;
                ctx.fillText(glyph, mx, my - 10);
              }
              const hiddenTokens = Array.isArray(edge.hiddenTokens) ? edge.hiddenTokens : [];
              if (hiddenTokens.length) {
                const preview = hiddenTokens.slice(0, 3);
                let hiddenLabel = preview.join(', ');
                const remaining = hiddenTokens.length - preview.length;
                if (remaining > 0) hiddenLabel += ` +${remaining}`;
                if (hiddenLabel) {
                  const dx = to.x - from.x;
                  const dy = to.y - from.y;
                  const dist = Math.hypot(dx, dy) || 1;
                  const offset = 16;
                  const hx = to.x + (dx / dist) * offset;
                  const hy = to.y + (dy / dist) * offset;
                  ctx.globalAlpha = baseAlpha() * 0.75;
                  ctx.fillStyle = cfg.whiteBg ? 'rgba(0,0,0,0.45)' : 'rgba(255,255,255,0.45)';
                  ctx.fillText(hiddenLabel, hx, hy);
                  ctx.globalAlpha = baseAlpha();
                }
              }
              ctx.fillStyle = theme.fg;
            }
          }
        }
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = theme.fg;
      }

      for (const [token, data] of graph.nodes.entries()) {
        const position = rotatedPositions.get(token);
        if (!position) continue;
        const freq = typeof data.f === 'number' ? data.f : 1;
        const radius = Math.max(2, (4 + 2 * Math.log2(1 + Math.max(0, freq))) * nodeScale);
        ctx.globalAlpha = baseAlpha();
        ctx.save();
        if (showGlow) {
          ctx.shadowColor = 'rgba(0, 255, 136, 0.35)';
          ctx.shadowBlur = 14 * Math.max(1, zoom);
        }
        ctx.beginPath();
        ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        ctx.globalAlpha = 1.0;
        if (cfg.showLabels !== false) {
          ctx.globalAlpha = baseAlpha();
          ctx.fillStyle = theme.fg;
          ctx.fillText(nodeLabel(token, glyphOnly), position.x, position.y - (radius + 12));
          ctx.globalAlpha = 1.0;
        }
      }

      ctx.restore();
    }

    function computePatches(graph, pos) {
      const groups = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(token);
      }
      const patches = new Map();
      const prev = window.HLSF?.state?.patches;
      for (const [key, toks] of groups) {
        const pts = toks.map(t => pos.get(t)).filter(Boolean);
        if (!pts.length) continue;
        const cx = pts.reduce((sum, p) => sum + p.x, 0) / pts.length;
        const cy = pts.reduce((sum, p) => sum + p.y, 0) / pts.length;
        const prevPatch = prev instanceof Map ? prev.get(key) : null;
        const angle = prevPatch && Number.isFinite(prevPatch.angle) ? prevPatch.angle : 0;
        patches.set(key, { cx, cy, angle });
      }
      return patches;
    }

    function rotate_patches(dt) {
      const state = window.HLSF?.state;
      if (!state?.emergent?.on) return;
      const speed = Number.isFinite(state.emergent.speed) ? state.emergent.speed : 0;
      if (!speed) return;
      const patches = state.patches instanceof Map ? state.patches : null;
      if (!patches) return;
      const tau = Math.PI * 2;
      for (const patch of patches.values()) {
        const current = Number.isFinite(patch?.angle) ? patch.angle : 0;
        patch.angle = (current + speed * dt) % tau;
      }
    }

    function rotatedPos(token, basePos, node) {
      if (!basePos) return basePos;
      const state = window.HLSF?.state;
      if (!state?.emergent?.on) return basePos;
      const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
      const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
      const patchKey = `${layer}:${cluster}`;
      const patch = state.patches instanceof Map ? state.patches.get(patchKey) : null;
      if (!patch) return basePos;
      const angle = Number.isFinite(patch.angle) ? patch.angle : 0;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const x = basePos.x - patch.cx;
      const y = basePos.y - patch.cy;
      return { x: patch.cx + c * x - s * y, y: patch.cy + s * x + c * y };
    }

    // ---------------- O20 layout ----------------
    function buildO20Layout(width, height, margin = 32) {
      const cx = width / 2;
      const cy = height / 2;
      const R = Math.min(cx, cy) - margin;
      const slots = [];
      for (let i = 0; i < 20; i++) {
        const theta = Math.PI * (i / 19);
        slots.push({
          x: cx + R * Math.cos(theta),
          y: cy - R * Math.sin(theta),
          theta
        });
      }
      return { cx, cy, R, slots };
    }

    function getCachedO20Layout(width, height, margin = 32) {
      window.HLSF = window.HLSF || {};
      const cache = window.HLSF.layoutCache;
      if (cache && cache.width === width && cache.height === height && cache.margin === margin) {
        return cache.layout;
      }
      const layout = buildO20Layout(width, height, margin);
      window.HLSF.layoutCache = { width, height, margin, layout };
      return layout;
    }

    function applyFrequencyVisuals(f) {
      const value = typeof f === 'number' ? f : 0;
      const stats = window.HLSF?.metrics?.freqStats;
      if (!stats || typeof stats.min !== 'number' || typeof stats.max !== 'number') {
        const clamped = Math.min(1, Math.max(0, value));
        return { norm: clamped, isHigh: value >= 1 };
      }
      const range = stats.max - stats.min;
      const norm = range === 0 ? 0 : (value - stats.min) / range;
      const clamped = Math.min(1, Math.max(0, norm));
      const threshold = typeof stats.p90 === 'number' ? stats.p90 : stats.max;
      return { norm: clamped, isHigh: value >= threshold };
    }

    // ---------------- Canvas renderer ----------------
    function drawHLSFMatrix(graph, opts = {}) {
      drawComposite(graph, opts);
    }

    let _anim = null;
    function animateComposite(graph, glyphOnly = false) {
      if (!graph) return;
      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawComposite(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function animateHLSF(graph, glyphOnly = false) {
      if (!graph) return;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found for animation');
        return;
      }

      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawHLSFMatrix(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function stopHLSFAnimation() {
      if (_anim) {
        cancelAnimationFrame(_anim);
        _anim = null;
      }
      if (window.HLSF) {
        window.HLSF.currentGraph = null;
        window.HLSF.currentGlyphOnly = false;
        window.HLSF.__centerInit = false;
      }
      if (typeof stopLegacyHLSFAnimation === 'function') {
        try {
          stopLegacyHLSFAnimation();
        } catch (err) {
          console.warn('Legacy HLSF animation stop failed:', err);
        }
      }
    }

    const MAX_REL_TYPES = 50;
    const MAX_EDGES_PER_TYPE = 10;

    function clampRelationTypeCap(value) {
      if (value === Infinity) return Infinity;
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (norm === 'all' || norm === '∞' || norm === 'infinity') return Infinity;
      }
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return MAX_REL_TYPES;
      if (numeric <= 0) return MAX_REL_TYPES;
      return Math.min(MAX_REL_TYPES, Math.max(1, numeric));
    }

    function clampEdgesPerType(value) {
      if (value === Infinity) return Infinity;
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (norm === 'all' || norm === '∞' || norm === 'infinity') return Infinity;
      }
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return 3;
      if (numeric <= 0) return 3;
      return Math.min(MAX_EDGES_PER_TYPE, Math.max(1, numeric));
    }

    function clampEdgeWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0.02;
      return Math.min(1, Math.max(0.01, numeric));
    }

    function clampNodeSize(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1;
      return Math.min(2.5, Math.max(0.5, numeric));
    }

    function normalizeEdgeColorMode(value) {
      switch (value) {
        case 'weight':
        case 'relation':
          return value;
        default:
          return 'theme';
      }
    }

    function normalizeMetricScope(value) {
      if (value === METRIC_SCOPE.DB) return METRIC_SCOPE.DB;
      if (typeof value === 'string' && value.toLowerCase() === METRIC_SCOPE.DB) return METRIC_SCOPE.DB;
      return METRIC_SCOPE.RUN;
    }

    function normalizeLayout(value) {
      const v = typeof value === 'string' ? value.toLowerCase() : value;
      switch (v) {
        case 'dimension':
        case 'affinity':
        case 'layered':
        case 'legacy':
          return v;
        default:
          return 'dimension';
      }
    }

    function layoutLabel(value) {
      switch (normalizeLayout(value)) {
        case 'dimension':
          return 'Dimension NAM';
        case 'affinity':
          return 'Clusters × Levels';
        case 'layered':
          return 'Layered';
        case 'legacy':
          return 'Legacy';
        default:
          return 'Dimension NAM';
      }
    }

    function describeAffinityMentalState(threshold, iterations) {
      const thr = Number.isFinite(threshold) ? threshold : 0.35;
      const iters = Number.isFinite(iterations) ? iterations : 8;
      const thrBand = thr <= 0.2 ? 'low'
        : thr <= 0.4 ? 'medium'
        : thr <= 0.6 ? 'high'
        : 'veryHigh';
      const iterBand = iters <= 4 ? 'brief'
        : iters <= 9 ? 'steady'
        : 'extended';

      const STATES = {
        low: {
          brief: {
            name: 'Impulsive ideation',
            desc: 'Weak ties are welcomed but the loop stops quickly, so early, noisy neighbors shape the clusters.'
          },
          steady: {
            name: 'Expansive brainstorming',
            desc: 'Low thresholds keep associative links flowing while a few passes weave them into loose but lively groups.'
          },
          extended: {
            name: 'Hypnagogic free association',
            desc: 'Almost every tenuous link survives repeated revisits, letting clusters blend in a dreamlike drift.'
          }
        },
        medium: {
          brief: {
            name: 'Decisive synthesis',
            desc: 'Moderate evidence is required but only a handful of passes occur, yielding balanced snap decisions.'
          },
          steady: {
            name: 'Focused yet flexible attention',
            desc: 'Clustering balances evidence with patience, producing well-formed communities without overthinking.'
          },
          extended: {
            name: 'Reflective integration',
            desc: 'Moderate filters paired with long deliberation polish clusters through repeated, thoughtful reconciliation.'
          }
        },
        high: {
          brief: {
            name: 'Surgical categorization',
            desc: 'Only strong alignments are heeded and the loop resolves quickly, carving crisp, selective groups.'
          },
          steady: {
            name: 'Structured analytical focus',
            desc: 'Strict similarity demands with measured revisits create tight, compartmentalized communities.'
          },
          extended: {
            name: 'Perfectionistic rumination',
            desc: 'High selectivity and many passes continually prune ambiguous members in search of immaculate boundaries.'
          }
        },
        veryHigh: {
          brief: {
            name: 'Rigid snap judgments',
            desc: 'Only the strongest neighbors are considered and the process halts fast, leaving fragmented results.'
          },
          steady: {
            name: 'Guarded deliberation',
            desc: 'Strict gates with limited revisits keep clusters narrow while cautiously revisiting edge cases.'
          },
          extended: {
            name: 'Tunnel-vision fixation',
            desc: 'Extreme selectivity applied over many rounds replays only the most forceful convictions.'
          }
        }
      };

      const preset = STATES[thrBand] && STATES[thrBand][iterBand]
        ? STATES[thrBand][iterBand]
        : null;
      if (preset) return preset;
      return {
        name: 'Adaptive clustering',
        desc: `Threshold ${thr.toFixed(2)} with ${iters} iteration${iters === 1 ? '' : 's'} blends evidence filtering with iterative refinement.`
      };
    }

    function updateAffinityAnnotations(wrapper, threshold, iterations) {
      if (!wrapper) return;
      const { name, desc } = describeAffinityMentalState(threshold, iterations);
      const nameEl = wrapper.querySelector('#hlsf-mental-name');
      if (nameEl) nameEl.textContent = name;
      const summaryEl = wrapper.querySelector('#hlsf-affinity-summary');
      if (summaryEl) summaryEl.textContent = `Current mental state: ${name}.`;
      const descEl = wrapper.querySelector('#hlsf-mental-desc');
      if (descEl) descEl.textContent = desc;
      const mechanicsEl = wrapper.querySelector('#hlsf-affinity-mechanics');
      if (mechanicsEl) {
        const thr = Number.isFinite(threshold) ? threshold : 0.35;
        const iters = Number.isFinite(iterations) ? iterations : 8;
        const iterWord = iters === 1 ? 'iteration' : 'iterations';
        mechanicsEl.textContent = `Neighbors must score at least ${thr.toFixed(2)} on the 60/40 cosine–Jaccard affinity mix to influence clustering. The loop will revisit labels for up to ${iters} ${iterWord} before settling.`;
      }
    }

    function ensureHLSFCanvas() {
      let wrapper = document.getElementById('hlsf-canvas-container');
      if (wrapper) {
        if (window.HLSF.config.deferredRender === false) wrapper.classList.remove('hidden');
      } else {
        if (!elements?.log) {
          console.warn('Log element not ready for HLSF canvas');
          return null;
        }

        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;

        wrapper = document.createElement('div');
        wrapper.id = 'hlsf-canvas-container';
        wrapper.className = 'hlsf-canvas-container';
        if (window.HLSF.config.deferredRender !== false) wrapper.classList.add('hidden');
        wrapper.innerHTML = `
          <div class="section-title">🔭 HLSF Matrix Visualizer</div>
          <details id="hlsf-batch-log" open>
            <summary>Batch log</summary>
            <div id="hlsf-log-progress">
              <div id="hlsf-log-bar"></div>
            </div>
            <pre id="hlsf-log-stream"></pre>
            <button id="hlsf-log-download">Download log</button>
          </details>
          <canvas id="hlsf-canvas"></canvas>
          <div class="hlsf-controls">
            <div class="hlsf-control-group">
              <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
              <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
              <input id="hlsf-alpha" type="range" min="0.005" max="0.99" step="0.01" value="0.70">
            </div>
            <div class="hlsf-control-group">
              <label>Edge width <span id="edgew-val">0.02</span></label>
              <input id="edgew" type="range" min="0.01" max="1.00" step="0.005" value="0.02">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
              <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-color-mode">Edge coloring</label>
              <select id="hlsf-edge-color-mode">
                <option value="theme">Theme</option>
                <option value="weight">Weight</option>
                <option value="relation">Relation</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">${MAX_REL_TYPES}</span></label>
              <input id="hlsf-relation-cap" type="number" min="1" max="${MAX_REL_TYPES}" step="1" value="${MAX_REL_TYPES}">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-scope">Scope</label>
              <select id="hlsf-scope">
                <option value="db">DB</option>
                <option value="state">State</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label>Dimension metrics</label>
              <div class="hlsf-dimension-stats">
                <div>Anchors D: <span id="hlsf-dimension-d">—</span></div>
                <div>Level count L: <span id="hlsf-dimension-levels">—</span></div>
                <div>Last level components C: <span id="hlsf-dimension-last">—</span></div>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
              <input id="hlsf-edges-per-type" type="number" min="1" max="${MAX_EDGES_PER_TYPE}" step="1" value="3">
            </div>
            <div class="hlsf-control-group">
              <label>Display options</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
                <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
                <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
                <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
                <button id="hlsf-toggle-layout" class="btn btn-secondary">Layout: Affinity</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-aff-thresh">Affinity threshold <span id="hlsf-aff-thresh-val">0.35</span></label>
              <input id="hlsf-aff-thresh" type="range" min="0.1" max="0.8" step="0.01" value="0.35">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-aff-iters">Affinity iterations <span id="hlsf-aff-iters-val">8</span></label>
              <input id="hlsf-aff-iters" type="range" min="1" max="20" step="1" value="8">
            </div>
            <div class="hlsf-control-group">
              <em id="hlsf-affinity-summary" class="hlsf-mental-summary">Current mental state: Focused yet flexible attention.</em>
            </div>
            <div class="hlsf-control-group">
              <label>Affinity cognition</label>
              <div id="hlsf-affinity-mental-state" class="hlsf-mental-state">
                <div id="hlsf-mental-name" class="hlsf-mental-name">Focused yet flexible attention</div>
                <div id="hlsf-mental-desc" class="hlsf-mental-desc">Moderate evidence is required and several rounds are permitted, yielding balanced, well-formed communities without excessive rumination.</div>
                <div id="hlsf-affinity-mechanics" class="hlsf-mental-mechanics">Neighbors must score at least 0.35 on the 60/40 cosine–Jaccard affinity mix to influence clustering. The loop allows up to 8 iterations before settling.</div>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>Rotation modes</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
                <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergence</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>View</label>
              <div class="hlsf-button-row">
                <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
                <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
                <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
                <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
              </div>
            </div>
          </div>
        `;

        entry.appendChild(wrapper);
        elements.log.appendChild(entry);
        elements.log.scrollTop = elements.log.scrollHeight;
        BatchLog.mount();
      }

      const canvas = /** @type {HTMLCanvasElement|null} */ (wrapper.querySelector('#hlsf-canvas'));
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      bindHlsfControls(wrapper);
      syncHlsfControls(wrapper);

      return canvas;
    }

    function bindHlsfControls(wrapper) {
      if (!wrapper || wrapper.dataset.controlsBound === 'true') return;

      const canvas = wrapper.querySelector('#hlsf-canvas');
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      const scopeSelect = wrapper.querySelector('#hlsf-scope');
      if (scopeSelect) {
        scopeSelect.addEventListener('change', () => {
          const value = scopeSelect.value === 'state' ? 'state' : 'db';
          window.HLSF.config.hlsfScope = value;
          if (window.HLSF?.currentGraph && window.HLSF?.lastCommand?.idx) {
            rebuildHlsfFromLastCommand(true);
          } else {
            debouncedLegacyRender();
          }
        });
      }

      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      if (speedSlider && speedVal) {
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }

      const edgeWidthSlider = wrapper.querySelector('#edgew');
      const edgeWidthVal = wrapper.querySelector('#edgew-val');
      if (edgeWidthSlider && edgeWidthVal) {
        edgeWidthSlider.addEventListener('input', (e) => {
          const next = clampEdgeWidth(parseFloat(e.target.value));
          if (!Number.isFinite(next)) return;
          window.HLSF.config.edgeWidth = next;
          edgeWidthVal.textContent = next.toFixed(3);
          if (Math.abs(next - parseFloat(edgeWidthSlider.value)) > 1e-6) {
            edgeWidthSlider.value = next.toFixed(3);
          }
          requestRender();
        });
      }

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      if (nodeSizeSlider && nodeSizeVal) {
        nodeSizeSlider.addEventListener('input', (e) => {
          const next = clampNodeSize(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.nodeSize = next;
          nodeSizeVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(nodeSizeSlider.value)) > 1e-6) {
            nodeSizeSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      if (relationInput) {
        relationInput.addEventListener('input', () => {
          const next = clampRelationTypeCap(relationInput.value);
          window.HLSF.config.relationTypeCap = next;
          relationInput.value = String(next);
          if (relationVal) relationVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      if (edgesInput) {
        edgesInput.addEventListener('input', () => {
          const next = clampEdgesPerType(edgesInput.value);
          window.HLSF.config.edgesPerType = next;
          edgesInput.value = String(next);
          if (edgesVal) edgesVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const thresholdSlider = wrapper.querySelector('#hlsf-aff-thresh');
      const thresholdVal = wrapper.querySelector('#hlsf-aff-thresh-val');
      if (thresholdSlider) {
        thresholdSlider.addEventListener('input', () => {
          const raw = Number(thresholdSlider.value);
          const clamped = Number.isFinite(raw) ? Math.min(0.8, Math.max(0.1, raw)) : 0.35;
          const value = Math.round(clamped * 100) / 100;
          window.HLSF.config.affinity = Object.assign({}, window.HLSF.config.affinity, { threshold: value });
          thresholdSlider.value = value.toFixed(2);
          if (thresholdVal) thresholdVal.textContent = value.toFixed(2);
          const currentIters = window.HLSF.config.affinity?.iterations;
          updateAffinityAnnotations(wrapper, value, Number.isFinite(currentIters) ? currentIters : 8);
          recomputeAndRender();
        });
      }

      const iterSlider = wrapper.querySelector('#hlsf-aff-iters');
      const iterVal = wrapper.querySelector('#hlsf-aff-iters-val');
      if (iterSlider) {
        iterSlider.addEventListener('input', () => {
          const raw = Number(iterSlider.value);
          const value = Number.isFinite(raw) ? Math.min(20, Math.max(1, Math.round(raw))) : 8;
          window.HLSF.config.affinity = Object.assign({}, window.HLSF.config.affinity, { iterations: value });
          iterSlider.value = String(value);
          if (iterVal) iterVal.textContent = String(value);
          const currentThresh = window.HLSF.config.affinity?.threshold;
          updateAffinityAnnotations(wrapper, Number.isFinite(currentThresh) ? currentThresh : 0.35, value);
          recomputeAndRender();
        });
      }

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      if (edgeColorSelect) {
        edgeColorSelect.addEventListener('change', (e) => {
          const value = normalizeEdgeColorMode(e.target.value);
          window.HLSF.config.edgeColorMode = value;
          edgeColorSelect.value = value;
          debouncedLegacyRender();
        });
      }

      const zoomIn = wrapper.querySelector('#hlsf-zoom-in');
      if (zoomIn) {
        zoomIn.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 1.2));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const zoomOut = wrapper.querySelector('#hlsf-zoom-out');
      if (zoomOut) {
        zoomOut.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 0.8));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const reset = wrapper.querySelector('#hlsf-reset-view');
      if (reset) {
        reset.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          window.HLSF.view.scale = 1;
          if (canvasEl) {
            const width = canvasEl.clientWidth || canvasEl.width;
            const height = canvasEl.clientHeight || canvasEl.height;
            window.HLSF.view.x = width / 2;
            window.HLSF.view.y = height / 2;
          } else {
            window.HLSF.view.x = 0;
            window.HLSF.view.y = 0;
          }
          syncViewToConfig();
          requestRender();
        });
      }

      const portal = wrapper.querySelector('#hlsf-zoom-portal');
      if (portal) {
        portal.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          if (!canvasEl) return;
          const width = canvasEl.clientWidth || canvasEl.width;
          const height = canvasEl.clientHeight || canvasEl.height;
          const cx = width / 2;
          const cy = height / 2;
          const target = {
            x: cx,
            y: cy,
            scale: Math.max(1.5, window.HLSF.view.scale * 2),
          };
          animateViewport(target, 350);
        });
      }

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) {
        rotationBtn.addEventListener('click', () => {
          window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
          if (window.HLSF.config.rotationActive) {
            window.HLSF.config.emergentActive = false;
            window.HLSF.state.emergent.on = false;
          }
          syncHlsfControls(wrapper);
          requestRender();
        });
      }

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) {
        emergentBtn.addEventListener('click', () => {
          const state = window.HLSF.state.emergent;
          state.on = !state.on;
          window.HLSF.config.emergentActive = state.on;
          if (state.on) window.HLSF.config.rotationActive = false;
          syncHlsfControls(wrapper);
          requestRender();
        });
      }

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) {
        edgesBtn.addEventListener('click', () => {
          window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
          edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
          debouncedLegacyRender();
        });
      }

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) {
        labelsBtn.addEventListener('click', () => {
          window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
          labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
          debouncedLegacyRender();
        });
      }

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) {
        glowBtn.addEventListener('click', () => {
          window.HLSF.config.showNodeGlow = !window.HLSF.config.showNodeGlow;
          glowBtn.textContent = window.HLSF.config.showNodeGlow ? 'Glow: On' : 'Glow: Off';
          debouncedLegacyRender();
        });
      }

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) {
        bgBtn.addEventListener('click', () => {
          window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
          bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
          debouncedLegacyRender();
        });
      }

      const layoutBtn = wrapper.querySelector('#hlsf-toggle-layout');
      if (layoutBtn) {
        layoutBtn.addEventListener('click', () => {
          const layouts = ['dimension', 'affinity', 'layered', 'legacy'];
          const current = normalizeLayout(window.HLSF.config.layout);
          const index = layouts.indexOf(current);
          const next = layouts[(index + 1) % layouts.length];
          window.HLSF.config.layout = next;
          layoutBtn.textContent = `Layout: ${layoutLabel(next)}`;
          debouncedLegacyRender();
        });
      }

      const canvasEl = wrapper.querySelector('#hlsf-canvas');
      if (canvasEl) {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvasEl.addEventListener('mousedown', (e) => {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvasEl.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.view.x += dx;
          window.HLSF.view.y += dy;
          syncViewToConfig();
          lastX = e.clientX;
          lastY = e.clientY;
          requestRender();
        });

        canvasEl.addEventListener('mouseleave', () => {
          isDragging = false;
        });
      }

      const affinityCfg = window.HLSF.config?.affinity || {};
      const initialThresh = Number.isFinite(affinityCfg.threshold) ? affinityCfg.threshold : 0.35;
      const initialIters = Number.isFinite(affinityCfg.iterations) ? affinityCfg.iterations : 8;
      updateAffinityAnnotations(wrapper, initialThresh, initialIters);

      wrapper.dataset.controlsBound = 'true';
    }

    function syncHlsfControls(wrapper) {
      if (!wrapper) return;

      syncViewToConfig();
      const config = window.HLSF.config || {};
      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      const omega = Number.isFinite(config.rotationOmega) ? config.rotationOmega : 0;
      window.HLSF.config.rotationOmega = omega;
      if (speedSlider) speedSlider.value = omega.toFixed(2);
      if (speedVal) speedVal.textContent = omega.toFixed(2);

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      const alpha = clampAlpha(config.alpha);
      window.HLSF.config.alpha = alpha;
      if (alphaSlider) alphaSlider.value = alpha.toFixed(2);
      if (alphaVal) alphaVal.textContent = alpha.toFixed(2);

      const edgeWidthSlider = wrapper.querySelector('#edgew');
      const edgeWidthVal = wrapper.querySelector('#edgew-val');
      const edgeWidth = clampEdgeWidth(config.edgeWidth);
      window.HLSF.config.edgeWidth = edgeWidth;
      if (edgeWidthSlider) edgeWidthSlider.value = edgeWidth.toFixed(3);
      if (edgeWidthVal) edgeWidthVal.textContent = edgeWidth.toFixed(3);

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      const nodeSize = clampNodeSize(config.nodeSize);
      window.HLSF.config.nodeSize = nodeSize;
      if (nodeSizeSlider) nodeSizeSlider.value = nodeSize.toFixed(1);
      if (nodeSizeVal) nodeSizeVal.textContent = nodeSize.toFixed(1);

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      const relationCapRaw = config.relationTypeCap;
      const relationCap = relationCapRaw === Infinity
        ? Infinity
        : clampRelationTypeCap(relationCapRaw);
      window.HLSF.config.relationTypeCap = relationCap;
      if (relationInput) {
        relationInput.value = relationCap === Infinity ? String(MAX_REL_TYPES) : String(relationCap);
      }
      if (relationVal) relationVal.textContent = relationCap === Infinity ? '∞' : String(relationCap);

      const scopeSelect = wrapper.querySelector('#hlsf-scope');
      const normalizedScope = config.hlsfScope === 'state' ? 'state' : 'db';
      window.HLSF.config.hlsfScope = normalizedScope;
      if (scopeSelect) scopeSelect.value = normalizedScope;

      const dimLayout = window.HLSF?.currentGraph?.dimensionLayout || window.HLSF?.currentLayoutSnapshot?.layout || null;
      const dimDSpan = wrapper.querySelector('#hlsf-dimension-d');
      const dimLevelSpan = wrapper.querySelector('#hlsf-dimension-levels');
      const dimLastSpan = wrapper.querySelector('#hlsf-dimension-last');
      if (dimDSpan) dimDSpan.textContent = dimLayout ? String(dimLayout.dimension || 0) : '—';
      if (dimLevelSpan) dimLevelSpan.textContent = dimLayout ? String(dimLayout.levelCount || 0) : '—';
      if (dimLastSpan) dimLastSpan.textContent = dimLayout ? String(dimLayout.lastLevelComponents || 0) : '—';

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      const edgesRaw = config.edgesPerType;
      const edgesPerType = edgesRaw === Infinity
        ? Infinity
        : clampEdgesPerType(edgesRaw);
      window.HLSF.config.edgesPerType = edgesPerType;
      if (edgesInput) {
        edgesInput.value = edgesPerType === Infinity ? String(MAX_EDGES_PER_TYPE) : String(edgesPerType);
      }
      if (edgesVal) edgesVal.textContent = edgesPerType === Infinity ? '∞' : String(edgesPerType);

      const affinityCfg = (config.affinity && typeof config.affinity === 'object') ? config.affinity : {};
      const threshold = (() => {
        const raw = Number(affinityCfg.threshold);
        const clamped = Number.isFinite(raw) ? Math.min(0.8, Math.max(0.1, raw)) : 0.35;
        return Math.round(clamped * 100) / 100;
      })();
      const iterations = (() => {
        const raw = Number(affinityCfg.iterations);
        return Number.isFinite(raw) ? Math.min(20, Math.max(1, Math.round(raw))) : 8;
      })();
      window.HLSF.config.affinity = { threshold, iterations };

      const thresholdSlider = wrapper.querySelector('#hlsf-aff-thresh');
      const thresholdVal = wrapper.querySelector('#hlsf-aff-thresh-val');
      if (thresholdSlider) thresholdSlider.value = threshold.toFixed(2);
      if (thresholdVal) thresholdVal.textContent = threshold.toFixed(2);

      const iterSlider = wrapper.querySelector('#hlsf-aff-iters');
      const iterVal = wrapper.querySelector('#hlsf-aff-iters-val');
      if (iterSlider) iterSlider.value = String(iterations);
      if (iterVal) iterVal.textContent = String(iterations);

      updateAffinityAnnotations(wrapper, threshold, iterations);

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      const colorMode = normalizeEdgeColorMode(config.edgeColorMode);
      window.HLSF.config.edgeColorMode = colorMode;
      if (edgeColorSelect) edgeColorSelect.value = colorMode;

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) rotationBtn.textContent = config.rotationActive ? 'Stop Global' : 'Start Global';

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      const emergentActive = window.HLSF.state?.emergent?.on === true;
      window.HLSF.config.emergentActive = emergentActive;
      if (emergentBtn) emergentBtn.textContent = emergentActive ? 'Stop Emergence' : 'Start Emergence';

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) edgesBtn.textContent = config.showEdges ? 'Edges: On' : 'Edges: Off';

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) labelsBtn.textContent = config.showLabels ? 'Labels: On' : 'Labels: Off';

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) glowBtn.textContent = config.showNodeGlow ? 'Glow: On' : 'Glow: Off';

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) bgBtn.textContent = config.whiteBg ? 'BG: Light' : 'BG: Dark';

      const layoutBtn = wrapper.querySelector('#hlsf-toggle-layout');
      if (layoutBtn) {
        const layout = normalizeLayout(config.layout);
        window.HLSF.config.layout = layout;
        layoutBtn.textContent = `Layout: ${layoutLabel(layout)}`;
      }
    }

    window.HLSF = window.HLSF || {};
    const existingConfig = window.HLSF.config || {};
    const DEFAULT_BOOTSTRAP_DB = "HLSF_Database_2025-10-15.json";
    window.HLSF.config = Object.assign({
      bootstrapDbUrl: existingConfig.bootstrapDbUrl || DEFAULT_BOOTSTRAP_DB,
      rotationActive: true,
      rotationOmega: 0.30,
      alpha: 0.10,
      scale: 1,
      tx: 0,
      ty: 0,
      emergentActive: false,
      showEdges: true,
      showLabels: true,
      fillFaces: false,
      whiteBg: false,
      showEnglish: true,
      fullAnchorCap: 0,
      batchLogging: true,
      deferredRender: true,
      progressTick: 250,
      layout: 'dimension',
      hlsfScope: existingConfig.hlsfScope || 'db',
      metricScope: METRIC_SCOPE.RUN,
      relationTypeCap: MAX_REL_TYPES,
      edgesPerType: 3,
      edgeWidth: 0.02,
      nodeSize: 1,
      edgeColorMode: 'theme',
      showNodeGlow: false,
      affinity: { threshold: 0.35, iterations: 8 },
    }, existingConfig);
    const initialRelationCap = window.HLSF.config.relationTypeCap;
    window.HLSF.config.relationTypeCap = initialRelationCap === Infinity
      ? Infinity
      : clampRelationTypeCap(initialRelationCap);
    const initialEdgesPerType = window.HLSF.config.edgesPerType;
    window.HLSF.config.edgesPerType = initialEdgesPerType === Infinity
      ? Infinity
      : clampEdgesPerType(initialEdgesPerType);
    window.HLSF.config.edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
    window.HLSF.config.nodeSize = clampNodeSize(window.HLSF.config.nodeSize);
    window.HLSF.config.edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
    window.HLSF.config.showNodeGlow = window.HLSF.config.showNodeGlow === true;
    window.HLSF.config.layout = normalizeLayout(window.HLSF.config.layout);
    window.HLSF.config.batchLogging = window.HLSF.config.batchLogging !== false;
    window.HLSF.config.deferredRender = window.HLSF.config.deferredRender !== false;
    window.HLSF.config.progressTick = Math.max(1, Math.round(Number(window.HLSF.config.progressTick) || 250));
    window.HLSF.config.metricScope = normalizeMetricScope(window.HLSF.config.metricScope);
    const affinityCfg = window.HLSF.config.affinity;
    if (!affinityCfg || typeof affinityCfg !== 'object') {
      window.HLSF.config.affinity = { threshold: 0.35, iterations: 8 };
    } else {
      const rawThresh = Number(affinityCfg.threshold);
      const rawIters = Number(affinityCfg.iterations);
      window.HLSF.config.affinity.threshold = Number.isFinite(rawThresh)
        ? Math.round(Math.min(0.8, Math.max(0.1, rawThresh)) * 100) / 100
        : 0.35;
      window.HLSF.config.affinity.iterations = Number.isFinite(rawIters)
        ? Math.min(20, Math.max(1, Math.round(rawIters)))
        : 8;
    }
    const prevState = window.HLSF.state || {};
    window.HLSF.state = Object.assign({}, prevState);
    window.HLSF.state.globalRot = Number.isFinite(prevState.globalRot) ? prevState.globalRot : 0;
    const emergentState = prevState.emergent && typeof prevState.emergent === 'object'
      ? prevState.emergent
      : {};
    window.HLSF.state.emergent = Object.assign({ on: false, speed: 0.25 }, emergentState);
    window.HLSF.state.emergentRot = Number.isFinite(prevState.emergentRot) ? prevState.emergentRot : 0;
    if (!(window.HLSF.state.patches instanceof Map)) window.HLSF.state.patches = new Map();
    window.HLSF.view = Object.assign({ x: 0, y: 0, scale: 1 }, window.HLSF.view || {});
    if (!Number.isFinite(window.HLSF.view.x)) window.HLSF.view.x = 0;
    if (!Number.isFinite(window.HLSF.view.y)) window.HLSF.view.y = 0;
    if (!Number.isFinite(window.HLSF.view.scale) || window.HLSF.view.scale <= 0) window.HLSF.view.scale = 1;

    function syncViewToConfig() {
      if (!window.HLSF?.config || !window.HLSF?.view) return;
      window.HLSF.config.scale = window.HLSF.view.scale;
      window.HLSF.config.tx = window.HLSF.view.x;
      window.HLSF.config.ty = window.HLSF.view.y;
    }
    window.HLSF.canvas = window.HLSF.canvas || null;
    window.HLSF.ctx = window.HLSF.ctx || null;
    window.HLSF.nodes = window.HLSF.nodes || [];
    window.HLSF.animationFrame = window.HLSF.animationFrame || null;
    window.HLSF.geometry = window.HLSF.geometry || {};
    window.HLSF.rendering = window.HLSF.rendering || {};
    window.HLSF.__centerInit = window.HLSF.__centerInit || false;
    window.HLSF.indexCache = window.HLSF.indexCache || null;
    window.HLSF.indexCacheSource = window.HLSF.indexCacheSource || null;

    const clampAlpha = (value) => {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return NaN;
      return Math.min(0.99, Math.max(0.005, numeric));
    };
    window.HLSF.config.alpha = (() => {
      const initial = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(initial) ? initial : 0.1;
    })();
    const baseAlpha = () => {
      const resolved = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(resolved) ? resolved : 0.1;
    };

    function hideVisualizer() {
      const el = document.getElementById('hlsf-canvas-container');
      if (el) el.classList.add('hidden');
    }

    function showVisualizer() {
      const el = document.getElementById('hlsf-canvas-container');
      if (el) el.classList.remove('hidden');
    }
    const edgeAlphaFromWeight = (w) => {
      const preferred = Number.isFinite(w) ? clampAlpha(w) : NaN;
      if (Number.isFinite(preferred)) return preferred;
      return baseAlpha();
    };

    const EDGE_COLOR_PALETTE = [
      '#00ff88', '#ffd54f', '#ff6f91', '#64b5f6', '#ce93d8',
      '#ff8a65', '#4dd0e1', '#9ccc65', '#f06292', '#ba68c8'
    ];

    function paletteColor(key) {
      if (!key) return EDGE_COLOR_PALETTE[0];
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = (hash * 33 + key.charCodeAt(i)) | 0;
      }
      const index = Math.abs(hash) % EDGE_COLOR_PALETTE.length;
      return EDGE_COLOR_PALETTE[index];
    }

    function normalizedIntensity(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(1, numeric));
    }

    function weightToColor(value) {
      const t = normalizedIntensity(value);
      const r = Math.round(255 - 90 * t);
      const g = Math.round(160 + 80 * t);
      const b = Math.round(120 + 16 * (1 - t));
      const alpha = 0.45 + 0.45 * t;
      return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2)})`;
    }

    function nodeEdgeStrokeColor(node, index, mode) {
      if (mode === 'relation') {
        return paletteColor(`${node.token}-${index}`);
      }
      if (mode === 'weight') {
        return weightToColor(node.attention ?? 0);
      }
      return null;
    }

    function compositeEdgeStrokeColor(edge, mode) {
      if (mode === 'relation') {
        return paletteColor(edge.rtype || `${edge.from}->${edge.to}`);
      }
      if (mode === 'weight') {
        return weightToColor(edge.w ?? 0);
      }
      return null;
    }

    function stepRotation(dt) {
      const w = window.HLSF.config.rotationOmega || 0;
      const tau = 2 * Math.PI;
      if (window.HLSF.config.rotationActive && w) {
        window.HLSF.state.globalRot = (window.HLSF.state.globalRot + dt * w) % tau;
      }
      rotate_patches(dt);
      if (window.HLSF.state?.emergent?.on) {
        const speed = Number.isFinite(window.HLSF.state.emergent.speed) ? window.HLSF.state.emergent.speed : 0;
        if (speed) {
          window.HLSF.state.emergentRot = (window.HLSF.state.emergentRot + dt * speed) % tau;
        }
      }
    }

    let TokenToGlyph = new Map();
    let GlyphToToken = new Map();

    function loadGlyphMaps(db) {
      if (!db) return;
      if (!(TokenToGlyph instanceof Map)) TokenToGlyph = new Map();
      if (!(GlyphToToken instanceof Map)) GlyphToToken = new Map();
      TokenToGlyph.clear();
      GlyphToToken.clear();
      (db.token_glyph_map || []).forEach(({ token, glyph }) => {
        if (token && glyph) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
      (db.glyph_token_map || []).forEach(({ glyph, token }) => {
        if (glyph && token) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
    }

    window.CognitionEngine = window.CognitionEngine || {
      state: {},
      cache: {},
      api: {},
      processing: {},
    };

    window.GlyphSystem = window.GlyphSystem || {
      ledger: null,
      encode: () => '',
      decode: () => '',
      export: () => ({}),
    };

    // ---- Glyph crypto core ----
    const LEDGER_KEY = "HLSF_GLYPH_LEDGER_V1";
    const GLYPH_SET = Array.from("⬣⬧⬩⬡⬪⬨⬤⬟⬢⬥⬠⬙⬘⬗⬖⬕⬔⬓⬒⬑"); // limited symbols
    const GLYPH_SEP = " "; // delimiter between glyph-weight pairs
    const NUM_FMT = n => Number(n).toString(); // unlimited precision as given

    function hydrateLedgerMaps(ledger) {
      TokenToGlyph.clear();
      GlyphToToken.clear();
      const map = ledger?.glyph_map || {};
      for (const glyph of Object.keys(map)) {
        const entries = Array.isArray(map[glyph]) ? map[glyph] : [];
        for (const entry of entries) {
          if (!entry || !entry.token) continue;
          TokenToGlyph.set(entry.token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(entry.token);
        }
      }
    }

    // Load/save ledger
    function loadLedger() {
      let ledger;
      try {
        const raw = localStorage.getItem(LEDGER_KEY);
        ledger = raw ? JSON.parse(raw) : null;
      } catch {
        ledger = null;
      }
      if (!ledger || typeof ledger !== 'object') {
        ledger = { version: "1.0", created_at: new Date().toISOString(), glyph_map: {} };
      } else {
        ledger.version = ledger.version || "1.0";
        ledger.created_at = ledger.created_at || new Date().toISOString();
        ledger.glyph_map = ledger.glyph_map || {};
      }
      hydrateLedgerMaps(ledger);
      return ledger;
    }
    function saveLedger(ledger) {
      try {
        localStorage.setItem(LEDGER_KEY, JSON.stringify(ledger));
      } catch (err) {
        console.warn('Failed to persist glyph ledger:', err);
      }
    }

    // ---- HLSF constants
    const TOKEN_CACHE_PREFIX = 'hlsf_token_';
    const DB_RAW_KEY = 'HLSF_DB_RAW';        // stores JSON export text
    const API_KEY_STORAGE_KEY = 'HLSF_API_KEY';
    const DB_INDEX_KEY = 'HLSF_DB_INDEX';    // array of token strings

    function parseMaybeNdjson(text) {
      try { return JSON.parse(text); } catch {}
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const rows = [];
      for (const ln of lines) {
        try { rows.push(JSON.parse(ln)); } catch {}
      }
      return rows.length ? rows : null;
    }

    function coerceDb(input) {
      const data = (typeof input === 'string') ? parseMaybeNdjson(input.replace(/^\uFEFF/, '')) : input;
      if (!data) throw new Error('Unparseable JSON/NDJSON');
      if (data && !Array.isArray(data) && Array.isArray(data.full_token_data)) {
        return Object.assign({}, data, { full_token_data: data.full_token_data });
      }
      if (Array.isArray(data)) return { full_token_data: data };
      throw new Error('Invalid database format. Expected full_token_data array.');
    }

    function normalizeRecord(rec) {
      if (!rec || typeof rec.token !== 'string') return null;
      const rels = rec.relationships && typeof rec.relationships === 'object' ? rec.relationships : {};
      const out = { token: rec.token, relationships: rels, cached_at: rec.cached_at || null };
      for (const [key, value] of Object.entries(rec)) {
        if (key === 'token' || key === 'relationships' || key === 'cached_at') continue;
        out[key] = value;
      }
      return out;
    }

    function loadDbObject(dbLike) {
      const db = coerceDb(dbLike);
      const raw = Array.from(db.full_token_data || []);
      const clean = raw.map(normalizeRecord).filter(Boolean);
      if (!clean.length) throw new Error('No valid token records');
      // Reset existing cached tokens so the cache matches the imported database
      const existingKeys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const key of existingKeys) {
        safeStorageRemove(key);
      }
      const now = new Date().toISOString();
      for (const record of clean) {
        const payload = Object.assign({ cached_at: now }, record);
        if (!payload.cached_at) payload.cached_at = now;
        const cacheKey = getCacheKey(record.token);
        safeStorageSet(cacheKey, JSON.stringify(payload));
      }
      const out = Object.assign({}, db, { full_token_data: clean });
      localStorage.setItem(DB_RAW_KEY, JSON.stringify(out));
      const index = clean.map(r => r.token);
      localStorage.setItem(DB_INDEX_KEY, JSON.stringify(index));
      window.HLSF.dbCache = out;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      window.HLSF.indexCache = null;
      window.HLSF.indexCacheSource = null;
      state.hlsfReady = false;
      if (typeof buildHLSFMatrices === 'function') {
        try {
          buildHLSFMatrices(out);
        } catch (err) {
          console.warn('Failed to rebuild HLSF matrices:', err);
        }
      }
      updateHeaderCounts();
      return clean.length;
    }

    function refreshDbReference(recordLike) {
      const normalized = normalizeRecord(recordLike);
      if (!normalized) return;

      if (!normalized.cached_at) {
        normalized.cached_at = new Date().toISOString();
      }

      let db = window.HLSF.dbCache;
      if (!db || typeof db !== 'object') {
        try {
          const raw = localStorage.getItem(DB_RAW_KEY);
          if (raw) {
            db = JSON.parse(raw);
          }
        } catch (err) {
          console.warn('Failed to hydrate existing DB snapshot:', err);
          db = null;
        }
      }

      if (!db || typeof db !== 'object') {
        db = { full_token_data: [] };
      }

      if (!Array.isArray(db.full_token_data)) {
        db.full_token_data = Array.isArray(db.full_token_data)
          ? db.full_token_data.filter(Boolean).map(normalizeRecord).filter(Boolean)
          : [];
      }

      const entries = db.full_token_data;
      const idx = entries.findIndex(rec => rec && rec.token === normalized.token);
      if (idx >= 0) {
        const existing = entries[idx] || {};
        entries[idx] = Object.assign({}, existing, normalized);
        if (!entries[idx].cached_at) entries[idx].cached_at = normalized.cached_at;
      } else {
        entries.push(normalized);
      }

      window.HLSF.dbCache = db;
      try {
        safeStorageSet(DB_RAW_KEY, JSON.stringify(db));
      } catch (err) {
        console.warn('Failed to persist updated DB snapshot:', err);
      }
      window.HLSF.indexCache = null;
      window.HLSF.indexCacheSource = null;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      state.hlsfReady = false;
      updateHeaderCounts();
    }

    function getDb() {
      if (window.HLSF.dbCache) return window.HLSF.dbCache;
      let raw = null;
      try {
        raw = localStorage.getItem(DB_RAW_KEY);
        if (!raw) {
          const legacy = localStorage.getItem('hlsf_db_raw');
          if (legacy) {
            localStorage.setItem(DB_RAW_KEY, legacy);
            localStorage.removeItem('hlsf_db_raw');
            raw = legacy;
          }
        }
      } catch (err) {
        console.warn('Failed to read DB from storage:', err);
        raw = null;
      }
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        window.HLSF.dbCache = parsed;
        return parsed;
      } catch (err) {
        console.warn('Stored DB is not valid JSON:', err);
        return null;
      }
    }

    // Symbolic glyphs for complex number representation
    const GLYPH_LIBRARY = [
      '◉', '◈', '◇', '◆', '◊', '○', '●', '◐', '◑', '◒',
      '◓', '☉', '⊙', '⊚', '⊛', '⊜', '⊝', '◎', '◍', '◌',
      '△', '▲', '▽', '▼', '◁', '▷', '◀', '▶', '⬟', '⬠',
      '⬡', '⬢', '⬣', '⬤', '⬥', '⬦', '⬧', '⬨', '⬩', '⬪',
      '⬫', '⬬', '⬭', '⬮', '⬯', '⭐', '★', '☆', '✦', '✧',
      '✶', '✷', '✸', '✹', '✺', '✻', '✼', '✽', '✾', '✿',
      '❀', '❁', '❂', '❃', '❄', '❅', '❆', '❇', '❈', '❉',
      '⚙', '⚛', '⚝', '⚞', '⚟', '⚬', '⚭', '⚮', '⚯', '⚰'
    ];

    const RELATIONSHIP_PRIORITIES = new Map([
      ['≡', 1.0], ['⊃', 1.0], ['⊂', 0.8], ['≈', 0.7], ['∈', 0.9], ['∋', 0.9],
      ['⊤', 0.9], ['⊥', 0.9], ['⊏', 0.8], ['⊐', 0.8], ['↔', 0.7], ['⇌', 0.7],
      ['∥', 0.6], ['∼', 0.5], ['→', 0.5], ['⇒', 0.5], ['⇐', 0.5], ['↠', 0.5],
      ['↗', 0.4], ['↘', 0.4], ['⇝', 1.0], ['⇂', 0.7], ['≠', 0.8], ['⊕', 0.8],
      ['⊛', 0.7], ['∝', 0.7], ['⇝ Causes', 1.0], ['⇐ Caused By', 0.9],
      ['∗', 0.7], ['≜', 0.9], ['⋆', 0.8], ['7→', 0.7], ['⊢', 0.9], ['⊣', 0.9],
      ['↷', 0.8], ['↶', 0.8], ['◦', 0.9], ['|=', 0.9], ['◁', 0.6], ['⇄', 0.6],
      ['⊗', 0.9], ['÷', 0.7], ['⊘', 0.8], ['×', 0.8], ['¬', 0.8], ['†', 0.8],
      ['⊠', 0.8], ['/∈', 0.8], ['⊬', 0.8], ['⊩', 0.9], ['⊨', 0.9], ['?', 0.5],
      ['⚡', 0.7], ['⇒ Attention', 0.7], ['↶ Self-Reference', 0.7], ['∧', 0.6],
      ['↭', 0.6], ['▷◁', 0.6]
    ]);

    // ============================================
    // STATE
    // ============================================
    const state = {
      apiKey: '',
      isProcessing: false,
      sessionStats: {
        totalApiCalls: 0,
        totalCacheHits: 0,
        totalCostUsd: 0,
      },
      hlsfReady: false,
    };

    state.hlsfReady = false;
    window.CognitionEngine.state = state;

    let currentAbortController = null;

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      log: document.getElementById('log'),
      input: document.getElementById('command-input'),
      sendBtn: document.getElementById('send-btn'),
      cancelBtn: document.getElementById('cancel-btn'),
      apiModal: document.getElementById('api-modal'),
      apiKeyInput: document.getElementById('api-key-input'),
      apiConfirmBtn: document.getElementById('api-confirm'),
      apiCancelBtn: document.getElementById('api-cancel'),
      cacheHitRate: document.getElementById('cache-hit-rate'),
      cachedTokens: document.getElementById('cached-tokens'),
      sessionCost: document.getElementById('session-cost'),
      dbFileInput: document.getElementById('db-file'),
    };

    // ============================================
    // UTILITIES
    // ============================================
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validatePrompt(prompt) {
      if (!prompt || typeof prompt !== 'string') {
        throw new Error('Invalid prompt: must be non-empty string');
      }
      if (prompt.length > 10000) {
        throw new Error('Prompt too long: max 10000 characters');
      }
      return prompt.trim();
    }

    function safeStorageGet(key, defaultValue = null) {
      try {
        const item = localStorage.getItem(key);
        if (item == null) return defaultValue;
        try {
          return JSON.parse(item);
        } catch {
          return item;
        }
      } catch (err) {
        console.warn(`Storage read failed for ${key}:`, err);
        return defaultValue;
      }
    }

    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        console.warn(`Storage write failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.warn(`Storage remove failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageKeys(prefix = '') {
      try {
        return Object.keys(localStorage).filter(k => k.startsWith(prefix));
      } catch (err) {
        console.warn('Storage keys enumeration failed:', err);
        return [];
      }
    }

    function isValidApiKey(key) {
      if (typeof key !== 'string') return false;
      const trimmed = key.trim();
      if (!trimmed) return false;
      if (!trimmed.startsWith('sk-')) return false;
      return trimmed.length >= 20;
    }

    function tokenize(text) {
      if (!text) return [];
      return text.trim()
        .split(/[^\p{L}\p{N}\-']+/u)
        .filter(Boolean)
        .map(t => t.toLowerCase());
    }

    function estimateTokensForText(text) {
      return tokenize(text).length;
    }

    function estimateTokensForMessages(messages) {
      if (!Array.isArray(messages)) return 0;
      let total = 0;
      for (const message of messages) {
        if (!message) continue;
        const contentTokens = estimateTokensForText(message.content || '');
        const roleTokens = message.role ? 4 : 0;
        total += contentTokens + roleTokens;
      }
      return total + 3; // minimal overhead for chat formatting
    }

    function estimateCompletionTokens(promptTokenCount) {
      const ratio = CONFIG.ESTIMATED_COMPLETION_RATIO ?? 0.7;
      const estimate = Math.round(promptTokenCount * ratio);
      return Math.max(32, estimate);
    }

    function getModelPricing(model) {
      const pricing = CONFIG.MODEL_PRICING?.[model];
      return pricing || CONFIG.MODEL_PRICING?.default || { inputPerMillion: 0, outputPerMillion: 0 };
    }

    function estimateCostUsd(promptTokens = 0, completionTokens = 0, model = CONFIG.DEFAULT_MODEL) {
      const pricing = getModelPricing(model);
      return ((promptTokens * pricing.inputPerMillion) + (completionTokens * pricing.outputPerMillion)) / 1_000_000;
    }

    const Session = (() => {
      const existing = window.Session && typeof window.Session === 'object'
        ? window.Session
        : {};
      const session = Object.assign({ tokens: new Set() }, existing);
      window.Session = session;
      return session;
    })();

    function addConversationTokens(arr) {
      for (const token of arr || []) {
        if (token) Session.tokens.add(token);
      }
    }

    function onUserPromptSubmitted(text) {
      const toks = text.trim().split(/\s+/).filter(Boolean);
      addConversationTokens(toks);
    }

    function formatCurrency(amountUsd) {
      if (!amountUsd || isNaN(amountUsd)) return '$0.0000';
      const abs = Math.abs(amountUsd);
      if (abs > 0 && abs < 0.0001) {
        return amountUsd < 0 ? '-<$0.0001' : '<$0.0001';
      }
      const decimals = abs >= 1 ? 2 : abs >= 0.01 ? 3 : 4;
      const prefix = amountUsd < 0 ? '-$' : '$';
      return `${prefix}${Math.abs(amountUsd).toFixed(decimals)}`;
    }

    function getCachedTokenCount() {
      return safeStorageKeys(TOKEN_CACHE_PREFIX).length;
    }

    // ============================================
    // COMPLEX NUMBER ENCODING & GLYPH SYSTEM
    // ============================================
    
    // Convert token to complex number representation
    // Magnitude = attention score, Phase = semantic hash
    function tokenToComplexNumber(token, tokenData) {
      const attentionScore = tokenData?.attention_score || 0.5;
      const magnitude = attentionScore; // 0.0 to 1.0
      
      // Generate phase from token's semantic properties
      let phaseHash = 0;
      for (let i = 0; i < token.length; i++) {
        phaseHash = ((phaseHash << 5) - phaseHash) + token.charCodeAt(i);
        phaseHash = phaseHash & phaseHash;
      }
      
      // Normalize phase to 0-2π
      const phase = (Math.abs(phaseHash) % 360) * (Math.PI / 180);
      
      // Calculate real and imaginary parts
      const real = magnitude * Math.cos(phase);
      const imaginary = magnitude * Math.sin(phase);
      
      return { real, imaginary, magnitude, phase };
    }

    const memoizedComplexNumber = (() => {
      const cache = new Map();
      return (token, tokenData) => {
        const score = tokenData?.attention_score ?? 0;
        const key = `${token}_${score}`;
        if (cache.has(key)) return cache.get(key);
        const result = tokenToComplexNumber(token, tokenData);
        cache.set(key, result);
        return result;
      };
    })();

    // Map complex number to glyph from library
    function complexToGlyph(complex) {
      // Use magnitude and phase to select glyph
      const magnitudeIndex = Math.floor(complex.magnitude * 7); // 0-7 range
      const phaseIndex = Math.floor((complex.phase / (2 * Math.PI)) * 10); // 0-9 range
      const glyphIndex = (magnitudeIndex * 10 + phaseIndex) % GLYPH_LIBRARY.length;
      return GLYPH_LIBRARY[glyphIndex];
    }

    // Generate glyph ledger for all cached tokens
    function generateGlyphLedger() {
      const ledger = new Map();
      const reverseMap = new Map(); // glyph -> tokens
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);

      for (const key of keys) {
        try {
          const tokenData = safeStorageGet(key);
          if (!tokenData?.token) continue;
          const token = tokenData.token;
          const complex = memoizedComplexNumber(token, tokenData);
          const glyph = complexToGlyph(complex);

          ledger.set(token, {
            glyph,
            complex: {
              real: complex.real.toFixed(4),
              imaginary: complex.imaginary.toFixed(4),
              magnitude: complex.magnitude.toFixed(4),
              phase: complex.phase.toFixed(4)
            },
            attention_score: tokenData.attention_score || 0
          });
          
          // Track consolidation - multiple tokens per glyph
          if (!reverseMap.has(glyph)) {
            reverseMap.set(glyph, []);
          }
          reverseMap.get(glyph).push(token);
        } catch (err) {
          console.error('Failed to process token:', key, err);
        }
      }
      
      return { ledger, reverseMap };
    }

    // Consolidate similar tokens to same glyph
    function findConsolidatedTokens(reverseMap) {
      const consolidated = [];
      for (const [glyph, tokens] of reverseMap.entries()) {
        if (tokens.length > 1) {
          consolidated.push({ glyph, tokens, count: tokens.length });
        }
      }
      return consolidated.sort((a, b) => b.count - a.count);
    }

    // Encode message using glyph ledger
    function encodeMessage(message, ledger) {
      const tokens = tokenize(message);
      const encoded = [];
      const unknown = [];
      
      for (const token of tokens) {
        const entry = ledger.get(token);
        if (entry) {
          encoded.push(entry.glyph);
        } else {
          encoded.push('◌'); // Unknown token marker
          unknown.push(token);
        }
      }
      
      return {
        encoded: encoded.join(''),
        coverage: ((tokens.length - unknown.length) / tokens.length * 100).toFixed(1),
        unknown
      };
    }

    // Decode message using reverse glyph map
    function decodeMessage(encoded, reverseMap) {
      const glyphs = Array.from(encoded);
      const decoded = [];
      
      for (const glyph of glyphs) {
        const tokens = reverseMap.get(glyph);
        if (tokens && tokens.length > 0) {
          // Use first token (could use most common or context-aware selection)
          decoded.push(tokens[0]);
        } else {
          decoded.push('[?]');
        }
      }
      
      return decoded.join(' ');
    }

    // Export glyph ledger for inter-system transmission
    function exportGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        ledger_version: "1.0",
        description: "HLSF Symbolic Glyph Encryption Ledger - Complex Number Token Encoding",
        specification: {
          encoding: "Complex numbers (magnitude=attention, phase=semantic_hash)",
          glyph_library_size: GLYPH_LIBRARY.length,
          representation: "Unicode symbolic glyphs",
          consolidation: "Similar tokens map to same glyph based on complex number proximity"
        },
        statistics: {
          total_tokens: ledger.size,
          unique_glyphs: reverseMap.size,
          consolidation_ratio: (ledger.size / reverseMap.size).toFixed(2),
          consolidated_groups: consolidated.length
        },
        glyph_ledger: Object.fromEntries(ledger),
        reverse_mapping: Object.fromEntries(
          Array.from(reverseMap.entries()).map(([glyph, tokens]) => [glyph, tokens])
        ),
        consolidated_tokens: consolidated,
        encryption_examples: generateEncryptionExamples(ledger, reverseMap)
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Glyph_Ledger_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return exportData;
    }

    window.GlyphSystem.ledger = null;
    window.GlyphSystem.encode = function encode(message) {
      const result = encryptTextToGlyphs(message || '');
      window.GlyphSystem.ledger = loadLedger();
      return { encoded: result.encrypted, coverage: result.coverage, unknown: result.unknown };
    };
    window.GlyphSystem.decode = function decode(encoded) {
      return decryptGlyphsToText(encoded || '');
    };
    window.GlyphSystem.export = function exportLedgerSnapshot() {
      return loadLedger();
    };

    function generateEncryptionExamples(ledger, reverseMap) {
      const examples = [
        "hello world",
        "consciousness",
        "quantum entanglement"
      ];
      
      return examples.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          plaintext: msg,
          encoded: result.encoded,
          coverage: result.coverage + '%',
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
    }

    function showGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      // Show sample encoded messages
      const sampleMessages = [
        "What is consciousness?",
        "Explain quantum mechanics",
        "The nature of reality"
      ];
      
      const encodedSamples = sampleMessages.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          original: msg,
          encoded: result.encoded,
          coverage: result.coverage,
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">🔐 Symbolic Glyph Encryption Ledger</div>
        
        <div class="adjacency-insight">
          <strong>📐 Complex Number Encoding:</strong><br>
          • Each token → Complex number (magnitude + phase)<br>
          • Magnitude = Attention score (0.0-1.0)<br>
          • Phase = Semantic hash (0-2π radians)<br>
          • Glyph = Visual representation of complex coordinates
        </div>

        <div class="adjacency-insight">
          <strong>📊 Ledger Statistics:</strong><br>
          • Total tokens: <strong>${ledger.size}</strong><br>
          • Unique glyphs: <strong>${reverseMap.size}</strong><br>
          • Consolidation ratio: <strong>${(ledger.size / reverseMap.size).toFixed(2)}:1</strong><br>
          • Efficiency gain: <strong>${(100 - (reverseMap.size / ledger.size * 100)).toFixed(1)}%</strong>
        </div>

        <div class="adjacency-insight">
          <strong>🔄 Token Consolidation (Similar tokens → Same glyph):</strong><br>
          ${consolidated.slice(0, 5).map(c => 
            `• <span style="font-size: 1.5em;">${c.glyph}</span> → ${c.tokens.slice(0, 3).join(', ')}${c.tokens.length > 3 ? '...' : ''} (${c.count} tokens)`
          ).join('<br>')}
          ${consolidated.length === 0 ? '<em>No consolidation yet - need more diverse tokens</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔐 Encrypted Message Examples:</strong><br>
          ${encodedSamples.map(s => `
            <div style="margin: 0.75rem 0; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <div style="opacity: 0.7; font-size: 0.85em;">Original:</div>
              <div style="margin: 0.25rem 0;">${s.original}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Encrypted (${s.coverage}% coverage):</div>
              <div style="font-size: 1.3em; letter-spacing: 0.1em; color: var(--accent); margin: 0.25rem 0;">${s.encoded}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Decoded:</div>
              <div style="margin: 0.25rem 0;">${s.decoded}</div>
            </div>
          `).join('')}
        </div>

        <details>
          <summary>📖 View full glyph mapping (first 20 tokens)</summary>
          <pre>${JSON.stringify(
            Object.fromEntries(Array.from(ledger.entries()).slice(0, 20)),
            null, 2
          )}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Usage:</strong> This ledger enables secure inter-system communication. 
          Messages encoded with glyphs can be transmitted efficiently and decoded by any system 
          with the same ledger. The consolidation reduces message size while maintaining semantic meaning.
        </div>
      `);
    }

    // ============================================
    // LOGGING
    // ============================================
    function batchLogUpdates(entries) {
      const fragment = document.createDocumentFragment();
      entries.forEach(entry => fragment.appendChild(entry));
      elements.log.appendChild(fragment);
      elements.log.scrollTop = elements.log.scrollHeight;
    }

    function addLog(content, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>${content}`;
      batchLogUpdates([entry]);
      return entry;
    }

    function appendLog(msg, type = 'info') {
      if (typeof msg === 'string') return addLog(msg, type);
      return addLog(sanitize(String(msg)), type);
    }

    function logStatus(msg) {
      return appendLog(`<div class="processing-indicator"><span class="spinner"></span>${sanitize(msg)}</div>`, 'status');
    }
    function logError(msg) { return appendLog(`🔴 ${sanitize(msg)}`, 'error'); }
    window.logOK = (msg) => addLog(`✅ ${sanitize(String(msg))}`, 'success');
    function logWarning(msg) { return appendLog(`⚠️ ${sanitize(msg)}`, 'warning'); }
    function logFinal(msg) { return appendLog(`✅ ${sanitize(msg)}`, 'success'); }

    function debounce(fn, delay) {
      let timeout;
      return function debounced(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    async function safeAsync(fn, errorMsg) {
      try {
        return await fn();
      } catch (err) {
        logError(`${errorMsg}: ${err.message}`);
        console.error(errorMsg, err);
        return null;
      }
    }

    // ============================================
    // STATS
    // ============================================
    function updateStats() {
      const { totalApiCalls, totalCacheHits, totalCostUsd } = state.sessionStats;
      const total = totalApiCalls + totalCacheHits;
      const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) + '%' : '—';

      const cachedCount = getCachedTokenCount();

      elements.cacheHitRate.textContent = hitRate;
      elements.cachedTokens.textContent = cachedCount;
      elements.sessionCost.textContent = formatCurrency(totalCostUsd);

      // Visual feedback for database growth
      if (cachedCount > 0) {
        elements.cachedTokens.style.color = cachedCount > 50 ? '#00ff88' : '#ffd54f';
      }
    }

    function updateHeaderCounts() {
      updateStats();
    }

    // ============================================
    // CACHE
    // ============================================
    function getCacheKey(token) {
      const normalized = token == null ? '' : String(token);
      return `${TOKEN_CACHE_PREFIX}${normalized.toLowerCase()}`;
    }

    function isTokenCached(token) {
      try {
        return localStorage.getItem(getCacheKey(token)) != null;
      } catch {
        return false;
      }
    }

    function updateTokenIndex(token) {
      if (!token) return;

      let index = safeStorageGet(DB_INDEX_KEY, []);
      if (!Array.isArray(index)) index = [];
      if (!index.includes(token)) {
        index.push(token);
        safeStorageSet(DB_INDEX_KEY, JSON.stringify(index));
      }
    }

    function getFromCache(token) {
      try {
        const raw = safeStorageGet(getCacheKey(token));
        if (!raw) return null;
        state.sessionStats.totalCacheHits++;
        updateStats();
        return raw;
      } catch { return null; }
    }

    function saveToCache(token, data) {
      try {
        const payloadData = Object.assign({ token }, data, {
          cached_at: new Date().toISOString(),
        });
        const recordToken = (typeof payloadData.token === 'string' && payloadData.token)
          ? payloadData.token
          : token;
        payloadData.token = recordToken;
        const payload = JSON.stringify(payloadData);
        const ok = safeStorageSet(getCacheKey(recordToken), payload);
        if (!ok) return;
        updateTokenIndex(recordToken);
        refreshDbReference(payloadData);
      } catch (err) {
        if (err.name === 'QuotaExceededError') {
          logWarning('Cache full. Use /reset to clear old data.');
        }
      }
    }

    window.CognitionEngine.cache = {
      get: getFromCache,
      set: saveToCache,
      key: getCacheKey,
    };

    // ============================================
    // OPENAI API
    // ============================================
    async function callOpenAI(messages, options = {}) {
      if (!state.apiKey) throw new Error('No API key configured');

      const body = {
        model: options.model || CONFIG.DEFAULT_MODEL,
        messages,
        max_tokens: options.max_tokens ?? CONFIG.MAX_TOKENS_PER_RESPONSE,
        temperature: options.temperature || 0.7,
      };

      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
        if (currentAbortController?.signal.aborted) {
          const error = new Error('Cancelled');
          error.name = 'AbortError';
          throw error;
        }

        attempt++;
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.apiKey}`,
            },
            body: JSON.stringify(body),
          });

          if (response.status === 429 && attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
            await new Promise(r => setTimeout(r, CONFIG.RETRY_BASE_DELAY_MS * Math.pow(2, attempt - 1)));
            continue;
          }

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `API error (${response.status})`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error?.message) errorMessage = errorData.error.message;
            } catch (e) {
              if (errorText) errorMessage = errorText;
            }
            
            if (response.status === 401) errorMessage = 'Invalid API key';
            else if (response.status === 403) errorMessage = 'Access forbidden - check billing setup';
            else if (response.status === 429) errorMessage = 'Rate limit exceeded';
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          state.sessionStats.totalApiCalls++;

          const content = data.choices?.[0]?.message?.content?.trim() || '';
          const usage = data.usage || {};
          const promptTokens = usage.prompt_tokens ?? estimateTokensForMessages(messages);
          const completionTokens = usage.completion_tokens ?? estimateTokensForText(content);
          const callCost = estimateCostUsd(promptTokens, completionTokens, body.model);
          state.sessionStats.totalCostUsd += callCost;
          updateStats();

          return content;
        } catch (err) {
          if (err.name === 'AbortError') throw err;
          if (err.message === 'Failed to fetch') {
            throw new Error('Network error - check connection or download HTML to run locally');
          }
          if (attempt === CONFIG.MAX_RETRY_ATTEMPTS) throw err;
        }
      }
    }

    window.CognitionEngine.api = {
      callOpenAI,
    };

    // ============================================
    // ADJACENCY
    // ============================================
    class ProgressTracker {
      constructor(total, label) {
        this.total = total;
        this.current = 0;
        this.label = label;
        this.element = logStatus(`⏳ ${label} (0/${total})`);
      }

      increment(count = 1) {
        this.current += count;
        const percent = this.total === 0 ? 100 : Math.round((this.current / this.total) * 100);
        if (this.element) {
          this.element.innerHTML = `⏳ ${this.label} (${this.current}/${this.total}) - ${percent}%`;
        }
      }

      complete(message) {
        if (this.element) {
          this.element.innerHTML = `✅ ${message || `${this.label} complete`}`;
        }
      }
    }

    async function fetchAdjacency(token, context) {
      if (currentAbortController?.signal.aborted) {
        throw new Error('AbortError');
      }

      const cached = getFromCache(token);
      if (cached) {
        return { ...cached, cache_hit: true };
      }

      if (!state.apiKey) return { token, relationships: {}, offline: true };

      const prompt = `Token: "${token}"
Context: "${context}"

For this token, identify the most relevant adjacent tokens across relationship types. For each that applies, provide related tokens with weights 0.01-1.00.

Relationship types: ≡ Identity, ⊃ Contains, ⊂ Is Contained By, ≈ Variant, ∈ Is Instance Of, ∋ Has Instance, ⊤ Is Type Of, ⊥ Has Type, ⊏ Part Of, ⊐ Composes, ↔ Mirrors, ⇌ Inverts, ∥ Parallel To, ∼ Adjacent To, → Next, ⇒ Sequence Of, ⇐ Preceded By, ↠ Follows, ↗ Spatially Above, ↘ Spatially Below, ⇝ Symbolically Supports, ⇂ Symbolically Depends, ≠ Contrasts, ⊕ Complements, ⊛ Associated With, ∝ Correlates With, ⇝ Causes, ⇐ Caused By, ∗ Evokes, ≜ Represents, ⋆ Symbolizes, 7→ Refers To, ⊢ Defines, ⊣ Is Defined By, ↷ Transforms To, ↶ Transformed From, ◦ Functions As, |= Interpreted As, ◁ Used With, ⇄ Co-occurs With, ⊗ Synthesizes, ÷ Divides Into, ⊘ Opposes, × Rejects, ¬ Negates, † Destroys, ⊠ Blocks, /∈ Invalidates, ⊬ Contradicts, ⊩ Asserts, ⊨ Provides Evidence, ? Uncertainty, ⚡ Memory, ⇒ Attention, ↶ Self-Reference, ∧ Perspective, ↭ Continuity, ▷◁ Relationality

Return JSON: {"token": "${token}", "relationships": {"≡": [{"token": "...", "weight": 0.95}], ...}}`;

      let safePrompt;
      try {
        safePrompt = validatePrompt(prompt);
      } catch (err) {
        logError(`Prompt validation failed for ${token}: ${err.message}`);
        return { token, relationships: {}, error: 'invalid_prompt' };
      }

      const content = await safeAsync(
        () => callOpenAI([
          { role: 'system', content: 'You are an HLSF token adjacency analyzer.' },
          { role: 'user', content: safePrompt },
        ]),
        `Adjacency fetch failed for ${token}`
      );

      if (!content) {
        return { token, relationships: {}, error: 'request_failed' };
      }

      try {
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const parsed = JSON.parse(content.slice(jsonStart, jsonEnd + 1));
        saveToCache(token, parsed);
        return { ...parsed, cache_hit: false };
      } catch {
        return { token, relationships: {}, error: 'Parse failed' };
      }
    }

    async function batchFetchAdjacencies(tokens, context, label) {
      const results = new Map();
      const unique = [...new Set(tokens)];

      const progress = new ProgressTracker(unique.length, label);

      let processed = 0;
      for (let i = 0; i < unique.length; i += CONFIG.MAX_CONCURRENCY) {
        if (currentAbortController?.signal.aborted) {
          progress.complete(`${label} cancelled (${processed}/${unique.length})`);
          break;
        }

        const batch = unique.slice(i, i + CONFIG.MAX_CONCURRENCY);
        const settled = await Promise.allSettled(batch.map(t => fetchAdjacency(t, context)));
        
        settled.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            results.set(batch[idx], result.value);
          }
        });

        processed += batch.length;
        progress.increment(batch.length);
      }

      const hits = Array.from(results.values()).filter(r => r.cache_hit).length;
      progress.complete(`${label}: ${hits} cached, ${results.size - hits} new`);
      return results;
    }

    window.CognitionEngine.processing = {
      fetchAdjacency,
      batchFetchAdjacencies,
    };

    function calculateAttention(matrices) {
      for (const entry of matrices.values()) {
        let weightSum = 0, totalEdges = 0;
        const rels = entry?.relationships || {};
        
        for (const [rel, edges] of Object.entries(rels)) {
          const priority = RELATIONSHIP_PRIORITIES.get(rel) || 0.3;
          if (Array.isArray(edges)) {
            edges.forEach(edge => {
              weightSum += (edge.weight || 0) * priority;
              totalEdges++;
            });
          }
        }
        
        entry.attention_score = totalEdges > 0 ? Number((weightSum / totalEdges).toFixed(3)) : 0;
        entry.total_relationships = totalEdges;
      }
      return matrices;
    }

    function summarizeAttention(matrices) {
      const summary = [];
      for (const [token, data] of matrices.entries()) {
        summary.push({ 
          token, 
          attention: data.attention_score || 0, 
          total: data.total_relationships || 0 
        });
      }
      return summary.sort((a, b) => b.attention - a.attention).slice(0, 10);
    }

    function formatTopTokens(topTokens) {
      const { ledger } = generateGlyphLedger();
      return topTokens.map(t => {
        const glyphEntry = ledger.get(t.token);
        const glyph = glyphEntry ? glyphEntry.glyph : '◌';
        return `<span class="token-highlight">${glyph} ${t.token}</span> (${t.attention.toFixed(2)})`;
      }).join(', ');
    }

    function extractKeyRelationships(matrices) {
      const relationships = [];
      let count = 0;
      for (const [token, data] of matrices.entries()) {
        if (count >= 5) break;
        const rels = data?.relationships || {};
        for (const [rel, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges) || edges.length === 0) continue;
          const topEdge = edges.sort((a, b) => b.weight - a.weight)[0];
          relationships.push(`${token} ${rel} ${topEdge.token} (${topEdge.weight.toFixed(2)})`);
          count++;
          if (count >= 5) break;
        }
      }
      return relationships;
    }

    // ============================================
    // HLSF VISUALIZATION
    // ============================================

    function polygonVertices(center, radius, sides) {
      const vertices = [];
      const angleStep = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep - Math.PI / 2;
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return vertices;
    }

    function deriveAdjacencyPolygon(center, baseRadius, relationships) {
      const entries = Object.entries(relationships || {})
        .filter(([, edges]) => Array.isArray(edges) && edges.length > 0)
        .map(([relType, edges]) => {
          const weightSum = edges.reduce((sum, edge) => {
            const weight = typeof edge.weight === 'number' ? edge.weight : 0;
            return sum + weight;
          }, 0);
          const avgWeight = edges.length > 0 ? weightSum / edges.length : 0;
          return {
            relType,
            count: edges.length,
            avgWeight
          };
        })
        .sort((a, b) => a.relType.localeCompare(b.relType));

      if (entries.length === 0) {
        return {
          vertices: polygonVertices(center, baseRadius * 0.8, 3),
          anchorIndex: 0,
          adjacencyTypes: 0
        };
      }

      const vertexCount = Math.max(entries.length + 1, 3);
      const baseAngle = -Math.PI / 2;
      const angleStep = (2 * Math.PI) / vertexCount;
      const maxCount = Math.max(...entries.map(entry => entry.count));

      const vertices = [];
      const anchor = [center[0], center[1] - baseRadius];
      vertices.push(anchor);

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const normalizedWeight = Math.min(1, Math.max(0, entry.avgWeight));
        const countFactor = maxCount > 0 ? entry.count / maxCount : 0;
        const radialFactor = 0.85 + normalizedWeight * 0.35 + countFactor * 0.25;
        const radius = baseRadius * radialFactor;
        const angle = baseAngle + angleStep * (i + 1);
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }

      let fillerIndex = entries.length;
      while (vertices.length < 3) {
        const angle = baseAngle + angleStep * (fillerIndex + 1);
        vertices.push([
          center[0] + baseRadius * 0.75 * Math.cos(angle),
          center[1] + baseRadius * 0.75 * Math.sin(angle)
        ]);
        fillerIndex++;
      }

      return {
        vertices,
        anchorIndex: 0,
        adjacencyTypes: entries.length
      };
    }

    function buildBaseTriangles(vertices, sides) {
      if (sides < 3) return [];
      const triangles = [];
      const center = vertices.reduce((acc, v) =>
        [acc[0] + v[0] / sides, acc[1] + v[1] / sides], [0, 0]);

      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        triangles.push([center, vertices[i], vertices[next]]);
      }
      return triangles;
    }

    function rotateTrianglesAround(triangles, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return triangles.map(tri => tri.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      }));
    }

    function rotatePointsAround(points, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      });
    }

    function scalePointsAround(points, center, scale) {
      if (!Array.isArray(points)) return [];
      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * scale,
          center[1] + dy * scale
        ];
      });
    }

    function scaleTrianglesAround(triangles, center, scale) {
      if (!Array.isArray(triangles)) return [];
      return triangles.map(tri => scalePointsAround(tri, center, scale));
    }

    window.HLSF.geometry = {
      polygonVertices,
      buildBaseTriangles,
      rotateTrianglesAround,
      rotatePointsAround,
      scalePointsAround,
      scaleTrianglesAround,
      deriveAdjacencyPolygon,
    };

    let hlsfNodes = [];

    function buildHLSFNodes() {
      const graph = window.HLSF_GRAPH;
      let tokenRecords = [];

      if (graph?.tokens instanceof Map) {
        tokenRecords = Array.from(graph.tokens.values());
      } else if (graph?.tokens && typeof graph.tokens === 'object') {
        tokenRecords = Object.values(graph.tokens);
      }

      let sourceLabel = '';

      if (tokenRecords.length === 0) {
        const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
        console.log(`Scanning ${keys.length} cached tokens from storage for HLSF build`);

        for (const key of keys) {
          try {
            const tokenData = safeStorageGet(key);
            if (!tokenData?.token) {
              console.warn('Token missing from data:', key);
              continue;
            }
            tokenRecords.push(tokenData);
          } catch (err) {
            console.error('Failed to process token:', key, err);
          }
        }

        if (graph) {
          graph.tokens = new Map(tokenRecords.map(record => [record.token, record]));
        }

        sourceLabel = '(storage scan)';
      } else {
        sourceLabel = '(graph cache)';
      }

      console.log(`Building HLSF nodes from ${tokenRecords.length} cached tokens ${sourceLabel}`.trim());

      const nodes = [];

      for (const tokenData of tokenRecords) {
        try {
          const token = tokenData.token;

          if (!token) {
            console.warn('Token missing from data:', tokenData);
            continue;
          }

          const rels = tokenData.relationships || {};

          // Count adjacencies
          let adjacencyCount = 0;
          for (const edges of Object.values(rels)) {
            if (Array.isArray(edges)) adjacencyCount += edges.length;
          }
          const adjacencyTypes = Object.values(rels)
            .filter(edges => Array.isArray(edges) && edges.length > 0)
            .length;

          const attention = typeof tokenData.attention_score === 'number'
            ? tokenData.attention_score
            : 0.5;
          const complex = memoizedComplexNumber(token, { ...tokenData, attention_score: attention });
          const glyph = complexToGlyph(complex);

          // Position based on complex number
          const x = complex.real * 2;
          const y = complex.imaginary * 2;

          // Radius based on attention
          const radius = 0.3 + attention * 0.4;

          // Build polygon derived from adjacency structure
          const shape = deriveAdjacencyPolygon([x, y], radius, rels);
          const sides = shape.vertices.length;

          // Color based on attention
          let color;
          if (attention >= 0.8) color = [0, 255, 136];
          else if (attention >= 0.5) color = [255, 213, 79];
          else color = [255, 119, 119];

          nodes.push({
            token,
            glyph,
            center: [x, y],
            radius,
            sides,
            attention,
            adjacencyCount,
            adjacencyTypes,
            anchorIndex: shape.anchorIndex,
            color,
            vertices: shape.vertices,
            triangles: null // Will be computed
          });
        } catch (err) {
          console.error('Failed to process token for HLSF:', tokenData, err);
        }
      }

      console.log(`Built ${nodes.length} HLSF nodes`);
      
      // Generate triangles for each node
      for (const node of nodes) {
        try {
          node.triangles = buildBaseTriangles(node.vertices, node.sides);
        } catch (err) {
          console.error(`Failed to build triangles for ${node.token}:`, err);
          node.triangles = [];
        }
      }
      
      return nodes;
    }

    function initHLSFCanvas() {
      console.log('Initializing HLSF Canvas...');
      
      try {
        // Build nodes first to check if we have data
        hlsfNodes = buildHLSFNodes();
        
        if (hlsfNodes.length === 0) {
          logWarning('No cached tokens found for HLSF. Process some queries first to populate the database.');
          return;
        }
        
        console.log(`Creating canvas UI for ${hlsfNodes.length} nodes`);
        
        const container = document.createElement('div');
        container.className = 'hlsf-canvas-container';
      container.innerHTML = `
        <div style="margin-bottom: 1rem;">
          <div class="section-title">🌌 HLSF: Hierarchical-Level Semantic Framework</div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">
            Geometric token visualization. Each polygon fans outward from a primary corner based on
            adjacency types, forming unique base-level shapes per matrix. Triangular subdivisions show
            hierarchical structure.
          </div>
        </div>
        <canvas id="hlsf-canvas" width="1200" height="600"></canvas>
        <div class="hlsf-controls">
          <div class="hlsf-control-group">
            <label>Rotation Speed</label>
            <input type="range" id="hlsf-rotation-speed" min="0" max="5" step="0.01" value="0.30">
            <span id="hlsf-speed-val">0.30</span>
          </div>

          <div class="hlsf-control-group">
            <label>Alpha Transparency</label>
            <input type="range" id="hlsf-alpha" min="0.005" max="0.99" step="0.01" value="0.10">
            <span id="hlsf-alpha-val">0.10</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>View Controls</label>
            <div class="hlsf-button-row">
              <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
              <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
              <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
              <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Rotation Modes</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-rotation" class="btn btn-primary">Start Global</button>
              <button id="hlsf-toggle-emergent" class="btn btn-success">Start Emergence</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Display Options</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-edges" class="btn btn-neutral">Edges: On</button>
              <button id="hlsf-toggle-labels" class="btn btn-neutral">Labels: On</button>
              <button id="hlsf-toggle-bg" class="btn btn-neutral">BG: Dark</button>
            </div>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.85rem;">
          <strong>Controls:</strong> Drag to pan • Scroll to zoom • Each polygon = token matrix •
          Fan vertices = adjacency types • Color = attention score<br>
          <strong>Modes:</strong> Global rotation = all polygons rotate around center • 
          Emergent rotation = each polygon rotates around its own center
        </div>
      `;
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
      entry.appendChild(container);
      elements.log.appendChild(entry);
      elements.log.scrollTop = elements.log.scrollHeight;
      
      // Initialize canvas
      window.HLSF.canvas = document.getElementById('hlsf-canvas');
      window.HLSF.ctx = window.HLSF.canvas.getContext('2d');
      
      console.log('Canvas initialized:', window.HLSF.canvas ? 'success' : 'failed');
      
      // Setup controls
      const speedSlider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (speedSlider && speedVal) {
        const omega = Number.isFinite(window.HLSF.config.rotationOmega)
          ? window.HLSF.config.rotationOmega
          : 0;
        speedSlider.value = omega.toFixed(2);
        speedVal.textContent = omega.toFixed(2);
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        const alpha = baseAlpha();
        alphaSlider.value = alpha.toFixed(2);
        alphaVal.textContent = alpha.toFixed(2);
        window.HLSF.config.alpha = alpha;
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }
      
      const globalZoomIn = document.getElementById('hlsf-zoom-in');
      if (globalZoomIn) {
        globalZoomIn.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 1.2));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const globalZoomOut = document.getElementById('hlsf-zoom-out');
      if (globalZoomOut) {
        globalZoomOut.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 0.8));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const globalReset = document.getElementById('hlsf-reset-view');
      if (globalReset) {
        globalReset.addEventListener('click', () => {
          window.HLSF.view.scale = 1;
          const canvasEl = window.HLSF.canvas;
          if (canvasEl) {
            const width = canvasEl.clientWidth || canvasEl.width;
            const height = canvasEl.clientHeight || canvasEl.height;
            window.HLSF.view.x = width / 2;
            window.HLSF.view.y = height / 2;
          } else {
            window.HLSF.view.x = 0;
            window.HLSF.view.y = 0;
          }
          syncViewToConfig();
          requestRender();
        });
      }

      const globalPortal = document.getElementById('hlsf-zoom-portal');
      if (globalPortal) {
        globalPortal.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          if (!canvasEl) return;
          const width = canvasEl.clientWidth || canvasEl.width;
          const height = canvasEl.clientHeight || canvasEl.height;
          animateViewport({
            x: width / 2,
            y: height / 2,
            scale: Math.max(1.5, window.HLSF.view.scale * 2),
          }, 350);
        });
      }

      const rotationBtn = document.getElementById('hlsf-toggle-rotation');
      rotationBtn.addEventListener('click', () => {
        window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
        if (window.HLSF.config.rotationActive) {
          window.HLSF.state.emergent.on = false;
          window.HLSF.config.emergentActive = false;
          document.getElementById('hlsf-toggle-emergent').textContent = 'Start Emergence';
        }
        rotationBtn.textContent = window.HLSF.config.rotationActive ? 'Stop Global' : 'Start Global';
        requestRender();
      });

      const emergentBtn = document.getElementById('hlsf-toggle-emergent');
      emergentBtn.addEventListener('click', () => {
        const state = window.HLSF.state.emergent;
        state.on = !state.on;
        window.HLSF.config.emergentActive = state.on;
        if (state.on) {
          window.HLSF.config.rotationActive = false;
          document.getElementById('hlsf-toggle-rotation').textContent = 'Start Global';
        }
        emergentBtn.textContent = state.on ? 'Stop Emergence' : 'Start Emergence';
        requestRender();
      });
      
      const edgesBtn = document.getElementById('hlsf-toggle-edges');
      edgesBtn.addEventListener('click', () => {
        window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
        edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
        debouncedLegacyRender();
      });

      const labelsBtn = document.getElementById('hlsf-toggle-labels');
      labelsBtn.addEventListener('click', () => {
        window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
        labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
        debouncedLegacyRender();
      });

      const bgBtn = document.getElementById('hlsf-toggle-bg');
      bgBtn.addEventListener('click', () => {
        window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
        bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
        debouncedLegacyRender();
      });
      
      // Mouse interaction
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      
      window.HLSF.canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      window.HLSF.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.view.x += dx;
          window.HLSF.view.y += dy;
          syncViewToConfig();
          lastX = e.clientX;
          lastY = e.clientY;
          requestRender();
        }
      });
      
      window.HLSF.canvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        window.HLSF.view.scale = Math.min(12, Math.max(0.25, window.HLSF.view.scale * factor));
        syncViewToConfig();
        requestRender();
      }, { passive: false });
      
      // Center view
      if (window.HLSF.canvas) {
        const width = window.HLSF.canvas.clientWidth || window.HLSF.canvas.width;
        const height = window.HLSF.canvas.clientHeight || window.HLSF.canvas.height;
        window.HLSF.view.x = width / 2;
        window.HLSF.view.y = height / 2;
      } else {
        window.HLSF.view.x = 0;
        window.HLSF.view.y = 0;
      }
      syncViewToConfig();
      
      // Build nodes
      window.HLSF.nodes = hlsfNodes;
      
      // Initial render
      renderLegacyHLSF();

      // Start animation
      animateLegacyHLSF();
      
      logOK(`HLSF visualization initialized with ${hlsfNodes.length} token matrices`);
      
      } catch (err) {
        logError(`Failed to initialize HLSF canvas: ${err.message}`);
        console.error('HLSF canvas error:', err);
        throw err;
      }
    }

    function strokePolygon(ctx, verts) {
      if (!verts || verts.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(verts[0][0], verts[0][1]);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i][0], verts[i][1]);
      ctx.closePath();
      ctx.stroke();
    }

    function strokeTriangles(ctx, tris) {
      if (!tris) return;
      for (const t of tris) strokePolygon(ctx, t);
    }

    function worldToScreen(x, y) {
      const sx = x * (200 * window.HLSF.config.scale) + window.HLSF.config.tx;
      const sy = -y * (200 * window.HLSF.config.scale) + window.HLSF.config.ty;
      return [sx, sy];
    }

    function renderLegacyHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not initialized for renderHLSF');
        return;
      }

      try {
        const ctx = window.HLSF.ctx;
        const width = window.HLSF.canvas.width;
        const height = window.HLSF.canvas.height;
        const theme = window.HLSF.config.whiteBg
          ? { bg: '#ffffff', fg: '#000000', grid: 'rgba(0, 0, 0, 0.05)' }
          : { bg: '#0a0a0a', fg: '#ffffff', grid: 'rgba(0, 255, 136, 0.05)' };
        const nodeScale = clampNodeSize(window.HLSF.config.nodeSize);
        const edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
        const edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
        const effectiveEdgeWidth = edgeWidth * Math.max(0.6, window.HLSF.config.scale || 1);

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = theme.bg;
        ctx.strokeStyle = theme.fg;
        ctx.lineWidth = 1;

        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = theme.grid;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        ctx.strokeStyle = theme.fg;
        if (window.HLSF.config.fillFaces === true) {
          /* intentionally unused now */
        }

        for (const node of window.HLSF.nodes) {
          let triangles = Array.isArray(node.triangles) ? node.triangles : [];
          let vertices = Array.isArray(node.vertices) ? node.vertices : [];
          let centerPoint = Array.isArray(node.center) ? node.center : [0, 0];
          const nodeColor = Array.isArray(node.color) ? node.color : [0, 255, 136];
          const [r, g, b] = nodeColor;

          if (window.HLSF.config.emergentActive) {
            const angle = window.HLSF.state?.emergentRot ?? 0;
            triangles = rotateTrianglesAround(triangles, node.center, angle);
            vertices = rotatePointsAround(vertices, node.center, angle);
          } else if (window.HLSF.config.rotationActive) {
            const angle = window.HLSF.state?.globalRot ?? 0;
            triangles = rotateTrianglesAround(triangles, [0, 0], angle);
            vertices = rotatePointsAround(vertices, [0, 0], angle);
            centerPoint = rotatePointsAround([node.center], [0, 0], angle)[0];
          }

          const scalePivot = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
            ? centerPoint
            : node.center;
          if (Math.abs(nodeScale - 1) > 1e-3) {
            triangles = scaleTrianglesAround(triangles, scalePivot, nodeScale);
            vertices = scalePointsAround(vertices, scalePivot, nodeScale);
          }

          triangles = Array.isArray(triangles) ? triangles : [];
          vertices = Array.isArray(vertices) ? vertices : [];

          const screenTriangles = triangles.map(tri => tri.map(([x, y]) => worldToScreen(x, y)));
          const screenVertices = vertices.map(([x, y]) => worldToScreen(x, y));

          ctx.globalAlpha = baseAlpha();
          ctx.strokeStyle = theme.fg;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.save();
          if (window.HLSF.config.showNodeGlow) {
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.35)`;
            ctx.shadowBlur = 16 * Math.max(1, window.HLSF.config.scale || 1);
          }

          strokePolygon(ctx, screenVertices);
          strokeTriangles(ctx, screenTriangles);
          ctx.restore();

          if (window.HLSF.config.showEdges && screenVertices.length > 1) {
            const anchorIndex = typeof node.anchorIndex === 'number' ? node.anchorIndex : 0;
            const anchor = screenVertices[anchorIndex];
            for (let i = 0; i < screenVertices.length; i++) {
              if (i === anchorIndex) continue;
              const [vx, vy] = screenVertices[i];
              const strokeColor = nodeEdgeStrokeColor(node, i, edgeColorMode) || theme.fg;
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = effectiveEdgeWidth;
              ctx.beginPath();
              ctx.moveTo(anchor[0], anchor[1]);
              ctx.lineTo(vx, vy);
              ctx.stroke();
            }
            ctx.strokeStyle = theme.fg;
          }

          ctx.globalAlpha = 1.0;

          if (window.HLSF.config.showLabels) {
            const centerForLabel = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
              ? centerPoint
              : node.center;
            const [sx, sy] = worldToScreen(centerForLabel[0], centerForLabel[1]);
            ctx.save();
            if (window.HLSF.config.showNodeGlow) {
              ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
              ctx.shadowBlur = 18 * Math.max(1, window.HLSF.config.scale || 1);
            }
            ctx.globalAlpha = baseAlpha();
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
            ctx.font = `${Math.max(12, 20 * window.HLSF.config.scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.glyph, sx, sy);
            ctx.restore();

            ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${Math.max(9, 11 * window.HLSF.config.scale)}px Fira Code, monospace`;
            ctx.fillText(node.token, sx, sy + 25 * window.HLSF.config.scale);
            ctx.globalAlpha = 1.0;
          }
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
        ctx.font = '12px Fira Code, monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Nodes: ${window.HLSF.nodes.length} | Zoom: ${window.HLSF.config.scale.toFixed(2)}x`, 10, 20);

      } catch (err) {
        console.error('Error rendering HLSF:', err);
      }
    }

    const debouncedLegacyRender = debounce(() => {
      if (window.HLSF?.currentGraph) {
        drawComposite(window.HLSF.currentGraph, { glyphOnly: window.HLSF.currentGlyphOnly === true });
      } else {
        renderLegacyHLSF();
      }
    }, 16);

    function requestRender() {
      debouncedLegacyRender();
    }

    function animateViewport(target, ms = 300) {
      const view = window.HLSF.view;
      const start = performance.now();
      const s0 = { x: view.x, y: view.y, scale: view.scale };
      const duration = Number.isFinite(ms) ? Math.max(16, ms) : 300;
      function step(t) {
        const k = Math.min(1, (t - start) / duration);
        const eased = k * (2 - k);
        view.x = s0.x + eased * ((target?.x ?? s0.x) - s0.x);
        view.y = s0.y + eased * ((target?.y ?? s0.y) - s0.y);
        const targetScale = Number.isFinite(target?.scale) ? Math.max(0.1, target.scale) : s0.scale;
        view.scale = s0.scale + eased * (targetScale - s0.scale);
        syncViewToConfig();
        requestRender();
        if (k < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    let _legacyLast = null;
    function animateLegacyHLSF(now) {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not ready for animation');
        return;
      }

      try {
        const timestamp = typeof now === 'number' ? now : performance.now();
        const last = _legacyLast ?? timestamp;
        const dt = (timestamp - last) / 1000;
        _legacyLast = timestamp;
        stepRotation(dt);

        if (window.HLSF.config.rotationActive || window.HLSF.config.emergentActive) {
          renderLegacyHLSF();
        }
      } catch (err) {
        console.error('Error in HLSF animation:', err);
      }

      window.HLSF.animationFrame = requestAnimationFrame(animateLegacyHLSF);
    }

    function stopLegacyHLSFAnimation() {
      try {
        if (window.HLSF && window.HLSF.animationFrame) {
          cancelAnimationFrame(window.HLSF.animationFrame);
          window.HLSF.animationFrame = null;
        }
        if (window.HLSF && window.HLSF.config) {
          window.HLSF.config.rotationActive = false;
          window.HLSF.config.emergentActive = false;
        }
        if (window.HLSF?.state?.emergent) {
          window.HLSF.state.emergent.on = false;
          window.HLSF.state.emergentRot = 0;
        }
        _legacyLast = null;
      } catch (err) {
        console.warn('Error stopping HLSF animation:', err);
      }
    }

    window.HLSF.rendering = {
      render: renderLegacyHLSF,
      animate: animateLegacyHLSF,
      stop: stopLegacyHLSFAnimation,
    };
    function computeRelHistogramEntries(db) {
      const hist = new Map();
      for (const rec of db.full_token_data || []) {
        const rels = rec?.relationships || {};
        for (const key of Object.keys(rels)) {
          const glyph = normalizeRelKeyForStats(key);
          if (!glyph) continue;
          const edges = Array.isArray(rels[key]) ? rels[key] : [];
          if (!edges.length) continue;
          hist.set(glyph, (hist.get(glyph) || 0) + edges.length);
        }
      }
      return [...hist.entries()].sort((a, b) => b[1] - a[1]);
    }

    function computeRelHistogram(db, entries){
      const base = Array.isArray(entries) ? entries : computeRelHistogramEntries(db);
      return base.map(([glyph, count]) => renderRelTypeRow(glyph, count));
    }

    function edgeSignatureForMerge(edge) {
      if (!edge || typeof edge !== 'object') return '';
      const token = edge.token ?? '';
      const relType = edge.type ?? edge.relationship ?? '';
      const weight = Number.isFinite(edge.weight)
        ? edge.weight
        : Number.isFinite(edge.w)
          ? edge.w
          : Number.isFinite(edge.attention)
            ? edge.attention
            : 0;
      return `${token}::${relType}::${weight}`;
    }

    function mergeRelationshipLists(existing, incoming) {
      const base = Array.isArray(existing) ? existing : [];
      const next = Array.isArray(incoming) ? incoming : [];
      if (base.length === 0) return next.slice();
      if (next.length === 0) return base.slice();

      const merged = base.slice();
      const seen = new Set(base.map(edgeSignatureForMerge));
      for (const edge of next) {
        const sig = edgeSignatureForMerge(edge);
        if (!seen.has(sig)) {
          seen.add(sig);
          merged.push(edge);
        }
      }
      return merged;
    }

    function mergeTokenRecords(existing, incoming) {
      if (!existing) return incoming;
      if (!incoming) return existing;

      const merged = Object.assign({}, existing, incoming);
      const baseRels = existing.relationships || {};
      const incomingRels = incoming.relationships || {};
      const relKeys = new Set([...Object.keys(baseRels), ...Object.keys(incomingRels)]);
      const outRels = {};
      for (const key of relKeys) {
        outRels[key] = mergeRelationshipLists(baseRels[key], incomingRels[key]);
      }
      merged.relationships = outRels;
      if (!merged.cached_at) {
        merged.cached_at = existing.cached_at || incoming.cached_at || null;
      }
      return merged;
    }

    function analyzeDatabaseMetadata() {
      const tokenFrequency = new Map();
      const index = new Map();
      let totalAttentionScore = 0;
      let oldestToken = null;
      let newestToken = null;

      const addRecord = (rec) => {
        const normalized = normalizeRecord(rec);
        if (!normalized) return;
        const existing = index.get(normalized.token);
        const merged = mergeTokenRecords(existing, normalized);
        index.set(normalized.token, merged);
      };

      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) addRecord(rec);
      }

      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const key of keys) {
        try {
          const data = safeStorageGet(key);
          if (data && typeof data === 'object') {
            addRecord(data);
          }
        } catch (err) {
          console.error('Failed to parse token:', key, err);
        }
      }

      const tokens = Array.from(index.values());

      const relTypeMaxCache = new Map();
      let maxAdjacencyMatrixCount = 0;
      const maxAdjacencyMatrixTokens = new Set();

      const cachedTokenSet = new Set();
      for (const key of index.keys()) {
        if (key == null) continue;
        cachedTokenSet.add(String(key).toLowerCase());
      }

      const sessionTokenSet = window.Session?.tokens instanceof Set ? window.Session.tokens : new Set();
      let cachedSessionTokens = 0;
      for (const token of sessionTokenSet) {
        if (!token) continue;
        if (cachedTokenSet.has(String(token).toLowerCase())) {
          cachedSessionTokens += 1;
        }
      }
      const sessionTokenCount = sessionTokenSet instanceof Set ? sessionTokenSet.size : 0;
      const sessionCoverage = sessionTokenCount > 0 ? cachedSessionTokens / sessionTokenCount : 0;

      for (const data of tokens) {
        if (!data || typeof data !== 'object') continue;

        if (data.cached_at) {
          const timestamp = new Date(data.cached_at);
          if (!Number.isNaN(timestamp.getTime())) {
            if (!oldestToken || timestamp < new Date(oldestToken.cached_at)) {
              oldestToken = data;
            }
            if (!newestToken || timestamp > new Date(newestToken.cached_at)) {
              newestToken = data;
            }
          }
        }

        const rels = data.relationships || {};
        const adjacencyNeighbors = new Set();
        for (const [relType, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges)) continue;
          const glyph = normalizeRelKeyForStats(relType);
          if (!glyph) continue;

          const uniqueTargets = new Set();

          for (const edge of edges) {
            const rawToken = edge?.token;
            const normalizedToken = typeof rawToken === 'string' ? rawToken.trim() : '';
            if (normalizedToken) {
              const freqKey = normalizedToken.toLowerCase();
              tokenFrequency.set(freqKey, (tokenFrequency.get(freqKey) || 0) + 1);
              adjacencyNeighbors.add(normalizedToken);
              uniqueTargets.add(normalizedToken);
            }
          }

          if (uniqueTargets.size > 0) {
            const entry = relTypeMaxCache.get(glyph);
            if (!entry || uniqueTargets.size > entry.count) {
              const tokensWithPeak = new Set();
              const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
              if (sourceToken) tokensWithPeak.add(sourceToken);
              relTypeMaxCache.set(glyph, { count: uniqueTargets.size, tokens: tokensWithPeak });
            } else if (uniqueTargets.size === entry.count) {
              const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
              if (sourceToken) entry.tokens.add(sourceToken);
            }
          }
        }

        if (adjacencyNeighbors.size > 0) {
          if (adjacencyNeighbors.size > maxAdjacencyMatrixCount) {
            maxAdjacencyMatrixCount = adjacencyNeighbors.size;
            maxAdjacencyMatrixTokens.clear();
            const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
            if (sourceToken) maxAdjacencyMatrixTokens.add(sourceToken);
          } else if (adjacencyNeighbors.size === maxAdjacencyMatrixCount) {
            const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
            if (sourceToken) maxAdjacencyMatrixTokens.add(sourceToken);
          }
        }

        if (data.attention_score) {
          totalAttentionScore += data.attention_score;
        }
      }

      const limitList = (collection, max = 10) => {
        const out = [];
        if (!collection) return out;
        if (Array.isArray(collection)) {
          for (const value of collection) {
            if (value == null || value === '') continue;
            out.push(value);
            if (out.length >= max) break;
          }
          return out;
        }
        if (typeof collection[Symbol.iterator] === 'function') {
          for (const value of collection) {
            if (value == null || value === '') continue;
            out.push(value);
            if (out.length >= max) break;
          }
        }
        return out;
      };

      let maxRelTypeCount = 0;
      const maxRelTypeEntries = [];
      for (const [glyph, info] of relTypeMaxCache.entries()) {
        if (!info || !Number.isFinite(info.count)) continue;
        if (info.count <= 0) continue;
        if (info.count > maxRelTypeCount) {
          maxRelTypeCount = info.count;
          maxRelTypeEntries.length = 0;
        }
        if (info.count === maxRelTypeCount) {
          maxRelTypeEntries.push({
            type: glyph,
            tokens: limitList(info.tokens, 10),
          });
        }
      }

      const maxAdjacencyMatrixSummary = {
        count: maxAdjacencyMatrixCount,
        tokens: limitList(maxAdjacencyMatrixTokens, 10),
      };

      const relHistogramEntries = computeRelHistogramEntries({ full_token_data: tokens });
      const relHistogramRows = computeRelHistogram(null, relHistogramEntries);
      const dbStats = computeDbStats(index);
      const totalRelationships = dbStats.relationships;
      const topRelationships = relHistogramEntries.slice(0, 10);
      const topRelationshipRows = relHistogramRows.slice(0, 10);

      const topTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);

      const highAttentionTokens = tokens
        .filter(t => t?.attention_score)
        .sort((a, b) => (b.attention_score || 0) - (a.attention_score || 0))
        .slice(0, 10);

      const adjacencyCostPerToken = estimateCostUsd(
        CONFIG.ADJACENCY_TOKEN_ESTIMATES.prompt,
        CONFIG.ADJACENCY_TOKEN_ESTIMATES.completion
      );

      return {
        totalTokens: dbStats.tokens,
        totalRelationships,
        avgAttentionScore: tokens.length > 0 ? (totalAttentionScore / tokens.length).toFixed(3) : 0,
        topRelationships,
        topRelationshipRows,
        relHistogramRows,
        topTokens,
        highAttentionTokens,
        oldestToken,
        newestToken,
        estimatedValue: tokens.length * adjacencyCostPerToken,
        rawData: tokens,
        dbStats,
        sessionTokenCount,
        cachedSessionTokens,
        sessionCoverage,
        maxRelTypeTokens: {
          count: maxRelTypeCount,
          types: maxRelTypeEntries,
        },
        maxAdjacencyMatrixTokens: maxAdjacencyMatrixSummary,
      };
    }

    function showDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      const dbStats = Object.assign({
        tokens: metadata.totalTokens,
        relationships: metadata.totalRelationships,
        nodes: 0,
        edges: 0,
        anchors: 0,
        minEdges: { count: 0, tokens: [] },
        maxEdges: { count: 0, tokens: [] },
      }, metadata.dbStats || {});

      const formatEdgeTokens = (edgeInfo) => {
        if (!edgeInfo || !Array.isArray(edgeInfo.tokens) || edgeInfo.tokens.length === 0) {
          return '';
        }
        const maxDisplay = 5;
        const rendered = edgeInfo.tokens.slice(0, maxDisplay)
          .map(token => `<span class="token-highlight">${token}</span>`)
          .join(', ');
        const extraCount = edgeInfo.tokens.length - maxDisplay;
        const extra = extraCount > 0
          ? ` <small style="opacity: 0.65;">(+${extraCount} more)</small>`
          : '';
        return `${rendered}${extra}`;
      };

      const formatEdgeSummary = (edgeInfo) => {
        const count = Number.isFinite(edgeInfo?.count) ? edgeInfo.count : 0;
        const tokensDisplay = formatEdgeTokens(edgeInfo);
        if (tokensDisplay) {
          return `<strong>${count}</strong> (${tokensDisplay})`;
        }
        if ((dbStats.tokens || 0) === 0) {
          return `<strong>${count}</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        return `<strong>${count}</strong>`;
      };

      const minEdgeSummary = formatEdgeSummary(dbStats.minEdges);
      const maxEdgeSummary = formatEdgeSummary(dbStats.maxEdges);

      const sessionTokenCount = metadata.sessionTokenCount || 0;
      const coverageRatioRaw = (typeof metadata.sessionCoverage === 'number' && Number.isFinite(metadata.sessionCoverage))
        ? metadata.sessionCoverage
        : 0;
      const coverageRatio = Math.min(Math.max(coverageRatioRaw, 0), 1);
      const coverageDisplay = sessionTokenCount > 0 ? `${(coverageRatio * 100).toFixed(1)}%` : '0.0%';
      const coverageCountSummary = sessionTokenCount > 0
        ? `Coverage: <strong>${metadata.cachedSessionTokens || 0}</strong> / <strong>${sessionTokenCount}</strong> (${coverageDisplay})`
        : 'Coverage: No session tokens observed yet';

      const formatHighlightList = (tokens, maxDisplay = 5) => {
        if (!Array.isArray(tokens) || tokens.length === 0) return '';
        const rendered = tokens.slice(0, maxDisplay)
          .map(token => `<span class="token-highlight">${token}</span>`)
          .join(', ');
        const extraCount = tokens.length - maxDisplay;
        const extra = extraCount > 0
          ? ` <small style="opacity: 0.65;">(+${extraCount} more)</small>`
          : '';
        return `${rendered}${extra}`;
      };

      const maxRelTypeTokens = metadata.maxRelTypeTokens || { count: 0, types: [] };
      const maxRelTypeSummary = (() => {
        const count = Number.isFinite(maxRelTypeTokens?.count) ? maxRelTypeTokens.count : 0;
        if (count <= 0) {
          return `<strong>0</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        const entries = Array.isArray(maxRelTypeTokens.types) ? maxRelTypeTokens.types : [];
        if (entries.length === 0) {
          return `<strong>${count}</strong>`;
        }
        const [primary, ...rest] = entries;
        const typeLabel = primary?.type ? relDisplay(primary.type) : 'Unknown';
        const tokenDisplay = formatHighlightList(primary?.tokens || []);
        const extraTypes = rest.length;
        const extraTypeNote = extraTypes > 0
          ? ` <small style="opacity: 0.65;">(+${extraTypes} other type${extraTypes === 1 ? '' : 's'})</small>`
          : '';
        const tokenNote = tokenDisplay ? ` — ${tokenDisplay}` : '';
        return `<strong>${count}</strong> via <span class="token-highlight">${typeLabel}</span>${tokenNote}${extraTypeNote}`;
      })();

      const maxAdjacencyMatrixTokens = metadata.maxAdjacencyMatrixTokens || { count: 0, tokens: [] };
      const maxAdjacencySummary = (() => {
        const count = Number.isFinite(maxAdjacencyMatrixTokens?.count) ? maxAdjacencyMatrixTokens.count : 0;
        if (count <= 0) {
          return `<strong>0</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        const tokenDisplay = formatHighlightList(maxAdjacencyMatrixTokens.tokens || []);
        return tokenDisplay
          ? `<strong>${count}</strong> — ${tokenDisplay}`
          : `<strong>${count}</strong>`;
      })();

      let maturityLevel;
      let maturityColor;
      let maturityMessage;
      if (sessionTokenCount === 0) {
        maturityLevel = 'Early';
        maturityColor = 'var(--accent)';
        maturityMessage = 'No session tokens analyzed yet. Run a prompt to begin building cache coverage.';
      } else if (coverageRatio >= 0.95) {
        maturityLevel = 'Mature';
        maturityColor = 'var(--success)';
        maturityMessage = 'Cached knowledge covers 95%+ of observed inputs and outputs. Most queries reuse stored insights.';
      } else if (coverageRatio >= 0.6) {
        maturityLevel = 'Growing';
        maturityColor = 'var(--warning)';
        maturityMessage = 'Coverage is building. Many session tokens are cached but new ones still appear.';
      } else {
        maturityLevel = 'Early';
        maturityColor = 'var(--accent)';
        maturityMessage = 'Cache coverage is limited. Expect frequent new adjacency generation.';
      }

      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">📊 Collective Database Metadata</div>
        
        <div class="adjacency-insight">
          <strong>🌐 Knowledge Base Status:</strong> <span style="color: ${maturityColor}; font-weight: bold;">${maturityLevel}</span><br>
          <small style="opacity: 0.8;">${maturityMessage}</small><br>
          <small style="opacity: 0.8; display: block; margin-top: 0.25rem;">${coverageCountSummary}</small>
        </div>

        <div class="adjacency-insight">
          <strong>💾 Database Size:</strong><br>
          • Total cached tokens: <strong>${metadata.totalTokens}</strong><br>
          • Total relationships: <strong>${metadata.totalRelationships}</strong><br>
          • Graph nodes (≥1 outgoing): <strong>${dbStats.nodes}</strong><br>
          • Edge types enumerated: <strong>${dbStats.edges}</strong><br>
          • Anchors (in ∩ out): <strong>${dbStats.anchors}</strong><br>
          • Minimum edges per token: ${minEdgeSummary}<br>
          • Maximum edges per token: ${maxEdgeSummary}<br>
          • Max tokens in a relationship type: ${maxRelTypeSummary}<br>
          • Max tokens per adjacency matrix: ${maxAdjacencySummary}<br>
          • Average attention score: <strong>${metadata.avgAttentionScore}</strong><br>
          • Network density: <strong>${(metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)}</strong> edges/token<br>
          • Estimated saved cost: <strong>${formatCurrency(metadata.estimatedValue || 0)}</strong>
        </div>

        <div class="adjacency-insight">
          <strong>📈 Most Common Relationship Types:</strong><br>
          ${metadata.topRelationshipRows.map(row =>
            `• <span class="token-highlight">${row}</span>`
          ).join('<br>')}
          ${metadata.topRelationshipRows.length === 0 ? '<em>No relationships cached yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔥 Most Referenced Tokens (Hub Concepts):</strong><br>
          <small style="opacity: 0.8;">These tokens appear most frequently across relationships - they represent core concepts in the knowledge graph.</small><br><br>
          ${metadata.topTokens.slice(0, 10).map(([token, count]) => 
            `• <span class="token-highlight">${token}</span>: ${count} references`
          ).join('<br>')}
          ${metadata.topTokens.length === 0 ? '<em>No hub concepts identified yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>⭐ Highest Attention Tokens:</strong><br>
          <small style="opacity: 0.8;">Tokens with the strongest weighted relationships - highly salient concepts.</small><br><br>
          ${metadata.highAttentionTokens.map(t => 
            `• <span class="token-highlight">${t.token}</span>: ${t.attention_score} (${t.total_relationships || 0} edges)`
          ).join('<br>')}
          ${metadata.highAttentionTokens.length === 0 ? '<em>No high-attention tokens yet</em>' : ''}
        </div>

        ${metadata.oldestToken ? `
        <div class="adjacency-insight">
          <strong>📅 Database Timeline:</strong><br>
          • Oldest entry: <strong>${metadata.oldestToken.token}</strong> (${new Date(metadata.oldestToken.cached_at).toLocaleString()})<br>
          • Newest entry: <strong>${metadata.newestToken.token}</strong> (${new Date(metadata.newestToken.cached_at).toLocaleString()})
        </div>
        ` : ''}

        <details>
          <summary>📊 View knowledge graph analytics</summary>
          <pre>${JSON.stringify({
            database_maturity: maturityLevel,
            network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
            top_5_relationship_types: metadata.topRelationships.slice(0, 5).map(([rel]) => relDisplay(rel)),
            relationship_histogram_named: metadata.relHistogramRows,
            top_5_hub_concepts: metadata.topTokens.slice(0, 5).map(([token]) => token),
            db_graph_metrics: dbStats,
            relationship_type_peaks: {
              max_tokens: metadata.maxRelTypeTokens?.count || 0,
              types: (metadata.maxRelTypeTokens?.types || []).map(entry => ({
                type: entry.type,
                type_display: relDisplay(entry.type),
                tokens: entry.tokens,
              })),
            },
            adjacency_matrix_peaks: {
              max_tokens: metadata.maxAdjacencyMatrixTokens?.count || 0,
              tokens: metadata.maxAdjacencyMatrixTokens?.tokens || [],
            },
            growth_metrics: {
              tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
              avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)
            },
            session_cache_coverage: {
              observed_tokens: sessionTokenCount,
              cached_tokens: metadata.cachedSessionTokens || 0,
              coverage_ratio: Number(coverageRatio.toFixed(3)),
              coverage_percent: sessionTokenCount > 0 ? Number((coverageRatio * 100).toFixed(1)) : 0
            }
          }, null, 2)}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Insight:</strong> This metadata represents the collective intelligence being built. 
          In a server deployment, this would be shared across all users, with each query contributing 
          to a growing knowledge base that makes future queries faster and cheaper. The database also 
          powers the symbolic glyph encryption system for secure inter-system communication.
        </div>
      `);
    }

    function exportDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      const dbStats = Object.assign({
        tokens: metadata.totalTokens,
        relationships: metadata.totalRelationships,
        nodes: 0,
        edges: 0,
        anchors: 0,
        minEdges: { count: 0, tokens: [] },
        maxEdges: { count: 0, tokens: [] },
      }, metadata.dbStats || {});

      const sessionTokenCount = metadata.sessionTokenCount || 0;
      const coverageRatioRaw = (typeof metadata.sessionCoverage === 'number' && Number.isFinite(metadata.sessionCoverage))
        ? metadata.sessionCoverage
        : 0;
      const coverageRatio = Math.min(Math.max(coverageRatioRaw, 0), 1);
      const coveragePercent = sessionTokenCount > 0 ? Number((coverageRatio * 100).toFixed(1)) : 0;
      const maturityLevel = sessionTokenCount === 0
        ? 'early'
        : (coverageRatio >= 0.95 ? 'mature' : coverageRatio >= 0.6 ? 'growing' : 'early');

      const exportData = {
        export_timestamp: new Date().toISOString(),
        readme: {
          description: "HLSF Cognition Engine - Collective Database Metadata Export",
          purpose: "This export contains the complete adjacency token database and analytics. It represents the collective intelligence built through token relationship analysis.",
          usage: "This data can be imported into a server-side database to bootstrap a new deployment or shared for analysis.",
          version: "2.0"
        },
        database_stats: {
          total_tokens: metadata.totalTokens,
          total_relationships: metadata.totalRelationships,
          graph_nodes: dbStats.nodes,
          edge_types_enumerated: dbStats.edges,
          anchors: dbStats.anchors,
          min_edges_per_token: {
            count: Number.isFinite(dbStats.minEdges?.count) ? dbStats.minEdges.count : 0,
            tokens: Array.isArray(dbStats.minEdges?.tokens) ? dbStats.minEdges.tokens : [],
          },
          max_edges_per_token: {
            count: Number.isFinite(dbStats.maxEdges?.count) ? dbStats.maxEdges.count : 0,
            tokens: Array.isArray(dbStats.maxEdges?.tokens) ? dbStats.maxEdges.tokens : [],
          },
          max_tokens_per_relationship_type: {
            count: metadata.maxRelTypeTokens?.count || 0,
            types: (metadata.maxRelTypeTokens?.types || []).map(entry => ({
              type: entry.type,
              type_display: relDisplay(entry.type),
              tokens: entry.tokens,
            })),
          },
          max_tokens_per_adjacency_matrix: {
            count: metadata.maxAdjacencyMatrixTokens?.count || 0,
            tokens: metadata.maxAdjacencyMatrixTokens?.tokens || [],
          },
          avg_attention_score: metadata.avgAttentionScore,
          estimated_value_usd: metadata.estimatedValue.toFixed(2),
          maturity_level: maturityLevel,
          session_token_count: sessionTokenCount,
          session_tokens_cached: metadata.cachedSessionTokens || 0,
          session_token_coverage_ratio: Number(coverageRatio.toFixed(3)),
          session_token_coverage_percent: coveragePercent
        },
        relationship_distribution: Object.fromEntries(metadata.topRelationships),
        relationship_distribution_named: Object.fromEntries(metadata.topRelationships.map(([glyph, count]) => [relDisplay(glyph), count])),
        hub_concepts: Object.fromEntries(metadata.topTokens),
        high_attention_tokens: metadata.highAttentionTokens.map(t => ({
          token: t.token,
          attention_score: t.attention_score,
          total_relationships: t.total_relationships
        })),
        knowledge_graph_metrics: {
          network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(3),
          avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
          tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
          oldest_entry: metadata.oldestToken?.cached_at,
          newest_entry: metadata.newestToken?.cached_at,
          date_range_days: metadata.oldestToken && metadata.newestToken ? 
            Math.ceil((new Date(metadata.newestToken.cached_at) - new Date(metadata.oldestToken.cached_at)) / (1000 * 60 * 60 * 24)) : 0
        },
        full_token_data: metadata.rawData
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      logOK(`Database metadata exported: ${metadata.totalTokens} tokens, ${metadata.totalRelationships} relationships, ${(new Blob([JSON.stringify(exportData)]).size / 1024).toFixed(1)}KB`);
    }

    async function importHLSFDBFromFile(file) {
      const txt = await file.text();
      const count = loadDbObject(txt);
      const db = getDb();
      if (!db) return;
      const seen = [];
      for (const rec of db.full_token_data || []) {
        safeStorageSet(TOKEN_CACHE_PREFIX + rec.token, JSON.stringify(rec));
        seen.push(rec.token);
      }
      safeStorageSet(DB_INDEX_KEY, JSON.stringify(seen));
      state.hlsfReady = false;
      window.HLSF_GRAPH = null;
      updateStats();
      addLog(`📊 Import: ${seen.length} tokens (${count} normalized).`);
      updateHeaderCounts();
    }

    function importDatabaseData(data, source = 'file') {
      try {
        const normalizedCount = loadDbObject(data);
        const db = getDb();
        if (!db) throw new Error('Failed to hydrate database');

        state.hlsfReady = false;
        let totalTokens = 0;
        try {
          totalTokens = loadDbObject(data);
        } catch (err) {
          console.warn('Failed to persist raw DB snapshot:', err);
        }

        const tokenData = data.full_token_data;
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        const seen = new Set();

        for (const token of tokenData) {
          if (!token?.token) continue;

          const key = getCacheKey(token.token);
          const existing = safeStorageGet(key);
          seen.add(token.token);

          if (existing) {
            const existingData = typeof existing === 'string' ? JSON.parse(existing) : existing;
            const importedDate = new Date(token.cached_at || 0);
            const existingDate = new Date(existingData?.cached_at || 0);

            if (importedDate > existingDate) {
              safeStorageSet(key, JSON.stringify(token));
              updated++;
            } else {
              skipped++;
            }
          } else {
            safeStorageSet(key, JSON.stringify(token));
            imported++;
          }
        }

        if (!totalTokens) {
          safeStorageSet(DB_INDEX_KEY, JSON.stringify(Array.from(seen)));
        }
        updateStats();

        const summary = [];
        if (imported > 0) summary.push(`${imported} new tokens imported`);
        if (updated > 0) summary.push(`${updated} tokens updated`);
        if (skipped > 0) summary.push(`${skipped} existing tokens kept`);
        if (!summary.length) summary.push('no cache changes');

        logOK(`Database imported from ${source}: ${summary.join(', ')}, normalized ${normalizedCount} tokens`);

        if (data?.database_stats) {
          addLog(`<div class="adjacency-insight">
            📊 <strong>Import Summary:</strong><br>
            • Source maturity: ${data.database_stats.maturity_level}<br>
            • Total tokens in source: ${data.database_stats.total_tokens}<br>
            • Total relationships: ${data.database_stats.total_relationships}<br>
            • Estimated value: ${data.database_stats.estimated_value_usd}
          </div>`);
        }

        return { imported, skipped, updated, seen: Array.from(seen), normalizedCount };
      } catch (err) {
        logError(`Import failed: ${err.message || err}`);
        return null;
      }
    }

    // ============================================
    // COMMANDS
    // ============================================
    const COMMANDS = window.COMMANDS = window.COMMANDS || Object.create(null);

    function registerCommand(name, handler) {
      if (!name || typeof handler !== 'function') return;
      const key = name.startsWith('/') ? name.toLowerCase() : `/${name.toLowerCase()}`;
      COMMANDS[key] = handler;
    }

    async function tryBootstrapDb() {
      if (getDb()) return true;

      let href = null;
      try {
        const url = new URL(location.href);
        href = url.searchParams.get('db') || window.HLSF.config.bootstrapDbUrl;
      } catch (err) {
        console.warn('Failed to parse bootstrap URL:', err);
      }

      if (!href) return false;

      try {
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
        return true;
      } catch (e) {
        logStatus(`Bootstrap DB fetch failed: ${String(e.message || e)}`);
        return false;
      }
    }

    function dbIndex() {
      const db = getDb();
      const idx = new Map();
      (db?.full_token_data || []).forEach(record => {
        if (record?.token) idx.set(record.token, record);
      });
      return idx;
    }

    function tokenWeight(token, idx) {
      const rec = idx.get(token);
      if (!rec) return 0.5;
      const relationships = Object.values(rec.relationships || {});
      const weights = [];
      for (const arr of relationships) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const w = rel?.weight;
          if (typeof w === 'number' && Number.isFinite(w)) weights.push(w);
        }
      }
      if (!weights.length) return 0.5;
      const maxW = Math.max(...weights);
      const meanW = weights.reduce((sum, value) => sum + value, 0) / weights.length;
      return Math.max(0.01, Math.min(1.0, 0.6 * maxW + 0.4 * meanW));
    }

    function hashGlyphForToken(token) {
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i = 0; i < token.length; i++) {
        h ^= token.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return GLYPH_SET[h % GLYPH_SET.length];
    }

    function glyphForToken(token) {
      if (!TokenToGlyph.has(token)) {
        // Ensure existing ledger mappings are available before hashing
        if (!TokenToGlyph.size) loadLedger();
      }
      return TokenToGlyph.get(token) || hashGlyphForToken(token);
    }

    function ledgerAdd(ledger, glyph, token, weight) {
      if (!ledger.glyph_map[glyph]) ledger.glyph_map[glyph] = [];
      const arr = ledger.glyph_map[glyph];
      const numericWeight = Number(weight);
      const now = Date.now();
      const found = arr.find(entry => entry.token === token);
      if (found) {
        found.w = numericWeight;
        found.t = now;
      } else {
        arr.push({ token, w: numericWeight, t: now });
      }
      TokenToGlyph.set(token, glyph);
      if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
      GlyphToToken.get(glyph).add(token);
      return ledger;
    }

    function ledgerBestToken(ledger, glyph, weight) {
      const arr = Array.isArray(ledger.glyph_map[glyph]) ? ledger.glyph_map[glyph] : [];
      if (!arr.length) return null;
      let best = arr[0];
      let bestDistance = Math.abs((best?.w ?? 0) - weight);
      for (let i = 1; i < arr.length; i++) {
        const candidate = arr[i];
        const distance = Math.abs((candidate?.w ?? 0) - weight);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      }
      return best?.token || null;
    }

    function parseGlyphFloatSequence(input) {
      const tokens = [];
      if (!input) return tokens;
      const segments = input.trim().split(/\s+/);
      for (const segment of segments) {
        if (!segment) continue;
        let cursor = 0;
        while (cursor < segment.length) {
          let glyph = null;
          for (const candidate of GLYPH_SET) {
            if (segment.startsWith(candidate, cursor)) {
              if (!glyph || candidate.length > glyph.length) glyph = candidate;
            }
          }
          if (!glyph) break;
          cursor += glyph.length;
          let nextGlyphIndex = segment.length;
          for (const candidate of GLYPH_SET) {
            const idx = segment.indexOf(candidate, cursor);
            if (idx !== -1 && idx < nextGlyphIndex) nextGlyphIndex = idx;
          }
          const numberPortion = segment.slice(cursor, nextGlyphIndex);
          cursor = nextGlyphIndex;
          let weight = parseFloat(numberPortion);
          if (!Number.isFinite(weight)) weight = 0.5;
          tokens.push({ glyph, weightStr: numberPortion, weight });
        }
      }
      return tokens;
    }

    function encryptTextToGlyphs(plain, options = {}) {
      const { persistUnknown = true } = options || {};
      const idx = dbIndex();
      const ledger = loadLedger();
      const words = (plain || '').trim().split(/\s+/).filter(Boolean);
      const out = [];
      const unknown = [];
      let covered = 0;
      let mutated = false;

      for (const word of words) {
        const glyph = glyphForToken(word);
        const weight = tokenWeight(word, idx);
        if (persistUnknown || idx.has(word)) {
          ledgerAdd(ledger, glyph, word, weight);
          mutated = true;
        }
        out.push(glyph + NUM_FMT(weight));
        if (idx.has(word)) covered++;
        else unknown.push(word);
      }

      if (mutated) saveLedger(ledger);
      const encrypted = out.join(GLYPH_SEP);
      const coverage = words.length ? (100 * covered / words.length).toFixed(1) : '0.0';
      return { encrypted, coverage, unknown };
    }

    function decryptGlyphsToText(cipher) {
      const ledger = loadLedger();
      const pairs = parseGlyphFloatSequence(cipher || '');
      const out = [];
      const unresolved = [];
      let resolved = 0;

      for (const pair of pairs) {
        const token = ledgerBestToken(ledger, pair.glyph, pair.weight);
        if (token) {
          out.push(token);
          resolved++;
        } else {
          out.push('<?>');
          unresolved.push({ glyph: pair.glyph, weight: pair.weight });
        }
      }

      const coverage = pairs.length ? (100 * resolved / pairs.length).toFixed(1) : '0.0';
      return { decrypted: out.join(' '), coverage, unresolved };
    }

    function cmdLedger(arg) {
      const ledger = loadLedger();
      const [sub] = (arg || '').trim().split(/\s+/);
      if (sub === 'export') {
        const blob = new Blob([JSON.stringify(ledger, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `glyph_ledger_${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);
        return logFinal('Ledger exported.');
      }
      if (sub === 'import') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = async e => {
          try {
            const file = e.target.files?.[0];
            if (!file) return;
            const text = await file.text();
            const imported = JSON.parse(text);
            hydrateLedgerMaps(imported);
            saveLedger(imported);
            logFinal('Ledger imported.');
          } catch (err) {
            logError(`Ledger import failed: ${err.message}`);
          }
        };
        input.click();
        return;
      }

      const lines = [];
      const map = ledger.glyph_map || {};
      const glyphs = Object.keys(map).sort();
      for (const glyph of glyphs) {
        const arr = Array.isArray(map[glyph]) ? map[glyph] : [];
        if (!arr.length) continue;
        const latest = [...arr].sort((a, b) => (b?.t ?? 0) - (a?.t ?? 0))[0];
        const weightStr = NUM_FMT(latest?.w ?? 0);
        lines.push(`${glyph} ${weightStr} → ${latest?.token || ''}`.trim());
      }
      return logFinal(lines.length ? lines.join('\n') : 'Ledger empty.');
    }

    function cmdGlyph(argsStr) {
      const idx = dbIndex();
      const tokens = (argsStr || '').trim().split(/\s+/).filter(Boolean);
      if (!tokens.length) {
        logError('Usage: /glyph <token1 token2 ...>');
        return;
      }
      const ledger = loadLedger();
      const outputs = [];
      for (const token of tokens) {
        const glyph = glyphForToken(token);
        const weight = tokenWeight(token, idx);
        ledgerAdd(ledger, glyph, token, weight);
        outputs.push(glyph + NUM_FMT(weight));
      }
      saveLedger(ledger);
      logFinal(outputs.join(GLYPH_SEP));
    }

    function cmdEncrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /encrypt <text>');
        return;
      }
      const { encrypted, coverage } = encryptTextToGlyphs(text, { persistUnknown: true });
      logFinal(`🔐 ${encrypted}\nCoverage: ${coverage}%`);
    }

    function cmdDecrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /decrypt <glyph+float sequence>');
        return;
      }
      const { decrypted, coverage } = decryptGlyphsToText(text);
      logFinal(`🔓 ${decrypted}\nCoverage: ${coverage}%`);
    }


    async function cmdImport() {
      const input = document.getElementById('db-file');
      if (!input) {
        logError('File input unavailable');
        return;
      }
      input.value = '';
      input.onchange = async e => {
        try {
          const f = e.target.files?.[0];
          if (!f) return;
          const text = await f.text();
          const n = loadDbObject(text);
          logFinal(`DB loaded. Tokens: ${n}`);
        } catch (err) {
          logError(String(err.message || err));
        } finally {
          e.target.value = '';
          input.onchange = null;
        }
      };
      input.click();
    }

    async function cmdLoadDb(arg) {
      try {
        const href = (arg || '').trim() || window.HLSF.config.bootstrapDbUrl;
        if (!href) throw new Error('Usage: /loaddb <url-or-path>');
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
      } catch (e) {
        logError(`load failed: ${String(e.message || e)}`);
      }
    }

    async function cmdHlsf(rawArgs) {
      if (!getDb()) {
        const ok = await tryBootstrapDb();
        if (!ok) {
          logError('No DB loaded. Use /loaddb or /import.');
          return;
        }
      }

      const originalArgs = (rawArgs || '').trim();
      const { text: sanitizedArgs, flags } = extractHlsfFlags(originalArgs);
      const args = parseHlsfArgs(sanitizedArgs);
      const prevBatchLogging = window.HLSF.config.batchLogging;
      const prevDeferred = window.HLSF.config.deferredRender;
      const runOptions = {
        batchLogging: flags.batchLogging ?? (prevBatchLogging !== false),
        deferredRender: flags.deferredRender ?? (prevDeferred !== false),
      };
      window.HLSF.config.batchLogging = runOptions.batchLogging;
      window.HLSF.config.deferredRender = runOptions.deferredRender;

      if (flags.metricScope) {
        window.HLSF.config.metricScope = normalizeMetricScope(flags.metricScope);
      }
      if (Object.prototype.hasOwnProperty.call(flags, 'relationTypeCap')) {
        window.HLSF.config.relationTypeCap = flags.relationTypeCap === Infinity
          ? Infinity
          : clampRelationTypeCap(flags.relationTypeCap);
      }
      if (Object.prototype.hasOwnProperty.call(flags, 'edgesPerType')) {
        window.HLSF.config.edgesPerType = flags.edgesPerType === Infinity
          ? Infinity
          : clampEdgesPerType(flags.edgesPerType);
      }

      BatchLog.clear();

      const canvas = ensureHLSFCanvas();
      if (!canvas) {
        window.HLSF.config.batchLogging = prevBatchLogging;
        window.HLSF.config.deferredRender = prevDeferred;
        logError('Unable to initialize canvas for HLSF rendering.');
        return;
      }

      if (runOptions.deferredRender) hideVisualizer();
      else showVisualizer();

      const loggingActive = window.HLSF.config.batchLogging !== false;
      const start = performance.now();

      const time = async (name, fn) => {
        const phaseStart = performance.now();
        if (loggingActive) BatchLog.phase(name, 'start');
        try {
          const result = await fn();
          if (loggingActive) {
            BatchLog.phase(name, 'end', { dt: (performance.now() - phaseStart) | 0 });
          }
          return result;
        } catch (err) {
          if (loggingActive) BatchLog.phase(name, 'error', { err: String(err) });
          throw err;
        }
      };

      try {
        if (loggingActive) {
          BatchLog.phase('hlsf', 'start', {
            args: originalArgs || '',
            resolved: sanitizedArgs || '',
            flags: runOptions,
            scope: window.HLSF.config.metricScope,
          });
        }

        const index = await time('index', async () => loadOrGetIndex());
        const { anchors, idx, glyphOnly } = await time('anchors', async () => anchorsForMode(args, index));
        const effectiveIndex = idx || index;
        const metricScope = window.HLSF.config.metricScope || METRIC_SCOPE.RUN;
        let anchorsToUse = Array.isArray(anchors) ? [...anchors] : [];
        if (metricScope === METRIC_SCOPE.DB) {
          anchorsToUse = effectiveIndex instanceof Map ? Array.from(effectiveIndex.keys()) : anchorsToUse;
        }

        if (!Array.isArray(anchorsToUse) || !anchorsToUse.length) {
          logError('DB is empty. Use /loaddb or /import.');
          return;
        }

        let depth = Number.isFinite(args.depth) ? args.depth : 3;
        if (Number.isFinite(flags.depth)) depth = flags.depth;
        if (metricScope === METRIC_SCOPE.DB) depth = 0;

        let graph = null;
        let runMetrics = { nodes: 0, edges: 0, relationships: 0, anchors: 0 };
        let layoutResult = null;

        if (metricScope === METRIC_SCOPE.RUN) {
          graph = await time('graph', async () => assembleGraphFromAnchorsLogged(anchorsToUse, depth, effectiveIndex));
          await time('cluster', async () => { applyAffinityClusters(graph, effectiveIndex); });
          layoutResult = await time('layout', async () => computeLayout(graph, effectiveIndex, { scope: window.HLSF?.config?.hlsfScope }));
          await time('stage', async () => prepareBuffers(graph, layoutResult, { glyphOnly: glyphOnly === true }));
          await time('render', async () => {
            showVisualizer();
            drawComposite(graph, { glyphOnly: glyphOnly === true });
            animateComposite(graph, glyphOnly === true);
          });
          runMetrics = graph?._metrics || ensureGraphMetrics(graph);
        } else {
          if (loggingActive) BatchLog.phase('graph', 'skip', { scope: METRIC_SCOPE.DB });
          stopHLSFAnimation();
          hideVisualizer();
          window.HLSF.currentGraph = null;
          window.HLSF.currentGlyphOnly = false;
          runMetrics = computeDbStats(effectiveIndex);
        }

        const dbStats = metricScope === METRIC_SCOPE.RUN
          ? computeDbStats(effectiveIndex)
          : runMetrics;

        window.HLSF.metrics = Object.assign({}, window.HLSF.metrics || {}, { db: dbStats });

        const suffix = originalArgs ? ` ${originalArgs}` : '';
        const layoutInfo = layoutResult?.layout || graph?.dimensionLayout || null;
        const dimVal = layoutInfo ? layoutInfo.dimension || 0 : 0;
        const levelCount = layoutInfo ? layoutInfo.levelCount || 0 : 0;
        const lastComponents = layoutInfo ? layoutInfo.lastLevelComponents || 0 : 0;
        const scopeUsed = (layoutInfo?.scope || window.HLSF?.config?.hlsfScope || 'db').toString().toLowerCase();
        logOK(`/hlsf${suffix} → nodes ${runMetrics.nodes} / ${dbStats.nodes}, edges ${runMetrics.edges} / ${dbStats.edges}, relationships ${runMetrics.relationships} / ${dbStats.relationships}, anchors ${runMetrics.anchors} / ${dbStats.anchors} D=${dimVal}, levels=${levelCount}, last_level_components=${lastComponents}, scope=${scopeUsed}`);
        addLog(`ⓘ run / db • tokens(db) ${dbStats.tokens}`);

        if (runMetrics.relationships < runMetrics.edges) {
          addLog('⚠ run relationships < run edge-types; check dedupe or caps.');
        }
        if (window.HLSF.config.metricScope === METRIC_SCOPE.RUN && runMetrics.nodes > dbStats.tokens) {
          addLog('⚠ run nodes > db tokens; index inconsistency.');
        }

        window.HLSF.lastCommand = {
          rawArgs: originalArgs,
          resolvedArgs: sanitizedArgs,
          args,
          anchors: [...anchorsToUse],
          idx: effectiveIndex,
          glyphOnly: glyphOnly === true,
          depth,
          flags: runOptions,
          metricScope,
        };
        syncHlsfControls(document.getElementById('hlsf-canvas-container'));

        if (loggingActive) {
          BatchLog.phase('hlsf', 'end', {
            total_ms: (performance.now() - start) | 0,
            nodes: runMetrics.nodes,
            edges: runMetrics.edges,
            relationships: runMetrics.relationships,
            anchors: runMetrics.anchors,
            metric_scope: metricScope,
            db_nodes: dbStats.nodes,
            db_edges: dbStats.edges,
            db_relationships: dbStats.relationships,
            db_tokens: dbStats.tokens,
            dimension: dimVal,
            levels: levelCount,
            last_level_components: lastComponents,
            scope: scopeUsed,
          });
        }
      } finally {
        window.HLSF.config.batchLogging = prevBatchLogging;
        window.HLSF.config.deferredRender = prevDeferred;
      }
    }

    async function runHlsfSafely(args) {
      try {
        await cmdHlsf(args);
      } catch (err) {
        if (window.HLSF?.config?.batchLogging !== false) {
          BatchLog.phase('hlsf', 'fatal', { err: String(err) });
        }
        showVisualizer();
        logError(String(err?.message || err));
      }
    }

    async function rebuildHlsfFromLastCommand(logUpdate = false) {
      const last = window.HLSF?.lastCommand;
      if (!last || !last.idx || !Array.isArray(last.anchors) || !last.anchors.length) return null;
      if (last.metricScope === METRIC_SCOPE.DB) {
        if (logUpdate) {
          const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
          logStatus(`↻ /hlsf${suffix} (scope=db) → metrics-only run; nothing to rebuild.`);
        }
        return null;
      }
      try {
        const depth = Number.isFinite(last.depth) ? last.depth : 3;
        const graph = await assembleGraphFromAnchorsLogged(last.anchors, depth, last.idx, { silent: true });
        applyAffinityClusters(graph, last.idx);
        const layout = computeLayout(graph, last.idx, { scope: window.HLSF?.config?.hlsfScope });
        prepareBuffers(graph, layout, { glyphOnly: last.glyphOnly === true });
        showVisualizer();
        drawComposite(graph, { glyphOnly: last.glyphOnly === true });
        animateComposite(graph, last.glyphOnly === true);
        syncHlsfControls(document.getElementById('hlsf-canvas-container'));
        if (logUpdate) {
          const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
          const m = graph?._metrics || ensureGraphMetrics(graph);
          logStatus(`↻ /hlsf${suffix} → nodes ${m.nodes}, edges ${m.edges}, relationships ${m.relationships}, anchors ${m.anchors}`);
        }
        return graph;
      } catch (err) {
        console.warn('Failed to rebuild HLSF command:', err);
        return null;
      }
    }

    function cmdScheme(arg) {
      const mode = (arg || '').toLowerCase();
      window.HLSF.config.whiteBg = mode === 'white';
      if (window.HLSF.currentGraph) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Scheme: ${window.HLSF.config.whiteBg ? 'Black lines on white' : 'White lines on black'}`);
    }

    function cmdSpin(arg) {
      const value = (arg || '').toLowerCase();
      window.HLSF.config.rotationActive = /^(on|true|1)$/i.test(value) || (!value && true);
      if (window.HLSF.currentGraph && !_anim) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Rotation: ${window.HLSF.config.rotationActive ? 'on' : 'off'}`);
    }

    function cmdOmega(arg) {
      const w = parseFloat(arg);
      if (!Number.isFinite(w)) {
        logError('Usage: /omega <rad/s>');
        return;
      }
      window.HLSF.config.rotationOmega = w;
      const slider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (slider) slider.value = w.toFixed(2);
      if (speedVal) speedVal.textContent = w.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Rotation omega = ${w.toFixed(2)} rad/s`);
    }

    function cmdAlpha(arg) {
      const parsed = parseFloat(arg);
      if (!Number.isFinite(parsed)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      const a = clampAlpha(parsed);
      if (!Number.isFinite(a)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      window.HLSF.config.alpha = a;
      const slider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (slider) slider.value = a.toFixed(2);
      if (alphaVal) alphaVal.textContent = a.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Alpha = ${a.toFixed(2)}`);
    }

    async function cmd_import() {
      await cmdImport();
    }

    async function cmd_loaddb(args) {
      const joined = Array.isArray(args) ? args.join(' ') : args;
      await cmdLoadDb(joined);
    }

    function getRelationshipPriority(relType) {
      if (RELATIONSHIP_PRIORITIES instanceof Map) {
        return RELATIONSHIP_PRIORITIES.get(relType) ?? 1;
      }
      if (typeof RELATIONSHIP_PRIORITIES === 'object' && RELATIONSHIP_PRIORITIES !== null) {
        return RELATIONSHIP_PRIORITIES[relType] ?? 1;
      }
      return 1;
    }

    function* iterTokenRecords() {
      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) yield rec;
        return;
      }
      const idxRaw = safeStorageGet(DB_INDEX_KEY, []);
      const idx = Array.isArray(idxRaw) ? idxRaw : [];
      const keys = idx.length ? idx.map(t => TOKEN_CACHE_PREFIX + t)
                              : safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const k of keys) {
        const rec = safeStorageGet(k);
        if (rec) yield rec;
      }
    }

    function buildHLSF() {
      const pri = RELATIONSHIP_PRIORITIES || {};
      const nodes = [];
      const edges = [];
      let maxAttention = 0;

      for (const rec of iterTokenRecords()) {
        if (!rec || !rec.token || !rec.relationships) continue;
        let attention = 0;

        for (const rawKey of Object.keys(rec.relationships)) {
          const type = normRelKey(rawKey);
          const p = (pri[type] ?? pri.get?.(type)) ?? 1;
          for (const rel of rec.relationships[rawKey]) {
            const w = rel.weight ?? 0;
            attention += w * p;
            edges.push({ source: rec.token, target: rel.token, type, w });
          }
        }
        maxAttention = Math.max(maxAttention, attention);
        nodes.push({ id: rec.token, attention });
      }

      const norm = maxAttention || 1;
      for (const n of nodes) n.attention = +(n.attention / norm).toFixed(3);

      return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
    }

    async function cmd_hlsf() {
      await runHlsfSafely('');
    }

    registerCommand('/import', cmd_import);
    registerCommand('/loaddb', cmd_loaddb);
    window.COMMANDS = COMMANDS;
    // Router guard (prevents duplicate logs)
    if (!COMMANDS.__hlsf_bound) {
      COMMANDS['/hlsf'] = cmd_hlsf;
      COMMANDS.__hlsf_bound = true;
    }
    registerCommand('/visualize', cmd_hlsf);

    async function dispatchCommand(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return false;

      const parts = trimmed.split(/\s+/);
      const [raw, ...rest] = parts;
      const command = raw.startsWith('/') ? raw.toLowerCase() : `/${raw.toLowerCase()}`;
      const arg = rest.join(' ').trim();

      if (command === '/import') { await cmdImport(); return true; }
      if (command === '/loaddb') { await cmdLoadDb(arg); return true; }
      if (command === '/hlsf') { await runHlsfSafely(arg); return true; }
      if (command === '/scheme') { cmdScheme(arg || 'black'); return true; }
      if (command === '/spin') { cmdSpin(arg || 'on'); return true; }
      if (command === '/omega') { cmdOmega(arg); return true; }
      if (command === '/alpha') { cmdAlpha(arg); return true; }

      return false;
    }

    function isCommand(input) { return input.startsWith('/'); }

    async function handleCommand(cmd) {
      const trimmed = cmd.trim();
      const handled = await safeAsync(() => dispatchCommand(trimmed), `Command dispatch failed for ${trimmed}`);
      if (handled) return;

      const segments = trimmed.slice(1).split(/\s+/);
      const [command, ...args] = segments;

      if (!command) {
        logError('Unknown command');
        return;
      }

      const normalized = `/${command.toLowerCase()}`;
      const mapped = COMMANDS[normalized];
      if (mapped) {
        await mapped(args, trimmed);
        return;
      }

      switch (command.toLowerCase()) {
        case 'clear':
          elements.log.innerHTML = '';
          logOK('Log cleared');
          break;
        case 'reset':
          if (confirm('Clear all cached data?')) {
            const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
            keys.forEach(k => safeStorageRemove(k));
            safeStorageRemove(DB_INDEX_KEY);
            let hadDbSnapshot = false;
            try {
              hadDbSnapshot = localStorage.getItem(DB_RAW_KEY) != null;
            } catch (err) {
              console.warn('Unable to inspect DB snapshot state:', err);
            }
            safeStorageRemove(DB_RAW_KEY);
            state.hlsfReady = false;
            window.HLSF_GRAPH = null;
            if (window.HLSF) {
              window.HLSF.matrices = null;
              window.HLSF.layoutCache = null;
              window.HLSF.dbCache = null;
              window.HLSF.indexCache = null;
              window.HLSF.indexCacheSource = null;
              window.HLSF.currentGraph = null;
              window.HLSF.currentGlyphOnly = false;
              window.HLSF.__centerInit = false;
            }
            Session.tokens.clear();
            updateStats();
            const clearedMsg = hadDbSnapshot
              ? `Cleared ${keys.length} tokens and database snapshot`
              : `Cleared ${keys.length} tokens`;
            logOK(clearedMsg);
          }
          break;
        case 'stats':
          const { totalApiCalls, totalCacheHits, totalCostUsd } = state.sessionStats;
          const total = totalApiCalls + totalCacheHits;
          const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) : 0;
          addLog(`<strong>Session Stats:</strong><br>
            • Requests: ${total}<br>
            • Cache hits: ${totalCacheHits} (${hitRate}%)<br>
            • API calls: ${totalApiCalls}<br>
            • Cost: ${formatCurrency(totalCostUsd)}<br>
            • Cached tokens: ${getCachedTokenCount()}`);
          break;
        case 'database':
        case 'db':
          showDatabaseMetadata();
          break;
        case 'export':
          exportDatabaseMetadata();
          break;
        case 'glyph':
          cmdGlyph(args.join(' '));
          break;
        case 'ledger':
          cmdLedger(args.join(' '));
          break;
        case 'encrypt':
          cmdEncrypt(args.join(' '));
          break;
        case 'decrypt':
          cmdDecrypt(args.join(' '));
          break;
        case 'exportledger':
          cmdLedger('export');
          break;
        case 'help':
          addLog(`<strong>Commands:</strong><br>
            /clear - Clear log<br>
            /reset - Clear cache<br>
            /stats - Session statistics<br>
            /database or /db - View database metadata<br>
            /export - Export database metadata as JSON<br>
            /import - Import database from JSON file<br>
            /loaddb &lt;url&gt; - Load database JSON from URL<br>
            /glyph &lt;token1 token2 ...&gt; - Show weighted glyph assignments<br>
            /ledger [show|export|import] - Manage private glyph ledger<br>
            /encrypt &lt;text&gt; - Encrypt text into weighted glyphs<br>
            /decrypt &lt;glyph+float&gt; - Decrypt using private ledger<br>
            /exportledger - Shortcut for /ledger export<br>
            /hlsf or /visualize - Visualize database as Hierarchical-Level Semantic Framework — builds from anchors<br>
            /help - Show commands`);
          break;
        default:
          logError(`Unknown: ${command}`);
      }
    }

    // ============================================
    // MAIN PROCESSING
    // ============================================
    async function processPrompt(prompt) {
      if (state.isProcessing) return;
      
      state.isProcessing = true;
      currentAbortController = new AbortController();
      elements.sendBtn.disabled = true;
      elements.cancelBtn.style.display = 'inline-block';
      elements.input.disabled = true;

      const startTime = performance.now();

      try {
        const tokens = tokenize(prompt);
        if (tokens.length === 0) {
          logError('Prompt cannot be empty');
          return;
        }
        addConversationTokens(tokens);
        if (tokens.length > CONFIG.MAX_TOKENS_PER_PROMPT) {
          logError(`Exceeds ${CONFIG.MAX_TOKENS_PER_PROMPT} token limit (${tokens.length})`);
          return;
        }

        const uniqueTokens = [...new Set(tokens)];
        const cachedTokens = uniqueTokens.filter(isTokenCached).length;
        const newTokenCount = Math.max(0, uniqueTokens.length - cachedTokens);

        const chatMessages = [
          { role: 'system', content: 'You are an expert assistant.' },
          { role: 'user', content: prompt },
        ];
        const chatPromptTokens = estimateTokensForMessages(chatMessages);
        const chatCompletionTokens = estimateCompletionTokens(chatPromptTokens);
        const chatCallCount = state.apiKey ? 3 : 0;
        const chatCostEstimate = chatCallCount * estimateCostUsd(chatPromptTokens, chatCompletionTokens);

        const adjacencyCallCount = state.apiKey ? newTokenCount : 0;
        const adjacencyCostEstimate = adjacencyCallCount > 0
          ? adjacencyCallCount * estimateCostUsd(
              CONFIG.ADJACENCY_TOKEN_ESTIMATES.prompt,
              CONFIG.ADJACENCY_TOKEN_ESTIMATES.completion
            )
          : 0;

        const estimatedCost = chatCostEstimate + adjacencyCostEstimate;
        const totalEstimatedCalls = chatCallCount + adjacencyCallCount;

        addLog(`<div class="cost-estimate">
          📊 <strong>Estimate:</strong> ${tokens.length} input tokens observed (${newTokenCount} new, ${cachedTokens} cached).<br>
          • Chat completions: ~${chatCallCount} call${chatCallCount === 1 ? '' : 's'} (${formatCurrency(chatCostEstimate)}).<br>
          • Adjacency builds: ~${adjacencyCallCount} new call${adjacencyCallCount === 1 ? '' : 's'} (${formatCurrency(adjacencyCostEstimate)}).<br>
          <strong>Total projected cost:</strong> ${formatCurrency(estimatedCost)} across ~${totalEstimatedCalls} API call${totalEstimatedCalls === 1 ? '' : 's'} (final depends on model output).
        </div>`);

        // Step 1: Initial response
        let initialResponse = '';
        if (state.apiKey) {
          const s1 = logStatus('⏳ Generating initial response...');
          initialResponse = await callOpenAI([
            { role: 'system', content: 'You are an expert assistant.' },
            { role: 'user', content: prompt },
          ]);
          s1.innerHTML = `✅ Initial response generated`;
        } else {
          initialResponse = '⚠️ Offline mode';
          logWarning('Skipped (offline)');
        }

        // Step 2: Adjacency analysis
        const responseTokens = tokenize(initialResponse);
        addConversationTokens(responseTokens);
        const [inputMatrices, outputMatrices] = await Promise.all([
          batchFetchAdjacencies(tokens, prompt, 'input'),
          batchFetchAdjacencies(responseTokens, initialResponse, 'output'),
        ]);

        calculateAttention(inputMatrices);
        calculateAttention(outputMatrices);

        const allMatrices = new Map([...inputMatrices, ...outputMatrices]);
        const topTokens = summarizeAttention(allMatrices);
        const keyRels = extractKeyRelationships(allMatrices);

        addLog(`<div class="adjacency-insight">
          <strong>🎯 High Attention:</strong> ${formatTopTokens(topTokens)}
        </div>
        <div class="adjacency-insight">
          <strong>🔗 Key Relationships:</strong><br>
          ${keyRels.map(r => `• ${r}`).join('<br>')}
        </div>`);

        // Step 3: Thought stream
        let thoughtStream = '';
        if (state.apiKey) {
          const s2 = logStatus('⏳ Synthesizing thought stream...');
          thoughtStream = await callOpenAI([
            { role: 'system', content: 'You create reflective thought streams from analytical insights.' },
            { role: 'user', content: `Based on these adjacency insights, generate a stream-of-consciousness internal monologue:\n\nTop tokens: ${JSON.stringify(topTokens)}\nRelationships: ${keyRels.join('; ')}\n\nWrite as flowing natural thought connecting these elements.` },
          ]);
          s2.innerHTML = '✅ Thought stream captured';
          
          addLog(`<div class="section-divider"></div>
            <div class="section-title">💭 Emergent Thought Stream</div>
            <div class="thought-stream">${sanitize(thoughtStream)}</div>`);
        }

        // Step 4: Refined response
        let refinedResponse = initialResponse;
        if (state.apiKey) {
          const s3 = logStatus('⏳ Refining response...');
          refinedResponse = await callOpenAI([
            { role: 'system', content: 'You refine responses based on adjacency insights.' },
            { role: 'user', content: `Original: "${initialResponse}"\n\nInsights: ${thoughtStream}\n\nRevise by: 1) Incorporating emergent insights 2) Restructuring based on token relationships 3) Enhancing coherence. Provide revised response only.` },
          ]);
          s3.innerHTML = '✅ Response refined';
        }
        addConversationTokens(tokenize(refinedResponse));

        // Display final output
        const time = ((performance.now() - startTime) / 1000).toFixed(1);
        addLog(`<div class="section-divider"></div>
          <div class="final-output">
            <h3>✨ REFINED RESPONSE</h3>
            <pre>${sanitize(refinedResponse)}</pre>
            
            <details>
              <summary>Compare with original response</summary>
              <pre>${sanitize(initialResponse)}</pre>
            </details>
            
            <details>
              <summary>View adjacency data (${allMatrices.size} tokens)</summary>
              <pre>${JSON.stringify(Array.from(allMatrices.entries()).slice(0, 5), null, 2)}</pre>
            </details>
          </div>
        `);
        
        logOK(`Processing complete (${time}s)`);

      } catch (err) {
        if (err.name === 'AbortError' || err.message === 'AbortError') {
          logWarning('Processing cancelled');
        } else {
          logError(err.message || 'Processing failed');
          console.error(err);
        }
      } finally {
        state.isProcessing = false;
        currentAbortController = null;
        elements.sendBtn.disabled = false;
        elements.cancelBtn.style.display = 'none';
        elements.input.disabled = false;
        elements.input.value = '';
        elements.input.focus();
      }
    }

    // ============================================
    // EVENTS
    // ============================================
    function applyApiKeyFromModal() {
      const key = elements.apiKeyInput.value.trim();
      if (!isValidApiKey(key)) {
        logError('Invalid API key format');
        return;
      }
      state.apiKey = key.trim();
      const persisted = safeStorageSet(API_KEY_STORAGE_KEY, state.apiKey);
      elements.apiModal.classList.add('hidden');
      if (!persisted) {
        logWarning('API key configured but not saved to storage');
      }
      logOK('API key configured');
    }

    elements.apiConfirmBtn.addEventListener('click', applyApiKeyFromModal);

    elements.apiKeyInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        applyApiKeyFromModal();
      }
    });

    elements.apiCancelBtn.addEventListener('click', () => {
      elements.apiModal.classList.add('hidden');
      logWarning('Offline mode - limited functionality');
    });

    elements.sendBtn.addEventListener('click', () => {
      const input = elements.input.value.trim();
      if (!input) return;
      
      addLog(`> ${sanitize(input)}`);
      
      if (isCommand(input)) {
        handleCommand(input);
        elements.input.value = '';
      } else {
        onUserPromptSubmitted(input);
        processPrompt(input);
      }
    });

    elements.cancelBtn.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
        logWarning('Cancelling...');
      }
    });

    elements.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.sendBtn.click();
      }
    });

    // ============================================
    // INIT
    // ============================================
    window.addEventListener('beforeunload', () => {
      state.apiKey = '';
      stopHLSFAnimation();
    });

    async function initialize() {
      updateStats();

      const storedKey = safeStorageGet(API_KEY_STORAGE_KEY, '');
      if (isValidApiKey(storedKey)) {
        state.apiKey = storedKey.trim();
        elements.apiKeyInput.value = state.apiKey;
        elements.apiModal.classList.add('hidden');
        logOK('Loaded stored API key');
      } else if (storedKey) {
        safeStorageRemove(API_KEY_STORAGE_KEY);
      }

      await tryBootstrapDb();

      const cachedCount = getCachedTokenCount();
      
      addLog(`<strong>🧠 HLSF Cognition Engine v2.0</strong><br><br>
        This engine performs:<br>
        1. Token adjacency mapping (50 relationship types)<br>
        2. Attention score calculation<br>
        3. Emergent thought stream synthesis<br>
        4. Response refinement based on insights<br>
        5. <strong>Symbolic glyph encryption</strong> (complex number encoding)<br>
        6. <strong>HLSF visualization</strong> (hierarchical semantic framework)<br><br>
        <strong>Commands:</strong> /help, /hlsf, /glyph, /encrypt, /decrypt<br>
        ${cachedCount > 0 ? `<br>✅ Loaded with ${cachedCount} cached tokens` : ''}
        <br><small>⚠️ Note: Download HTML and run locally for API calls to work.</small>
      `);
      
      elements.input.focus();
    }

    window.addEventListener('load', () => {
      tryBootstrapDb();
    });

    initialize();
  </script>
</body>
</html>