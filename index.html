<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HLSF Cognition Engine v2.0</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0a0a;
      --panel: #111;
      --text: #e0e0e0;
      --accent: #00ff88;
      --error: #ff4444;
      --success: #44ff44;
      --warning: #ffd54f;
      --scrollbar: #1f1f1f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Fira Code', Consolas, Monaco, 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
      width: 100%;
    }

    #header {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      font-weight: normal;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .stat-value {
      font-weight: bold;
      color: var(--accent);
    }

    #log {
      flex: 1;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
      min-height: 400px;
    }

    #log::-webkit-scrollbar { width: 10px; }
    #log::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 10px; }

    #input-area {
      margin-top: 1rem;
      display: flex;
      gap: 0.75rem;
    }

    #command-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      transition: border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    #command-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn-primary { background: var(--accent); color: #022d15; }
    .btn-secondary { background: #333; color: var(--text); }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.25);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .log-entry {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      animation: fadeIn 0.3s ease;
    }

    .log-entry .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .log-entry.status { font-style: italic; }
    .log-entry.error { border-left-color: var(--error); color: var(--error); }
    .log-entry.success { border-left-color: var(--success); color: var(--success); }
    .log-entry.warning { border-left-color: var(--warning); color: var(--warning); }

    .cost-estimate {
      background: rgba(255, 213, 79, 0.1);
      border: 1px solid var(--warning);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
    }

    .section-divider {
      margin: 1.5rem 0 0.5rem 0;
      border-top: 2px solid #222;
      padding-top: 1rem;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .thought-stream {
      background: rgba(0, 255, 136, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 8px;
      padding: 1rem;
      font-style: italic;
      line-height: 1.6;
    }

    .adjacency-insight {
      background: rgba(255, 213, 79, 0.05);
      border: 1px solid rgba(255, 213, 79, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .token-highlight {
      background: rgba(0, 255, 136, 0.2);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: bold;
    }

    .final-output {
      border-left: 3px solid var(--success);
      padding: 1rem;
      background: rgba(68, 255, 68, 0.05);
      border-radius: 8px;
    }

    .final-output h3 {
      margin-top: 0;
      color: var(--success);
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #222;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin: 0.5rem 0;
      transition: border 0.2s ease;
    }

    details[open] {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.25);
    }

    summary {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      list-style: none;
      font-weight: 600;
      padding: 0.3rem 0;
    }

    summary::-webkit-details-marker { display: none; }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0.5rem 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: #111;
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2rem;
      width: min(420px, 90vw);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-content h2 { margin: 0; color: var(--accent); }

    .hlsf-canvas-container {
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
    }

    #hlsf-canvas {
      width: 100%;
      height: 600px;
      background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
      border-radius: 8px;
      cursor: grab;
    }

    #hlsf-canvas:active {
      cursor: grabbing;
    }

    .hlsf-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .hlsf-control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .hlsf-control-group label {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .hlsf-control-group input[type="range"] {
      width: 100%;
    }

    .hlsf-control-group input[type="number"] {
      width: 80px;
      padding: 0.5rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 6px;
      color: var(--text);
    }

    .hlsf-button-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hlsf-button-row button {
      flex: 1;
      min-width: 80px;
    }

    .hlsf-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      margin-top: 0.5rem;
    }

    .hlsf-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .hlsf-legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .modal-content input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #222;
      background: #0c0c0c;
      color: var(--text);
      font-size: 1rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .pill-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pill-button.primary { background: var(--accent); color: #022d15; }
    .pill-button.secondary { background: transparent; border: 1px solid #333; color: var(--text); }

    .pill-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.18);
    }

    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 136, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    .processing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      #app { padding: 1rem; }
      #header { flex-direction: column; align-items: flex-start; }
      .header-stats { flex-direction: column; gap: 0.5rem; }
      #input-area { flex-direction: column; }
      .button-group { flex-direction: column; }
      .btn { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="api-modal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true">
      <h2>Enter OpenAI API Key</h2>
      <p>Provide your OpenAI API key (sk-...) to begin using the HLSF Cognition Engine.</p>
      <input id="api-key-input" type="password" placeholder="sk-..." />
      <div class="modal-actions">
        <button id="api-cancel" class="pill-button secondary">Continue offline</button>
        <button id="api-confirm" class="pill-button primary">Save key</button>
      </div>
      <small style="opacity:0.65">⚠️ Note: Download this HTML file and run locally for API calls to work.</small>
    </div>
  </div>

  <div id="app">
    <div id="header">
      <div>HLSF Cognition Engine v2.0</div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">Cache Hit Rate</span>
          <span class="stat-value" id="cache-hit-rate">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Cached Tokens</span>
          <span class="stat-value" id="cached-tokens">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Session Cost</span>
          <span class="stat-value" id="session-cost">$0.00</span>
        </div>
      </div>
    </div>
    <div id="log"></div>
    <div id="input-area">
      <input id="command-input" type="text" placeholder="> Enter a prompt or /command" maxlength="600" autocomplete="off" />
      <div class="button-group">
        <button id="cancel-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
        <button id="send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
    <input id="db-file" type="file" accept="application/json" style="display:none">
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      MAX_TOKENS_PER_PROMPT: 100,
      MAX_CONCURRENCY: 5,
      MAX_RETRY_ATTEMPTS: 3,
      RETRY_BASE_DELAY_MS: 500,
      DEFAULT_MODEL: 'gpt-4o-mini',
      ESTIMATED_COST_PER_API_CALL: 0.02,
    };

    window.HLSF = window.HLSF || {
      config: {
        rotationSpeed: 0.5,
        alpha: 0.3,
        scale: 1,
        tx: 0,
        ty: 0,
        rotationActive: false,
        emergentActive: false,
        globalRotation: 0,
        showEdges: true,
        showLabels: true,
        whiteBg: false,
      },
      canvas: null,
      ctx: null,
      nodes: [],
      animationFrame: null,
      geometry: {},
      rendering: {},
    };

    window.CognitionEngine = window.CognitionEngine || {
      state: {},
      cache: {},
      api: {},
      processing: {},
    };

    window.GlyphSystem = window.GlyphSystem || {
      ledger: null,
      encode: () => '',
      decode: () => '',
      export: () => ({}),
    };

    // ---- HLSF constants
    const TOKEN_CACHE_PREFIX = 'hlsf_token_';
    const DB_RAW_KEY = 'hlsf_db_raw';        // stores JSON export text
    const DB_INDEX_KEY = 'hlsf_db_index';    // array of token strings

    // Symbolic glyphs for complex number representation
    const GLYPH_LIBRARY = [
      '◉', '◈', '◇', '◆', '◊', '○', '●', '◐', '◑', '◒',
      '◓', '☉', '⊙', '⊚', '⊛', '⊜', '⊝', '◎', '◍', '◌',
      '△', '▲', '▽', '▼', '◁', '▷', '◀', '▶', '⬟', '⬠',
      '⬡', '⬢', '⬣', '⬤', '⬥', '⬦', '⬧', '⬨', '⬩', '⬪',
      '⬫', '⬬', '⬭', '⬮', '⬯', '⭐', '★', '☆', '✦', '✧',
      '✶', '✷', '✸', '✹', '✺', '✻', '✼', '✽', '✾', '✿',
      '❀', '❁', '❂', '❃', '❄', '❅', '❆', '❇', '❈', '❉',
      '⚙', '⚛', '⚝', '⚞', '⚟', '⚬', '⚭', '⚮', '⚯', '⚰'
    ];

    const RELATIONSHIP_PRIORITIES = new Map([
      ['≡', 1.0], ['⊃', 1.0], ['⊂', 0.8], ['≈', 0.7], ['∈', 0.9], ['∋', 0.9],
      ['⊤', 0.9], ['⊥', 0.9], ['⊏', 0.8], ['⊐', 0.8], ['↔', 0.7], ['⇌', 0.7],
      ['∥', 0.6], ['∼', 0.5], ['→', 0.5], ['⇒', 0.5], ['⇐', 0.5], ['↠', 0.5],
      ['↗', 0.4], ['↘', 0.4], ['⇝', 1.0], ['⇂', 0.7], ['≠', 0.8], ['⊕', 0.8],
      ['⊛', 0.7], ['∝', 0.7], ['⇝ Causes', 1.0], ['⇐ Caused By', 0.9],
      ['∗', 0.7], ['≜', 0.9], ['⋆', 0.8], ['7→', 0.7], ['⊢', 0.9], ['⊣', 0.9],
      ['↷', 0.8], ['↶', 0.8], ['◦', 0.9], ['|=', 0.9], ['◁', 0.6], ['⇄', 0.6],
      ['⊗', 0.9], ['÷', 0.7], ['⊘', 0.8], ['×', 0.8], ['¬', 0.8], ['†', 0.8],
      ['⊠', 0.8], ['/∈', 0.8], ['⊬', 0.8], ['⊩', 0.9], ['⊨', 0.9], ['?', 0.5],
      ['⚡', 0.7], ['⇒ Attention', 0.7], ['↶ Self-Reference', 0.7], ['∧', 0.6],
      ['↭', 0.6], ['▷◁', 0.6]
    ]);

    // ============================================
    // STATE
    // ============================================
    const state = {
      apiKey: '',
      isProcessing: false,
      sessionStats: {
        totalApiCalls: 0,
        totalCacheHits: 0,
        totalCostCents: 0,
      },
      hlsfReady: false,
    };

    state.hlsfReady = false;
    window.CognitionEngine.state = state;

    let currentAbortController = null;

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      log: document.getElementById('log'),
      input: document.getElementById('command-input'),
      sendBtn: document.getElementById('send-btn'),
      cancelBtn: document.getElementById('cancel-btn'),
      apiModal: document.getElementById('api-modal'),
      apiKeyInput: document.getElementById('api-key-input'),
      apiConfirmBtn: document.getElementById('api-confirm'),
      apiCancelBtn: document.getElementById('api-cancel'),
      cacheHitRate: document.getElementById('cache-hit-rate'),
      cachedTokens: document.getElementById('cached-tokens'),
      sessionCost: document.getElementById('session-cost'),
      dbFileInput: document.getElementById('db-file'),
    };

    // ============================================
    // UTILITIES
    // ============================================
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validatePrompt(prompt) {
      if (!prompt || typeof prompt !== 'string') {
        throw new Error('Invalid prompt: must be non-empty string');
      }
      if (prompt.length > 10000) {
        throw new Error('Prompt too long: max 10000 characters');
      }
      return prompt.trim();
    }

    function safeStorageGet(key, defaultValue = null) {
      try {
        const item = localStorage.getItem(key);
        if (item == null) return defaultValue;
        try {
          return JSON.parse(item);
        } catch {
          return item;
        }
      } catch (err) {
        console.warn(`Storage read failed for ${key}:`, err);
        return defaultValue;
      }
    }

    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        console.warn(`Storage write failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.warn(`Storage remove failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageKeys(prefix = '') {
      try {
        return Object.keys(localStorage).filter(k => k.startsWith(prefix));
      } catch (err) {
        console.warn('Storage keys enumeration failed:', err);
        return [];
      }
    }

    function tokenize(text) {
      if (!text) return [];
      return text.trim()
        .split(/[^\p{L}\p{N}\-']+/u)
        .filter(Boolean)
        .map(t => t.toLowerCase());
    }

    function formatCurrency(cents) {
      return `$${(cents / 100).toFixed(2)}`;
    }

    function getCachedTokenCount() {
      return safeStorageKeys(TOKEN_CACHE_PREFIX).length;
    }

    // ============================================
    // COMPLEX NUMBER ENCODING & GLYPH SYSTEM
    // ============================================
    
    // Convert token to complex number representation
    // Magnitude = attention score, Phase = semantic hash
    function tokenToComplexNumber(token, tokenData) {
      const attentionScore = tokenData?.attention_score || 0.5;
      const magnitude = attentionScore; // 0.0 to 1.0
      
      // Generate phase from token's semantic properties
      let phaseHash = 0;
      for (let i = 0; i < token.length; i++) {
        phaseHash = ((phaseHash << 5) - phaseHash) + token.charCodeAt(i);
        phaseHash = phaseHash & phaseHash;
      }
      
      // Normalize phase to 0-2π
      const phase = (Math.abs(phaseHash) % 360) * (Math.PI / 180);
      
      // Calculate real and imaginary parts
      const real = magnitude * Math.cos(phase);
      const imaginary = magnitude * Math.sin(phase);
      
      return { real, imaginary, magnitude, phase };
    }

    const memoizedComplexNumber = (() => {
      const cache = new Map();
      return (token, tokenData) => {
        const score = tokenData?.attention_score ?? 0;
        const key = `${token}_${score}`;
        if (cache.has(key)) return cache.get(key);
        const result = tokenToComplexNumber(token, tokenData);
        cache.set(key, result);
        return result;
      };
    })();

    // Map complex number to glyph from library
    function complexToGlyph(complex) {
      // Use magnitude and phase to select glyph
      const magnitudeIndex = Math.floor(complex.magnitude * 7); // 0-7 range
      const phaseIndex = Math.floor((complex.phase / (2 * Math.PI)) * 10); // 0-9 range
      const glyphIndex = (magnitudeIndex * 10 + phaseIndex) % GLYPH_LIBRARY.length;
      return GLYPH_LIBRARY[glyphIndex];
    }

    // Generate glyph ledger for all cached tokens
    function generateGlyphLedger() {
      const ledger = new Map();
      const reverseMap = new Map(); // glyph -> tokens
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);

      for (const key of keys) {
        try {
          const tokenData = safeStorageGet(key);
          if (!tokenData?.token) continue;
          const token = tokenData.token;
          const complex = memoizedComplexNumber(token, tokenData);
          const glyph = complexToGlyph(complex);

          ledger.set(token, {
            glyph,
            complex: {
              real: complex.real.toFixed(4),
              imaginary: complex.imaginary.toFixed(4),
              magnitude: complex.magnitude.toFixed(4),
              phase: complex.phase.toFixed(4)
            },
            attention_score: tokenData.attention_score || 0
          });
          
          // Track consolidation - multiple tokens per glyph
          if (!reverseMap.has(glyph)) {
            reverseMap.set(glyph, []);
          }
          reverseMap.get(glyph).push(token);
        } catch (err) {
          console.error('Failed to process token:', key, err);
        }
      }
      
      return { ledger, reverseMap };
    }

    // Consolidate similar tokens to same glyph
    function findConsolidatedTokens(reverseMap) {
      const consolidated = [];
      for (const [glyph, tokens] of reverseMap.entries()) {
        if (tokens.length > 1) {
          consolidated.push({ glyph, tokens, count: tokens.length });
        }
      }
      return consolidated.sort((a, b) => b.count - a.count);
    }

    // Encode message using glyph ledger
    function encodeMessage(message, ledger) {
      const tokens = tokenize(message);
      const encoded = [];
      const unknown = [];
      
      for (const token of tokens) {
        const entry = ledger.get(token);
        if (entry) {
          encoded.push(entry.glyph);
        } else {
          encoded.push('◌'); // Unknown token marker
          unknown.push(token);
        }
      }
      
      return {
        encoded: encoded.join(''),
        coverage: ((tokens.length - unknown.length) / tokens.length * 100).toFixed(1),
        unknown
      };
    }

    // Decode message using reverse glyph map
    function decodeMessage(encoded, reverseMap) {
      const glyphs = Array.from(encoded);
      const decoded = [];
      
      for (const glyph of glyphs) {
        const tokens = reverseMap.get(glyph);
        if (tokens && tokens.length > 0) {
          // Use first token (could use most common or context-aware selection)
          decoded.push(tokens[0]);
        } else {
          decoded.push('[?]');
        }
      }
      
      return decoded.join(' ');
    }

    // Export glyph ledger for inter-system transmission
    function exportGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        ledger_version: "1.0",
        description: "HLSF Symbolic Glyph Encryption Ledger - Complex Number Token Encoding",
        specification: {
          encoding: "Complex numbers (magnitude=attention, phase=semantic_hash)",
          glyph_library_size: GLYPH_LIBRARY.length,
          representation: "Unicode symbolic glyphs",
          consolidation: "Similar tokens map to same glyph based on complex number proximity"
        },
        statistics: {
          total_tokens: ledger.size,
          unique_glyphs: reverseMap.size,
          consolidation_ratio: (ledger.size / reverseMap.size).toFixed(2),
          consolidated_groups: consolidated.length
        },
        glyph_ledger: Object.fromEntries(ledger),
        reverse_mapping: Object.fromEntries(
          Array.from(reverseMap.entries()).map(([glyph, tokens]) => [glyph, tokens])
        ),
        consolidated_tokens: consolidated,
        encryption_examples: generateEncryptionExamples(ledger, reverseMap)
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Glyph_Ledger_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return exportData;
    }

    window.GlyphSystem.ledger = null;
    window.GlyphSystem.encode = function encode(message) {
      const { ledger } = generateGlyphLedger();
      window.GlyphSystem.ledger = ledger;
      return encodeMessage(message, ledger);
    };
    window.GlyphSystem.decode = function decode(encoded) {
      const { reverseMap } = generateGlyphLedger();
      return decodeMessage(encoded, reverseMap);
    };
    window.GlyphSystem.export = exportGlyphLedger;

    function generateEncryptionExamples(ledger, reverseMap) {
      const examples = [
        "hello world",
        "consciousness",
        "quantum entanglement"
      ];
      
      return examples.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          plaintext: msg,
          encoded: result.encoded,
          coverage: result.coverage + '%',
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
    }

    function showGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      // Show sample encoded messages
      const sampleMessages = [
        "What is consciousness?",
        "Explain quantum mechanics",
        "The nature of reality"
      ];
      
      const encodedSamples = sampleMessages.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          original: msg,
          encoded: result.encoded,
          coverage: result.coverage,
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">🔐 Symbolic Glyph Encryption Ledger</div>
        
        <div class="adjacency-insight">
          <strong>📐 Complex Number Encoding:</strong><br>
          • Each token → Complex number (magnitude + phase)<br>
          • Magnitude = Attention score (0.0-1.0)<br>
          • Phase = Semantic hash (0-2π radians)<br>
          • Glyph = Visual representation of complex coordinates
        </div>

        <div class="adjacency-insight">
          <strong>📊 Ledger Statistics:</strong><br>
          • Total tokens: <strong>${ledger.size}</strong><br>
          • Unique glyphs: <strong>${reverseMap.size}</strong><br>
          • Consolidation ratio: <strong>${(ledger.size / reverseMap.size).toFixed(2)}:1</strong><br>
          • Efficiency gain: <strong>${(100 - (reverseMap.size / ledger.size * 100)).toFixed(1)}%</strong>
        </div>

        <div class="adjacency-insight">
          <strong>🔄 Token Consolidation (Similar tokens → Same glyph):</strong><br>
          ${consolidated.slice(0, 5).map(c => 
            `• <span style="font-size: 1.5em;">${c.glyph}</span> → ${c.tokens.slice(0, 3).join(', ')}${c.tokens.length > 3 ? '...' : ''} (${c.count} tokens)`
          ).join('<br>')}
          ${consolidated.length === 0 ? '<em>No consolidation yet - need more diverse tokens</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔐 Encrypted Message Examples:</strong><br>
          ${encodedSamples.map(s => `
            <div style="margin: 0.75rem 0; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <div style="opacity: 0.7; font-size: 0.85em;">Original:</div>
              <div style="margin: 0.25rem 0;">${s.original}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Encrypted (${s.coverage}% coverage):</div>
              <div style="font-size: 1.3em; letter-spacing: 0.1em; color: var(--accent); margin: 0.25rem 0;">${s.encoded}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Decoded:</div>
              <div style="margin: 0.25rem 0;">${s.decoded}</div>
            </div>
          `).join('')}
        </div>

        <details>
          <summary>📖 View full glyph mapping (first 20 tokens)</summary>
          <pre>${JSON.stringify(
            Object.fromEntries(Array.from(ledger.entries()).slice(0, 20)),
            null, 2
          )}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Usage:</strong> This ledger enables secure inter-system communication. 
          Messages encoded with glyphs can be transmitted efficiently and decoded by any system 
          with the same ledger. The consolidation reduces message size while maintaining semantic meaning.
        </div>
      `);
    }

    // ============================================
    // LOGGING
    // ============================================
    function batchLogUpdates(entries) {
      const fragment = document.createDocumentFragment();
      entries.forEach(entry => fragment.appendChild(entry));
      elements.log.appendChild(fragment);
      elements.log.scrollTop = elements.log.scrollHeight;
    }

    function addLog(content, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>${content}`;
      batchLogUpdates([entry]);
      return entry;
    }

    function logStatus(msg) { return addLog(`<div class="processing-indicator"><span class="spinner"></span>${msg}</div>`, 'status'); }
    function logError(msg) { return addLog(`🔴 ${sanitize(msg)}`, 'error'); }
    function logSuccess(msg) { return addLog(`✅ ${sanitize(msg)}`, 'success'); }
    function logWarning(msg) { return addLog(`⚠️ ${sanitize(msg)}`, 'warning'); }

    function debounce(fn, delay) {
      let timeout;
      return function debounced(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    async function safeAsync(fn, errorMsg) {
      try {
        return await fn();
      } catch (err) {
        logError(`${errorMsg}: ${err.message}`);
        console.error(errorMsg, err);
        return null;
      }
    }

    // ============================================
    // STATS
    // ============================================
    function updateStats() {
      const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
      const total = totalApiCalls + totalCacheHits;
      const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) + '%' : '—';

      const cachedCount = getCachedTokenCount();

      elements.cacheHitRate.textContent = hitRate;
      elements.cachedTokens.textContent = cachedCount;
      elements.sessionCost.textContent = formatCurrency(totalCostCents);

      // Visual feedback for database growth
      if (cachedCount > 0) {
        elements.cachedTokens.style.color = cachedCount > 50 ? '#00ff88' : '#ffd54f';
      }
    }

    function updateHeaderCounts() {
      updateStats();
    }

    // ============================================
    // CACHE
    // ============================================
    function getCacheKey(token) {
      const normalized = token == null ? '' : String(token);
      return `${TOKEN_CACHE_PREFIX}${normalized.toLowerCase()}`;
    }

    function updateTokenIndex(token) {
      if (!token) return;

      let index = safeStorageGet(DB_INDEX_KEY, []);
      if (!Array.isArray(index)) index = [];
      if (!index.includes(token)) {
        index.push(token);
        safeStorageSet(DB_INDEX_KEY, JSON.stringify(index));
      }
    }

    function getFromCache(token) {
      try {
        const raw = safeStorageGet(getCacheKey(token));
        if (!raw) return null;
        state.sessionStats.totalCacheHits++;
        updateStats();
        return raw;
      } catch { return null; }
    }

    function saveToCache(token, data) {
      try {
        const payload = JSON.stringify({
          ...data,
          cached_at: new Date().toISOString()
        });
        const ok = safeStorageSet(getCacheKey(token), payload);
        if (!ok) return;
        updateTokenIndex(token);
      } catch (err) {
        if (err.name === 'QuotaExceededError') {
          logWarning('Cache full. Use /reset to clear old data.');
        }
      }
    }

    window.CognitionEngine.cache = {
      get: getFromCache,
      set: saveToCache,
      key: getCacheKey,
    };

    // ============================================
    // OPENAI API
    // ============================================
    async function callOpenAI(messages, options = {}) {
      if (!state.apiKey) throw new Error('No API key configured');

      const body = {
        model: options.model || CONFIG.DEFAULT_MODEL,
        messages,
        max_tokens: options.max_tokens || 1000,
        temperature: options.temperature || 0.7,
      };

      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
        if (currentAbortController?.signal.aborted) {
          const error = new Error('Cancelled');
          error.name = 'AbortError';
          throw error;
        }

        attempt++;
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.apiKey}`,
            },
            body: JSON.stringify(body),
          });

          if (response.status === 429 && attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
            await new Promise(r => setTimeout(r, CONFIG.RETRY_BASE_DELAY_MS * Math.pow(2, attempt - 1)));
            continue;
          }

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `API error (${response.status})`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error?.message) errorMessage = errorData.error.message;
            } catch (e) {
              if (errorText) errorMessage = errorText;
            }
            
            if (response.status === 401) errorMessage = 'Invalid API key';
            else if (response.status === 403) errorMessage = 'Access forbidden - check billing setup';
            else if (response.status === 429) errorMessage = 'Rate limit exceeded';
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          state.sessionStats.totalApiCalls++;
          state.sessionStats.totalCostCents += Math.ceil(CONFIG.ESTIMATED_COST_PER_API_CALL * 100);
          updateStats();

          return data.choices?.[0]?.message?.content?.trim() || '';
        } catch (err) {
          if (err.name === 'AbortError') throw err;
          if (err.message === 'Failed to fetch') {
            throw new Error('Network error - check connection or download HTML to run locally');
          }
          if (attempt === CONFIG.MAX_RETRY_ATTEMPTS) throw err;
        }
      }
    }

    window.CognitionEngine.api = {
      callOpenAI,
    };

    // ============================================
    // ADJACENCY
    // ============================================
    class ProgressTracker {
      constructor(total, label) {
        this.total = total;
        this.current = 0;
        this.label = label;
        this.element = logStatus(`⏳ ${label} (0/${total})`);
      }

      increment(count = 1) {
        this.current += count;
        const percent = this.total === 0 ? 100 : Math.round((this.current / this.total) * 100);
        if (this.element) {
          this.element.innerHTML = `⏳ ${this.label} (${this.current}/${this.total}) - ${percent}%`;
        }
      }

      complete(message) {
        if (this.element) {
          this.element.innerHTML = `✅ ${message || `${this.label} complete`}`;
        }
      }
    }

    async function fetchAdjacency(token, context) {
      if (currentAbortController?.signal.aborted) {
        throw new Error('AbortError');
      }

      const cached = getFromCache(token);
      if (cached) return { ...cached, cache_hit: true };

      if (!state.apiKey) return { token, relationships: {}, offline: true };

      const prompt = `Token: "${token}"
Context: "${context}"

For this token, identify the most relevant adjacent tokens across relationship types. For each that applies, provide related tokens with weights 0.01-1.00.

Relationship types: ≡ Identity, ⊃ Contains, ⊂ Is Contained By, ≈ Variant, ∈ Is Instance Of, ∋ Has Instance, ⊤ Is Type Of, ⊥ Has Type, ⊏ Part Of, ⊐ Composes, ↔ Mirrors, ⇌ Inverts, ∥ Parallel To, ∼ Adjacent To, → Next, ⇒ Sequence Of, ⇐ Preceded By, ↠ Follows, ↗ Spatially Above, ↘ Spatially Below, ⇝ Symbolically Supports, ⇂ Symbolically Depends, ≠ Contrasts, ⊕ Complements, ⊛ Associated With, ∝ Correlates With, ⇝ Causes, ⇐ Caused By, ∗ Evokes, ≜ Represents, ⋆ Symbolizes, 7→ Refers To, ⊢ Defines, ⊣ Is Defined By, ↷ Transforms To, ↶ Transformed From, ◦ Functions As, |= Interpreted As, ◁ Used With, ⇄ Co-occurs With, ⊗ Synthesizes, ÷ Divides Into, ⊘ Opposes, × Rejects, ¬ Negates, † Destroys, ⊠ Blocks, /∈ Invalidates, ⊬ Contradicts, ⊩ Asserts, ⊨ Provides Evidence, ? Uncertainty, ⚡ Memory, ⇒ Attention, ↶ Self-Reference, ∧ Perspective, ↭ Continuity, ▷◁ Relationality

Return JSON: {"token": "${token}", "relationships": {"≡": [{"token": "...", "weight": 0.95}], ...}}`;

      let safePrompt;
      try {
        safePrompt = validatePrompt(prompt);
      } catch (err) {
        logError(`Prompt validation failed for ${token}: ${err.message}`);
        return { token, relationships: {}, error: 'invalid_prompt' };
      }

      const content = await safeAsync(
        () => callOpenAI([
          { role: 'system', content: 'You are an HLSF token adjacency analyzer.' },
          { role: 'user', content: safePrompt },
        ]),
        `Adjacency fetch failed for ${token}`
      );

      if (!content) {
        return { token, relationships: {}, error: 'request_failed' };
      }

      try {
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const parsed = JSON.parse(content.slice(jsonStart, jsonEnd + 1));
        saveToCache(token, parsed);
        return { ...parsed, cache_hit: false };
      } catch {
        return { token, relationships: {}, error: 'Parse failed' };
      }
    }

    async function batchFetchAdjacencies(tokens, context, label) {
      const results = new Map();
      const unique = [...new Set(tokens)];

      const progress = new ProgressTracker(unique.length, label);

      let processed = 0;
      for (let i = 0; i < unique.length; i += CONFIG.MAX_CONCURRENCY) {
        if (currentAbortController?.signal.aborted) {
          progress.complete(`${label} cancelled (${processed}/${unique.length})`);
          break;
        }

        const batch = unique.slice(i, i + CONFIG.MAX_CONCURRENCY);
        const settled = await Promise.allSettled(batch.map(t => fetchAdjacency(t, context)));
        
        settled.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            results.set(batch[idx], result.value);
          }
        });

        processed += batch.length;
        progress.increment(batch.length);
      }

      const hits = Array.from(results.values()).filter(r => r.cache_hit).length;
      progress.complete(`${label}: ${hits} cached, ${results.size - hits} new`);
      return results;
    }

    window.CognitionEngine.processing = {
      fetchAdjacency,
      batchFetchAdjacencies,
    };

    function calculateAttention(matrices) {
      for (const entry of matrices.values()) {
        let weightSum = 0, totalEdges = 0;
        const rels = entry?.relationships || {};
        
        for (const [rel, edges] of Object.entries(rels)) {
          const priority = RELATIONSHIP_PRIORITIES.get(rel) || 0.3;
          if (Array.isArray(edges)) {
            edges.forEach(edge => {
              weightSum += (edge.weight || 0) * priority;
              totalEdges++;
            });
          }
        }
        
        entry.attention_score = totalEdges > 0 ? Number((weightSum / totalEdges).toFixed(3)) : 0;
        entry.total_relationships = totalEdges;
      }
      return matrices;
    }

    function summarizeAttention(matrices) {
      const summary = [];
      for (const [token, data] of matrices.entries()) {
        summary.push({ 
          token, 
          attention: data.attention_score || 0, 
          total: data.total_relationships || 0 
        });
      }
      return summary.sort((a, b) => b.attention - a.attention).slice(0, 10);
    }

    function formatTopTokens(topTokens) {
      const { ledger } = generateGlyphLedger();
      return topTokens.map(t => {
        const glyphEntry = ledger.get(t.token);
        const glyph = glyphEntry ? glyphEntry.glyph : '◌';
        return `<span class="token-highlight">${glyph} ${t.token}</span> (${t.attention.toFixed(2)})`;
      }).join(', ');
    }

    function extractKeyRelationships(matrices) {
      const relationships = [];
      let count = 0;
      for (const [token, data] of matrices.entries()) {
        if (count >= 5) break;
        const rels = data?.relationships || {};
        for (const [rel, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges) || edges.length === 0) continue;
          const topEdge = edges.sort((a, b) => b.weight - a.weight)[0];
          relationships.push(`${token} ${rel} ${topEdge.token} (${topEdge.weight.toFixed(2)})`);
          count++;
          if (count >= 5) break;
        }
      }
      return relationships;
    }

    // ============================================
    // HLSF VISUALIZATION
    // ============================================

    function polygonVertices(center, radius, sides) {
      const vertices = [];
      const angleStep = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep - Math.PI / 2;
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return vertices;
    }

    function deriveAdjacencyPolygon(center, baseRadius, relationships) {
      const entries = Object.entries(relationships || {})
        .filter(([, edges]) => Array.isArray(edges) && edges.length > 0)
        .map(([relType, edges]) => {
          const weightSum = edges.reduce((sum, edge) => {
            const weight = typeof edge.weight === 'number' ? edge.weight : 0;
            return sum + weight;
          }, 0);
          const avgWeight = edges.length > 0 ? weightSum / edges.length : 0;
          return {
            relType,
            count: edges.length,
            avgWeight
          };
        })
        .sort((a, b) => a.relType.localeCompare(b.relType));

      if (entries.length === 0) {
        return {
          vertices: polygonVertices(center, baseRadius * 0.8, 3),
          anchorIndex: 0,
          adjacencyTypes: 0
        };
      }

      const vertexCount = Math.max(entries.length + 1, 3);
      const baseAngle = -Math.PI / 2;
      const angleStep = (2 * Math.PI) / vertexCount;
      const maxCount = Math.max(...entries.map(entry => entry.count));

      const vertices = [];
      const anchor = [center[0], center[1] - baseRadius];
      vertices.push(anchor);

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const normalizedWeight = Math.min(1, Math.max(0, entry.avgWeight));
        const countFactor = maxCount > 0 ? entry.count / maxCount : 0;
        const radialFactor = 0.85 + normalizedWeight * 0.35 + countFactor * 0.25;
        const radius = baseRadius * radialFactor;
        const angle = baseAngle + angleStep * (i + 1);
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }

      let fillerIndex = entries.length;
      while (vertices.length < 3) {
        const angle = baseAngle + angleStep * (fillerIndex + 1);
        vertices.push([
          center[0] + baseRadius * 0.75 * Math.cos(angle),
          center[1] + baseRadius * 0.75 * Math.sin(angle)
        ]);
        fillerIndex++;
      }

      return {
        vertices,
        anchorIndex: 0,
        adjacencyTypes: entries.length
      };
    }

    function buildBaseTriangles(vertices, sides) {
      if (sides < 3) return [];
      const triangles = [];
      const center = vertices.reduce((acc, v) =>
        [acc[0] + v[0] / sides, acc[1] + v[1] / sides], [0, 0]);

      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        triangles.push([center, vertices[i], vertices[next]]);
      }
      return triangles;
    }

    function rotateTrianglesAround(triangles, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return triangles.map(tri => tri.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      }));
    }

    function rotatePointsAround(points, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      });
    }

    window.HLSF.geometry = {
      polygonVertices,
      buildBaseTriangles,
      rotateTrianglesAround,
      rotatePointsAround,
      deriveAdjacencyPolygon,
    };

    let hlsfNodes = [];

    function buildHLSFNodes() {
      const graph = window.HLSF_GRAPH;
      let tokenRecords = [];

      if (graph?.tokens instanceof Map) {
        tokenRecords = Array.from(graph.tokens.values());
      } else if (graph?.tokens && typeof graph.tokens === 'object') {
        tokenRecords = Object.values(graph.tokens);
      }

      let sourceLabel = '';

      if (tokenRecords.length === 0) {
        const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
        console.log(`Scanning ${keys.length} cached tokens from storage for HLSF build`);

        for (const key of keys) {
          try {
            const tokenData = safeStorageGet(key);
            if (!tokenData?.token) {
              console.warn('Token missing from data:', key);
              continue;
            }
            tokenRecords.push(tokenData);
          } catch (err) {
            console.error('Failed to process token:', key, err);
          }
        }

        if (graph) {
          graph.tokens = new Map(tokenRecords.map(record => [record.token, record]));
        }

        sourceLabel = '(storage scan)';
      } else {
        sourceLabel = '(graph cache)';
      }

      console.log(`Building HLSF nodes from ${tokenRecords.length} cached tokens ${sourceLabel}`.trim());

      const nodes = [];

      for (const tokenData of tokenRecords) {
        try {
          const token = tokenData.token;

          if (!token) {
            console.warn('Token missing from data:', tokenData);
            continue;
          }

          const rels = tokenData.relationships || {};

          // Count adjacencies
          let adjacencyCount = 0;
          for (const edges of Object.values(rels)) {
            if (Array.isArray(edges)) adjacencyCount += edges.length;
          }
          const adjacencyTypes = Object.values(rels)
            .filter(edges => Array.isArray(edges) && edges.length > 0)
            .length;

          const attention = typeof tokenData.attention_score === 'number'
            ? tokenData.attention_score
            : 0.5;
          const complex = memoizedComplexNumber(token, { ...tokenData, attention_score: attention });
          const glyph = complexToGlyph(complex);

          // Position based on complex number
          const x = complex.real * 2;
          const y = complex.imaginary * 2;

          // Radius based on attention
          const radius = 0.3 + attention * 0.4;

          // Build polygon derived from adjacency structure
          const shape = deriveAdjacencyPolygon([x, y], radius, rels);
          const sides = shape.vertices.length;

          // Color based on attention
          let color;
          if (attention >= 0.8) color = [0, 255, 136];
          else if (attention >= 0.5) color = [255, 213, 79];
          else color = [255, 119, 119];

          nodes.push({
            token,
            glyph,
            center: [x, y],
            radius,
            sides,
            attention,
            adjacencyCount,
            adjacencyTypes,
            anchorIndex: shape.anchorIndex,
            color,
            vertices: shape.vertices,
            triangles: null, // Will be computed
            localRotation: 0,
            rotationSpeed: attention * 0.02
          });
        } catch (err) {
          console.error('Failed to process token for HLSF:', tokenData, err);
        }
      }

      console.log(`Built ${nodes.length} HLSF nodes`);
      
      // Generate triangles for each node
      for (const node of nodes) {
        try {
          node.triangles = buildBaseTriangles(node.vertices, node.sides);
        } catch (err) {
          console.error(`Failed to build triangles for ${node.token}:`, err);
          node.triangles = [];
        }
      }
      
      return nodes;
    }

    function initHLSFCanvas() {
      console.log('Initializing HLSF Canvas...');
      
      try {
        // Build nodes first to check if we have data
        hlsfNodes = buildHLSFNodes();
        
        if (hlsfNodes.length === 0) {
          logWarning('No cached tokens found for HLSF. Process some queries first to populate the database.');
          return;
        }
        
        console.log(`Creating canvas UI for ${hlsfNodes.length} nodes`);
        
        const container = document.createElement('div');
        container.className = 'hlsf-canvas-container';
      container.innerHTML = `
        <div style="margin-bottom: 1rem;">
          <div class="section-title">🌌 HLSF: Hierarchical-Level Semantic Framework</div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">
            Geometric token visualization. Each polygon fans outward from a primary corner based on
            adjacency types, forming unique base-level shapes per matrix. Triangular subdivisions show
            hierarchical structure.
          </div>
        </div>
        <canvas id="hlsf-canvas" width="1200" height="600"></canvas>
        <div class="hlsf-controls">
          <div class="hlsf-control-group">
            <label>Rotation Speed</label>
            <input type="range" id="hlsf-rotation-speed" min="0" max="5" step="0.1" value="0.5">
            <span id="hlsf-speed-val">0.5</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>Alpha Transparency</label>
            <input type="range" id="hlsf-alpha" min="0.1" max="1" step="0.05" value="0.3">
            <span id="hlsf-alpha-val">0.3</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>View Controls</label>
            <div class="hlsf-button-row">
              <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
              <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
              <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Rotation Modes</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-rotation" class="btn btn-primary">Start Global</button>
              <button id="hlsf-toggle-emergent" class="btn btn-success">Start Emergent</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Display Options</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-edges" class="btn btn-neutral">Edges: On</button>
              <button id="hlsf-toggle-labels" class="btn btn-neutral">Labels: On</button>
              <button id="hlsf-toggle-bg" class="btn btn-neutral">BG: Dark</button>
            </div>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.85rem;">
          <strong>Controls:</strong> Drag to pan • Scroll to zoom • Each polygon = token matrix •
          Fan vertices = adjacency types • Color = attention score<br>
          <strong>Modes:</strong> Global rotation = all polygons rotate around center • 
          Emergent rotation = each polygon rotates around its own center
        </div>
      `;
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
      entry.appendChild(container);
      elements.log.appendChild(entry);
      elements.log.scrollTop = elements.log.scrollHeight;
      
      // Initialize canvas
      window.HLSF.canvas = document.getElementById('hlsf-canvas');
      window.HLSF.ctx = window.HLSF.canvas.getContext('2d');
      
      console.log('Canvas initialized:', window.HLSF.canvas ? 'success' : 'failed');
      
      // Setup controls
      const speedSlider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      speedSlider.addEventListener('input', (e) => {
        window.HLSF.config.rotationSpeed = parseFloat(e.target.value);
        speedVal.textContent = window.HLSF.config.rotationSpeed.toFixed(1);
        debouncedRender();
      });

      const alphaSlider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      alphaSlider.addEventListener('input', (e) => {
        window.HLSF.config.alpha = parseFloat(e.target.value);
        alphaVal.textContent = window.HLSF.config.alpha.toFixed(2);
        debouncedRender();
      });
      
      document.getElementById('hlsf-zoom-in').addEventListener('click', () => {
        window.HLSF.config.scale *= 1.2;
        debouncedRender();
      });

      document.getElementById('hlsf-zoom-out').addEventListener('click', () => {
        window.HLSF.config.scale *= 0.8;
        debouncedRender();
      });

      document.getElementById('hlsf-reset-view').addEventListener('click', () => {
        window.HLSF.config.scale = 1;
        window.HLSF.config.tx = window.HLSF.canvas.width / 2;
        window.HLSF.config.ty = window.HLSF.canvas.height / 2;
        debouncedRender();
      });
      
      const rotationBtn = document.getElementById('hlsf-toggle-rotation');
      rotationBtn.addEventListener('click', () => {
        window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
        window.HLSF.config.emergentActive = false;
        rotationBtn.textContent = window.HLSF.config.rotationActive ? 'Stop Global' : 'Start Global';
        document.getElementById('hlsf-toggle-emergent').textContent = 'Start Emergent';
      });
      
      const emergentBtn = document.getElementById('hlsf-toggle-emergent');
      emergentBtn.addEventListener('click', () => {
        window.HLSF.config.emergentActive = !window.HLSF.config.emergentActive;
        window.HLSF.config.rotationActive = false;
        emergentBtn.textContent = window.HLSF.config.emergentActive ? 'Stop Emergent' : 'Start Emergent';
        document.getElementById('hlsf-toggle-rotation').textContent = 'Start Global';
      });
      
      const edgesBtn = document.getElementById('hlsf-toggle-edges');
      edgesBtn.addEventListener('click', () => {
        window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
        edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
        debouncedRender();
      });

      const labelsBtn = document.getElementById('hlsf-toggle-labels');
      labelsBtn.addEventListener('click', () => {
        window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
        labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
        debouncedRender();
      });

      const bgBtn = document.getElementById('hlsf-toggle-bg');
      bgBtn.addEventListener('click', () => {
        window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
        bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
        debouncedRender();
      });
      
      // Mouse interaction
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      
      window.HLSF.canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      window.HLSF.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.config.tx += dx;
          window.HLSF.config.ty += dy;
          lastX = e.clientX;
          lastY = e.clientY;
          debouncedRender();
        }
      });
      
      window.HLSF.canvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        window.HLSF.config.scale *= factor;
        debouncedRender();
      }, { passive: false });
      
      // Center view
      window.HLSF.config.tx = window.HLSF.canvas.width / 2;
      window.HLSF.config.ty = window.HLSF.canvas.height / 2;
      
      // Build nodes
      window.HLSF.nodes = hlsfNodes;
      
      // Initial render
      renderHLSF();
      
      // Start animation
      animateHLSF();
      
      logSuccess(`HLSF visualization initialized with ${hlsfNodes.length} token matrices`);
      
      } catch (err) {
        logError(`Failed to initialize HLSF canvas: ${err.message}`);
        console.error('HLSF canvas error:', err);
        throw err;
      }
    }

    function worldToScreen(x, y) {
      const sx = x * (200 * window.HLSF.config.scale) + window.HLSF.config.tx;
      const sy = -y * (200 * window.HLSF.config.scale) + window.HLSF.config.ty;
      return [sx, sy];
    }

    function drawTriangle(tri, fillColor, strokeColor) {
      const ctx = window.HLSF.ctx;
      const p0 = worldToScreen(tri[0][0], tri[0][1]);
      const p1 = worldToScreen(tri[1][0], tri[1][1]);
      const p2 = worldToScreen(tri[2][0], tri[2][1]);
      
      ctx.beginPath();
      ctx.moveTo(p0[0], p0[1]);
      ctx.lineTo(p1[0], p1[1]);
      ctx.lineTo(p2[0], p2[1]);
      ctx.closePath();
      
      if (fillColor) {
        ctx.fillStyle = fillColor;
        ctx.fill();
      }
      
      if (strokeColor && window.HLSF.config.showEdges) {
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function renderHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not initialized for renderHLSF');
        return;
      }
      
      try {
        const ctx = window.HLSF.ctx;
        const width = window.HLSF.canvas.width;
        const height = window.HLSF.canvas.height;
      
      // Clear canvas
      ctx.fillStyle = window.HLSF.config.whiteBg ? '#ffffff' : '#0a0a0a';
      ctx.fillRect(0, 0, width, height);
      
      // Draw grid
      ctx.strokeStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.05)' : 'rgba(0, 255, 136, 0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Draw each node's triangles
      for (const node of window.HLSF.nodes) {
        const [r, g, b] = node.color;
        const fillColor = `rgba(${r}, ${g}, ${b}, ${window.HLSF.config.alpha})`;
        const strokeColor = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';

        let triangles = node.triangles;
        let vertices = node.vertices;

        // Apply rotation if active
        if (window.HLSF.config.emergentActive) {
          triangles = rotateTrianglesAround(node.triangles, node.center, node.localRotation);
          vertices = rotatePointsAround(node.vertices, node.center, node.localRotation);
        } else if (window.HLSF.config.rotationActive) {
          triangles = rotateTrianglesAround(node.triangles, [0, 0], window.HLSF.config.globalRotation);
          vertices = rotatePointsAround(node.vertices, [0, 0], window.HLSF.config.globalRotation);
        }

        for (const tri of triangles) {
          drawTriangle(tri, fillColor, strokeColor);
        }

        if (window.HLSF.config.showEdges && vertices.length > 1) {
          const anchorIndex = typeof node.anchorIndex === 'number' ? node.anchorIndex : 0;
          const anchor = vertices[anchorIndex];
          const [ax, ay] = worldToScreen(anchor[0], anchor[1]);
          ctx.strokeStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.35)';
          ctx.lineWidth = 1.2;
          for (let i = 0; i < vertices.length; i++) {
            if (i === anchorIndex) continue;
            const [vx, vy] = worldToScreen(vertices[i][0], vertices[i][1]);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(vx, vy);
            ctx.stroke();
          }
        }

        // Draw glyph and label
        if (window.HLSF.config.showLabels) {
          const [sx, sy] = worldToScreen(node.center[0], node.center[1]);

          // Draw glyph
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
          ctx.font = `${Math.max(12, 20 * window.HLSF.config.scale)}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.glyph, sx, sy);

          // Draw token name
          ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
          ctx.font = `${Math.max(9, 11 * window.HLSF.config.scale)}px Fira Code, monospace`;
          ctx.fillText(node.token, sx, sy + 25 * window.HLSF.config.scale);
        }
      }
      
      // Draw stats
      ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
      ctx.font = '12px Fira Code, monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`Nodes: ${window.HLSF.nodes.length} | Zoom: ${window.HLSF.config.scale.toFixed(2)}x`, 10, 20);
      
      } catch (err) {
        console.error('Error rendering HLSF:', err);
      }
    }

    const debouncedRender = debounce(() => renderHLSF(), 16);

    function animateHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not ready for animation');
        return;
      }
      
      try {
        if (window.HLSF.config.rotationActive) {
          window.HLSF.config.globalRotation += window.HLSF.config.rotationSpeed * 0.01;
        } else if (window.HLSF.config.emergentActive) {
          for (const node of window.HLSF.nodes) {
            node.localRotation += node.rotationSpeed;
          }
        }
        
        if (window.HLSF.config.rotationActive || window.HLSF.config.emergentActive) {
          renderHLSF();
        }
      } catch (err) {
        console.error('Error in HLSF animation:', err);
      }
      
      window.HLSF.animationFrame = requestAnimationFrame(animateHLSF);
    }

    function stopHLSFAnimation() {
      try {
        if (window.HLSF && window.HLSF.animationFrame) {
          cancelAnimationFrame(window.HLSF.animationFrame);
          window.HLSF.animationFrame = null;
        }
        if (window.HLSF && window.HLSF.config) {
          window.HLSF.config.rotationActive = false;
          window.HLSF.config.emergentActive = false;
        }
      } catch (err) {
        console.warn('Error stopping HLSF animation:', err);
      }
    }

    window.HLSF.rendering = {
      render: renderHLSF,
      animate: animateHLSF,
      stop: stopHLSFAnimation,
    };
    function analyzeDatabaseMetadata() {
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      const tokens = [];
      const relationshipCounts = new Map();
      const tokenFrequency = new Map();
      let totalRelationships = 0;
      let totalAttentionScore = 0;
      let oldestToken = null;
      let newestToken = null;

      for (const key of keys) {
        try {
          const data = safeStorageGet(key);
          tokens.push(data);

          // Track oldest and newest
          if (data.cached_at) {
            const timestamp = new Date(data.cached_at);
            if (!oldestToken || timestamp < new Date(oldestToken.cached_at)) {
              oldestToken = data;
            }
            if (!newestToken || timestamp > new Date(newestToken.cached_at)) {
              newestToken = data;
            }
          }

          // Count relationships
          const rels = data.relationships || {};
          for (const [relType, edges] of Object.entries(rels)) {
            if (!Array.isArray(edges)) continue;
            
            relationshipCounts.set(relType, (relationshipCounts.get(relType) || 0) + edges.length);
            totalRelationships += edges.length;

            // Track token frequency across relationships
            for (const edge of edges) {
              const token = edge.token?.toLowerCase();
              if (token) {
                tokenFrequency.set(token, (tokenFrequency.get(token) || 0) + 1);
              }
            }
          }

          if (data.attention_score) {
            totalAttentionScore += data.attention_score;
          }
        } catch (err) {
          console.error('Failed to parse token:', key, err);
        }
      }

      // Sort by frequency
      const topRelationships = Array.from(relationshipCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

      const topTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);

      const highAttentionTokens = tokens
        .filter(t => t.attention_score)
        .sort((a, b) => b.attention_score - a.attention_score)
        .slice(0, 10);

      return {
        totalTokens: tokens.length,
        totalRelationships,
        avgAttentionScore: tokens.length > 0 ? (totalAttentionScore / tokens.length).toFixed(3) : 0,
        topRelationships,
        topTokens,
        highAttentionTokens,
        oldestToken,
        newestToken,
        estimatedValue: tokens.length * CONFIG.ESTIMATED_COST_PER_API_CALL,
        rawData: tokens
      };
    }

    function showDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const maturityLevel = metadata.totalTokens > 100 ? 'Mature' : metadata.totalTokens > 20 ? 'Growing' : 'Early';
      const maturityColor = metadata.totalTokens > 100 ? 'var(--success)' : metadata.totalTokens > 20 ? 'var(--warning)' : 'var(--accent)';
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">📊 Collective Database Metadata</div>
        
        <div class="adjacency-insight">
          <strong>🌐 Knowledge Base Status:</strong> <span style="color: ${maturityColor}; font-weight: bold;">${maturityLevel}</span><br>
          <small style="opacity: 0.8;">
            ${metadata.totalTokens < 20 ? 
              'Building foundational knowledge. Each query adds to the collective intelligence.' :
              metadata.totalTokens < 100 ?
              'Database is maturing. Cache hit rate improving with each session.' :
              'Mature knowledge base. Most queries benefit from cached insights.'}
          </small>
        </div>

        <div class="adjacency-insight">
          <strong>💾 Database Size:</strong><br>
          • Total cached tokens: <strong>${metadata.totalTokens}</strong><br>
          • Total relationships: <strong>${metadata.totalRelationships}</strong><br>
          • Average attention score: <strong>${metadata.avgAttentionScore}</strong><br>
          • Network density: <strong>${(metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)}</strong> edges/token<br>
          • Estimated saved cost: <strong>${formatCurrency(Math.ceil(metadata.estimatedValue * 100))}</strong>
        </div>

        <div class="adjacency-insight">
          <strong>📈 Most Common Relationship Types:</strong><br>
          ${metadata.topRelationships.map(([rel, count]) => 
            `• <span class="token-highlight">${rel}</span>: ${count} instances`
          ).join('<br>')}
          ${metadata.topRelationships.length === 0 ? '<em>No relationships cached yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔥 Most Referenced Tokens (Hub Concepts):</strong><br>
          <small style="opacity: 0.8;">These tokens appear most frequently across relationships - they represent core concepts in the knowledge graph.</small><br><br>
          ${metadata.topTokens.slice(0, 10).map(([token, count]) => 
            `• <span class="token-highlight">${token}</span>: ${count} references`
          ).join('<br>')}
          ${metadata.topTokens.length === 0 ? '<em>No hub concepts identified yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>⭐ Highest Attention Tokens:</strong><br>
          <small style="opacity: 0.8;">Tokens with the strongest weighted relationships - highly salient concepts.</small><br><br>
          ${metadata.highAttentionTokens.map(t => 
            `• <span class="token-highlight">${t.token}</span>: ${t.attention_score} (${t.total_relationships || 0} edges)`
          ).join('<br>')}
          ${metadata.highAttentionTokens.length === 0 ? '<em>No high-attention tokens yet</em>' : ''}
        </div>

        ${metadata.oldestToken ? `
        <div class="adjacency-insight">
          <strong>📅 Database Timeline:</strong><br>
          • Oldest entry: <strong>${metadata.oldestToken.token}</strong> (${new Date(metadata.oldestToken.cached_at).toLocaleString()})<br>
          • Newest entry: <strong>${metadata.newestToken.token}</strong> (${new Date(metadata.newestToken.cached_at).toLocaleString()})
        </div>
        ` : ''}

        <details>
          <summary>📊 View knowledge graph analytics</summary>
          <pre>${JSON.stringify({
            database_maturity: maturityLevel,
            network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
            top_5_relationship_types: metadata.topRelationships.slice(0, 5).map(([rel]) => rel),
            top_5_hub_concepts: metadata.topTokens.slice(0, 5).map(([token]) => token),
            growth_metrics: {
              tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
              avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)
            }
          }, null, 2)}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Insight:</strong> This metadata represents the collective intelligence being built. 
          In a server deployment, this would be shared across all users, with each query contributing 
          to a growing knowledge base that makes future queries faster and cheaper. The database also 
          powers the symbolic glyph encryption system for secure inter-system communication.
        </div>
      `);
    }

    function exportDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        readme: {
          description: "HLSF Cognition Engine - Collective Database Metadata Export",
          purpose: "This export contains the complete adjacency token database and analytics. It represents the collective intelligence built through token relationship analysis.",
          usage: "This data can be imported into a server-side database to bootstrap a new deployment or shared for analysis.",
          version: "2.0"
        },
        database_stats: {
          total_tokens: metadata.totalTokens,
          total_relationships: metadata.totalRelationships,
          avg_attention_score: metadata.avgAttentionScore,
          estimated_value_usd: metadata.estimatedValue.toFixed(2),
          maturity_level: metadata.totalTokens > 100 ? 'mature' : metadata.totalTokens > 20 ? 'growing' : 'early'
        },
        relationship_distribution: Object.fromEntries(metadata.topRelationships),
        hub_concepts: Object.fromEntries(metadata.topTokens),
        high_attention_tokens: metadata.highAttentionTokens.map(t => ({
          token: t.token,
          attention_score: t.attention_score,
          total_relationships: t.total_relationships
        })),
        knowledge_graph_metrics: {
          network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(3),
          avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
          tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
          oldest_entry: metadata.oldestToken?.cached_at,
          newest_entry: metadata.newestToken?.cached_at,
          date_range_days: metadata.oldestToken && metadata.newestToken ? 
            Math.ceil((new Date(metadata.newestToken.cached_at) - new Date(metadata.oldestToken.cached_at)) / (1000 * 60 * 60 * 24)) : 0
        },
        full_token_data: metadata.rawData
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      logSuccess(`Database metadata exported: ${metadata.totalTokens} tokens, ${metadata.totalRelationships} relationships, ${(new Blob([JSON.stringify(exportData)]).size / 1024).toFixed(1)}KB`);
    }

    async function importHLSFDBFromFile(file) {
      const txt = await file.text();
      const db = JSON.parse(txt);
      safeStorageSet(DB_RAW_KEY, txt);

      const seen = [];
      for (const rec of db.full_token_data || []) {
        safeStorageSet(TOKEN_CACHE_PREFIX + rec.token, JSON.stringify(rec));
        seen.push(rec.token);
      }
      safeStorageSet(DB_INDEX_KEY, JSON.stringify(seen));
      state.hlsfReady = false;
      window.HLSF_GRAPH = null;
      updateStats();
      addLog(`📊 Import: ${seen.length} tokens, ${db.database_stats?.total_relationships ?? '?'} relationships.`);
      updateHeaderCounts();
    }

    function importDatabaseData(data, source = 'file') {
      try {
        // Validate the data structure
        if (!data.full_token_data || !Array.isArray(data.full_token_data)) {
          logError('Invalid database format. Expected full_token_data array.');
          return null;
        }

        state.hlsfReady = false;
        const persisted = safeStorageSet(DB_RAW_KEY, JSON.stringify(data));
        if (!persisted) {
          console.warn('Failed to persist raw DB snapshot');
        }

        const tokenData = data.full_token_data;
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        const seen = new Set();

        for (const token of tokenData) {
          if (!token.token) continue;

          const key = getCacheKey(token.token);
          const existing = safeStorageGet(key);
          seen.add(token.token);

          if (existing) {
            // Check if imported data is newer
            const existingData = typeof existing === 'string' ? JSON.parse(existing) : existing;
            const importedDate = new Date(token.cached_at || 0);
            const existingDate = new Date(existingData.cached_at || 0);

            if (importedDate > existingDate) {
              safeStorageSet(key, JSON.stringify(token));
              updated++;
            } else {
              skipped++;
            }
          } else {
            safeStorageSet(key, JSON.stringify(token));
            imported++;
          }
        }

        safeStorageSet(DB_INDEX_KEY, JSON.stringify(Array.from(seen)));
        updateStats();

        const summary = [];
        if (imported > 0) summary.push(`${imported} new tokens imported`);
        if (updated > 0) summary.push(`${updated} tokens updated`);
        if (skipped > 0) summary.push(`${skipped} existing tokens kept`);

        logSuccess(`Database imported from ${source}: ${summary.join(', ')}`);

        if (data.database_stats) {
          addLog(`<div class="adjacency-insight">
            📊 <strong>Import Summary:</strong><br>
            • Source maturity: ${data.database_stats.maturity_level}<br>
            • Total tokens in source: ${data.database_stats.total_tokens}<br>
            • Total relationships: ${data.database_stats.total_relationships}<br>
            • Estimated value: ${data.database_stats.estimated_value_usd}
          </div>`);
        }

        return { imported, skipped, updated, seen: Array.from(seen) };
      } catch (err) {
        logError(`Import failed: ${err.message}`);
        return null;
      }
    }

    async function autoLoadDatabase() {
      // Try to load from database.json in the same directory
      try {
        const response = await fetch('database.json');
        if (response.ok) {
          const data = await response.json();
          importDatabaseData(data, 'database.json');
        }
      } catch (err) {
        // Silently fail - file might not exist, which is fine
        console.log('No database.json found for auto-load');
      }
    }

    // ============================================
    // COMMANDS
    // ============================================
    const COMMANDS = window.COMMANDS = window.COMMANDS || Object.create(null);

    function registerCommand(name, handler) {
      if (!name || typeof handler !== 'function') return;
      const key = name.startsWith('/') ? name.toLowerCase() : `/${name.toLowerCase()}`;
      COMMANDS[key] = handler;
    }

    function cmd_import() {
      elements.dbFileInput.click();
    }

    function getRelationshipPriority(relType) {
      if (RELATIONSHIP_PRIORITIES instanceof Map) {
        return RELATIONSHIP_PRIORITIES.get(relType) ?? 1;
      }
      if (typeof RELATIONSHIP_PRIORITIES === 'object' && RELATIONSHIP_PRIORITIES !== null) {
        return RELATIONSHIP_PRIORITIES[relType] ?? 1;
      }
      return 1;
    }

    function* iterTokenRecords() {
      const raw = safeStorageGet(DB_RAW_KEY);
      if (raw) {
        const db = typeof raw === 'string' ? JSON.parse(raw) : raw;
        if (db.full_token_data && db.full_token_data.length) {
          for (const rec of db.full_token_data) yield rec;
          return;
        }
      }
      const idxRaw = safeStorageGet(DB_INDEX_KEY, []);
      const idx = Array.isArray(idxRaw) ? idxRaw : [];
      const keys = idx.length ? idx.map(t => TOKEN_CACHE_PREFIX + t)
                              : safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const k of keys) {
        const rec = safeStorageGet(k);
        if (rec) yield rec;
      }
    }

    function normRelKey(k) {
      // accept "∼ Adjacent To", "→ Next", bare "⊛", etc.
      const first = (k || '').trim().split(/\s+/)[0];
      return first || k;
    }

    function buildHLSF() {
      const pri = RELATIONSHIP_PRIORITIES || {};
      const nodes = [];
      const edges = [];
      let maxAttention = 0;

      for (const rec of iterTokenRecords()) {
        if (!rec || !rec.token || !rec.relationships) continue;
        let attention = 0;

        for (const rawKey of Object.keys(rec.relationships)) {
          const type = normRelKey(rawKey);
          const p = (pri[type] ?? pri.get?.(type)) ?? 1;
          for (const rel of rec.relationships[rawKey]) {
            const w = rel.weight ?? 0;
            attention += w * p;
            edges.push({ source: rec.token, target: rel.token, type, w });
          }
        }
        maxAttention = Math.max(maxAttention, attention);
        nodes.push({ id: rec.token, attention });
      }

      const norm = maxAttention || 1;
      for (const n of nodes) n.attention = +(n.attention / norm).toFixed(3);

      return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
    }

    async function cmd_hlsf() {
      const it = iterTokenRecords();
      const first = it.next();
      if (first.done) { logWarning('No cached tokens found for HLSF. Use /import.'); return; }

      // Re-run with full iterator including the first element
      function* replay() { yield first.value; for (const r of iterTokenRecords()) yield r; }
      const HLSF = (() => {
        const pri = RELATIONSHIP_PRIORITIES || {};
        const nodes = []; const edges = []; let maxA = 0;
        for (const rec of replay()) {
          if (!rec || !rec.token || !rec.relationships) continue;
          let a = 0;
          for (const rk of Object.keys(rec.relationships)) {
            const t = normRelKey(rk);
            const p = (pri[t] ?? pri.get?.(t)) ?? 1;
            for (const rel of rec.relationships[rk]) { const w = rel.weight ?? 0; a += w * p; edges.push({ source: rec.token, target: rel.token, type: t, w }); }
          }
          maxA = Math.max(maxA, a);
          nodes.push({ id: rec.token, attention: a });
        }
        const m = maxA || 1;
        for (const n of nodes) n.attention = +(n.attention / m).toFixed(3);
        return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
      })();

      window.HLSF_GRAPH = HLSF;
      state.hlsfReady = true;
      logSuccess(`HLSF ready: ${HLSF.meta.nodeCount} nodes, ${HLSF.meta.edgeCount} edges.`);
      try {
        stopHLSFAnimation();
        initHLSFCanvas();
      } catch (err) {
        logError(`HLSF initialization failed: ${err.message}`);
        console.error('HLSF visualization error:', err);
      }
      return; // ← stop any fallthrough probes
    }

    registerCommand('/import', cmd_import);
    window.COMMANDS = COMMANDS;
    // Router guard (prevents duplicate logs)
    if (!COMMANDS.__hlsf_bound) {
      COMMANDS['/hlsf'] = cmd_hlsf;
      COMMANDS.__hlsf_bound = true;
    }
    registerCommand('/visualize', cmd_hlsf);

    async function dispatchCommand(cmd) {
      if (cmd === '/hlsf') { await cmd_hlsf(); return; }  // hard return
      // ...other commands
    }

    function isCommand(input) { return input.startsWith('/'); }

    async function handleCommand(cmd) {
      const trimmed = cmd.trim();
      await safeAsync(() => dispatchCommand(trimmed), `Command dispatch failed for ${trimmed}`);
      if (trimmed === '/hlsf') return;

      const [command, ...args] = trimmed.slice(1).split(/\s+/);

      if (!command) {
        logError('Unknown command');
        return;
      }

      const normalized = `/${command.toLowerCase()}`;
      const mapped = COMMANDS[normalized];
      if (mapped) {
        await mapped(args, trimmed);
        return;
      }

      switch (command.toLowerCase()) {
        case 'clear':
          elements.log.innerHTML = '';
          logSuccess('Log cleared');
          break;
        case 'reset':
          if (confirm('Clear all cached data?')) {
            const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
            keys.forEach(k => safeStorageRemove(k));
            safeStorageRemove(DB_INDEX_KEY);
            state.hlsfReady = false;
            window.HLSF_GRAPH = null;
            updateStats();
            logSuccess(`Cleared ${keys.length} tokens`);
          }
          break;
        case 'stats':
          const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
          const total = totalApiCalls + totalCacheHits;
          const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) : 0;
          addLog(`<strong>Session Stats:</strong><br>
            • Requests: ${total}<br>
            • Cache hits: ${totalCacheHits} (${hitRate}%)<br>
            • API calls: ${totalApiCalls}<br>
            • Cost: ${formatCurrency(totalCostCents)}<br>
            • Cached tokens: ${getCachedTokenCount()}`);
          break;
        case 'database':
        case 'db':
          showDatabaseMetadata();
          break;
        case 'export':
          exportDatabaseMetadata();
          break;
        case 'glyph':
        case 'ledger':
          showGlyphLedger();
          break;
        case 'encrypt':
          const encryptMsg = args.join(' ');
          if (!encryptMsg) {
            logError('Usage: /encrypt <message>');
            break;
          }
          const encResult = window.GlyphSystem.encode(encryptMsg);
          addLog(`<div class="adjacency-insight">
            <strong>🔐 Encrypted:</strong><br>
            <div style="font-size: 1.5em; letter-spacing: 0.15em; color: var(--accent); margin: 0.5rem 0;">${encResult.encoded}</div>
            Coverage: ${encResult.coverage}%
            ${encResult.unknown.length > 0 ? `<br>Unknown tokens: ${encResult.unknown.join(', ')}` : ''}
          </div>`);
          break;
        case 'decrypt':
          const decryptMsg = args.join(' ');
          if (!decryptMsg) {
            logError('Usage: /decrypt <encrypted glyphs>');
            break;
          }
          const decoded = window.GlyphSystem.decode(decryptMsg);
          addLog(`<div class="adjacency-insight">
            <strong>🔓 Decrypted:</strong><br>
            ${decoded}
          </div>`);
          break;
        case 'exportledger':
          const ledgerData = window.GlyphSystem.export();
          logSuccess(`Glyph ledger exported: ${ledgerData.statistics.total_tokens} tokens, ${ledgerData.statistics.unique_glyphs} glyphs`);
          break;
        case 'help':
          addLog(`<strong>Commands:</strong><br>
            /clear - Clear log<br>
            /reset - Clear cache<br>
            /stats - Session statistics<br>
            /database or /db - View database metadata<br>
            /export - Export database metadata as JSON<br>
            /import - Import database from JSON file<br>
            /glyph or /ledger - View symbolic glyph encryption ledger<br>
            /encrypt &lt;message&gt; - Encrypt message using glyph system<br>
            /decrypt &lt;glyphs&gt; - Decrypt glyph-encoded message<br>
            /exportledger - Export glyph ledger for inter-system transmission<br>
            /hlsf or /visualize - Visualize database as Hierarchical-Level Semantic Framework<br>
            /help - Show commands`);
          break;
        default:
          logError(`Unknown: ${command}`);
      }
    }

    // ============================================
    // MAIN PROCESSING
    // ============================================
    async function processPrompt(prompt) {
      if (state.isProcessing) return;
      
      state.isProcessing = true;
      currentAbortController = new AbortController();
      elements.sendBtn.disabled = true;
      elements.cancelBtn.style.display = 'inline-block';
      elements.input.disabled = true;

      const startTime = performance.now();

      try {
        const tokens = tokenize(prompt);
        if (tokens.length === 0) {
          logError('Prompt cannot be empty');
          return;
        }
        if (tokens.length > CONFIG.MAX_TOKENS_PER_PROMPT) {
          logError(`Exceeds ${CONFIG.MAX_TOKENS_PER_PROMPT} token limit (${tokens.length})`);
          return;
        }

        const estimatedCalls = tokens.length * 2 + 3;
        const estimatedCost = estimatedCalls * CONFIG.ESTIMATED_COST_PER_API_CALL;
        addLog(`<div class="cost-estimate">
          📊 <strong>Estimate:</strong> ${tokens.length} tokens, ~${estimatedCalls} API calls, ~${formatCurrency(Math.ceil(estimatedCost * 100))}
        </div>`);

        // Step 1: Initial response
        let initialResponse = '';
        if (state.apiKey) {
          const s1 = logStatus('⏳ Generating initial response...');
          initialResponse = await callOpenAI([
            { role: 'system', content: 'You are an expert assistant.' },
            { role: 'user', content: prompt },
          ]);
          s1.innerHTML = `✅ Initial response generated`;
        } else {
          initialResponse = '⚠️ Offline mode';
          logWarning('Skipped (offline)');
        }

        // Step 2: Adjacency analysis
        const responseTokens = tokenize(initialResponse);
        const [inputMatrices, outputMatrices] = await Promise.all([
          batchFetchAdjacencies(tokens, prompt, 'input'),
          batchFetchAdjacencies(responseTokens, initialResponse, 'output'),
        ]);

        calculateAttention(inputMatrices);
        calculateAttention(outputMatrices);

        const allMatrices = new Map([...inputMatrices, ...outputMatrices]);
        const topTokens = summarizeAttention(allMatrices);
        const keyRels = extractKeyRelationships(allMatrices);

        addLog(`<div class="adjacency-insight">
          <strong>🎯 High Attention:</strong> ${formatTopTokens(topTokens)}
        </div>
        <div class="adjacency-insight">
          <strong>🔗 Key Relationships:</strong><br>
          ${keyRels.map(r => `• ${r}`).join('<br>')}
        </div>`);

        // Step 3: Thought stream
        let thoughtStream = '';
        if (state.apiKey) {
          const s2 = logStatus('⏳ Synthesizing thought stream...');
          thoughtStream = await callOpenAI([
            { role: 'system', content: 'You create reflective thought streams from analytical insights.' },
            { role: 'user', content: `Based on these adjacency insights, generate a stream-of-consciousness internal monologue:\n\nTop tokens: ${JSON.stringify(topTokens)}\nRelationships: ${keyRels.join('; ')}\n\nWrite as flowing natural thought connecting these elements.` },
          ]);
          s2.innerHTML = '✅ Thought stream captured';
          
          addLog(`<div class="section-divider"></div>
            <div class="section-title">💭 Emergent Thought Stream</div>
            <div class="thought-stream">${sanitize(thoughtStream)}</div>`);
        }

        // Step 4: Refined response
        let refinedResponse = initialResponse;
        if (state.apiKey) {
          const s3 = logStatus('⏳ Refining response...');
          refinedResponse = await callOpenAI([
            { role: 'system', content: 'You refine responses based on adjacency insights.' },
            { role: 'user', content: `Original: "${initialResponse}"\n\nInsights: ${thoughtStream}\n\nRevise by: 1) Incorporating emergent insights 2) Restructuring based on token relationships 3) Enhancing coherence. Provide revised response only.` },
          ]);
          s3.innerHTML = '✅ Response refined';
        }

        // Display final output
        const time = ((performance.now() - startTime) / 1000).toFixed(1);
        addLog(`<div class="section-divider"></div>
          <div class="final-output">
            <h3>✨ REFINED RESPONSE</h3>
            <pre>${sanitize(refinedResponse)}</pre>
            
            <details>
              <summary>Compare with original response</summary>
              <pre>${sanitize(initialResponse)}</pre>
            </details>
            
            <details>
              <summary>View adjacency data (${allMatrices.size} tokens)</summary>
              <pre>${JSON.stringify(Array.from(allMatrices.entries()).slice(0, 5), null, 2)}</pre>
            </details>
          </div>
        `);
        
        logSuccess(`Processing complete (${time}s)`);

      } catch (err) {
        if (err.name === 'AbortError' || err.message === 'AbortError') {
          logWarning('Processing cancelled');
        } else {
          logError(err.message || 'Processing failed');
          console.error(err);
        }
      } finally {
        state.isProcessing = false;
        currentAbortController = null;
        elements.sendBtn.disabled = false;
        elements.cancelBtn.style.display = 'none';
        elements.input.disabled = false;
        elements.input.value = '';
        elements.input.focus();
      }
    }

    // ============================================
    // EVENTS
    // ============================================
    elements.apiConfirmBtn.addEventListener('click', () => {
      const key = elements.apiKeyInput.value.trim();
      if (!key.startsWith('sk-')) {
        logError('Invalid API key format');
        return;
      }
      state.apiKey = key;
      elements.apiModal.classList.add('hidden');
      logSuccess('API key configured');
    });

    elements.apiCancelBtn.addEventListener('click', () => {
      elements.apiModal.classList.add('hidden');
      logWarning('Offline mode - limited functionality');
    });

    elements.sendBtn.addEventListener('click', () => {
      const input = elements.input.value.trim();
      if (!input) return;
      
      addLog(`> ${sanitize(input)}`);
      
      if (isCommand(input)) {
        handleCommand(input);
        elements.input.value = '';
      } else {
        processPrompt(input);
      }
    });

    elements.cancelBtn.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
        logWarning('Cancelling...');
      }
    });

    elements.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.sendBtn.click();
      }
    });

    elements.dbFileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      try {
        await importHLSFDBFromFile(file);
      } catch (err) {
        logError(`Import failed: ${err.message}`);
      } finally {
        e.target.value = '';
      }
    });

    // ============================================
    // INIT
    // ============================================
    window.addEventListener('beforeunload', () => {
      state.apiKey = '';
      stopHLSFAnimation();
    });

    async function initialize() {
      updateStats();
      
      // Try to auto-load database.json
      await autoLoadDatabase();
      
      const cachedCount = getCachedTokenCount();
      
      addLog(`<strong>🧠 HLSF Cognition Engine v2.0</strong><br><br>
        This engine performs:<br>
        1. Token adjacency mapping (50 relationship types)<br>
        2. Attention score calculation<br>
        3. Emergent thought stream synthesis<br>
        4. Response refinement based on insights<br>
        5. <strong>Symbolic glyph encryption</strong> (complex number encoding)<br>
        6. <strong>HLSF visualization</strong> (hierarchical semantic framework)<br><br>
        <strong>Commands:</strong> /help, /hlsf, /glyph, /encrypt, /decrypt<br>
        ${cachedCount > 0 ? `<br>✅ Loaded with ${cachedCount} cached tokens` : ''}
        <br><small>⚠️ Note: Download HTML and run locally for API calls to work.</small>
      `);
      
      elements.input.focus();
    }

    initialize();
  </script>
</body>
</html>