<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HLSF Cognition Engine v2.0</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0a0a;
      --panel: #111;
      --text: #e0e0e0;
      --accent: #00ff88;
      --error: #ff4444;
      --success: #44ff44;
      --warning: #ffd54f;
      --scrollbar: #1f1f1f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Fira Code', Consolas, Monaco, 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
      width: 100%;
    }

    #header {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      font-weight: normal;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .stat-value {
      font-weight: bold;
      color: var(--accent);
    }

    #log {
      flex: 1;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
      min-height: 400px;
    }

    #log::-webkit-scrollbar { width: 10px; }
    #log::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 10px; }

    #input-area {
      margin-top: 1rem;
      display: flex;
      gap: 0.75rem;
    }

    #command-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      transition: border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    #command-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn-primary { background: var(--accent); color: #022d15; }
    .btn-secondary { background: #333; color: var(--text); }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.25);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .hidden { display: none !important; }

    #hlsf-log-progress { background: #222; }
    #hlsf-log-bar { background: #6cf; height: 6px; width: 0%; transition: width 0.15s; }
    #hlsf-batch-log { max-height: 280px; overflow: auto; }

    .log-entry {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      animation: fadeIn 0.3s ease;
    }

    .log-entry .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .log-entry.status { font-style: italic; }
    .log-entry.error { border-left-color: var(--error); color: var(--error); }
    .log-entry.success { border-left-color: var(--success); color: var(--success); }
    .log-entry.warning { border-left-color: var(--warning); color: var(--warning); }

    .cost-estimate {
      background: rgba(255, 213, 79, 0.1);
      border: 1px solid var(--warning);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
    }

    .section-divider {
      margin: 1.5rem 0 0.5rem 0;
      border-top: 2px solid #222;
      padding-top: 1rem;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .thought-stream {
      background: rgba(0, 255, 136, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 8px;
      padding: 1rem;
      font-style: italic;
      line-height: 1.6;
    }

    .adjacency-insight {
      background: rgba(255, 213, 79, 0.05);
      border: 1px solid rgba(255, 213, 79, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .token-highlight {
      background: rgba(0, 255, 136, 0.2);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: bold;
    }

    .final-output {
      border-left: 3px solid var(--success);
      padding: 1rem;
      background: rgba(68, 255, 68, 0.05);
      border-radius: 8px;
    }

    .final-output h3 {
      margin-top: 0;
      color: var(--success);
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #222;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin: 0.5rem 0;
      transition: border 0.2s ease;
    }

    details[open] {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.25);
    }

    summary {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      list-style: none;
      font-weight: 600;
      padding: 0.3rem 0;
    }

    summary::-webkit-details-marker { display: none; }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0.5rem 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: #111;
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2rem;
      width: min(420px, 90vw);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-content h2 { margin: 0; color: var(--accent); }

    .hlsf-canvas-container {
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
    }

    #hlsf-canvas {
      width: 100%;
      height: 600px;
      background: transparent;
      border-radius: 8px;
      cursor: grab;
    }

    #hlsf-canvas:active {
      cursor: grabbing;
    }

    .hlsf-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .hlsf-control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .hlsf-control-group.full-span {
      grid-column: 1 / -1;
    }

    .hlsf-mental-state {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid #222;
      border-radius: 6px;
      padding: 0.75rem 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .hlsf-mental-name {
      font-weight: 700;
      color: var(--accent);
      font-size: 0.95rem;
    }

    .hlsf-mental-summary {
      font-size: 0.85rem;
      font-style: italic;
      opacity: 0.8;
    }

    .hlsf-mental-desc,
    .hlsf-mental-mechanics {
      font-size: 0.8rem;
      line-height: 1.3;
    }

    .hlsf-mental-mechanics {
      opacity: 0.75;
    }

    .hlsf-dimension-stats {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid #222;
      border-radius: 6px;
      padding: 0.5rem 0.6rem;
    }

    .hlsf-dimension-stats span {
      color: var(--accent);
      font-weight: 600;
    }

    .hlsf-control-group label {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .hlsf-control-group input[type="range"],
    .hlsf-control-group select {
      width: 100%;
    }

    .hlsf-control-group input[type="number"],
    .hlsf-control-group select {
      padding: 0.5rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 6px;
      color: var(--text);
    }

    .hlsf-button-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hlsf-button-row button {
      flex: 1;
      min-width: 80px;
    }

    .hlsf-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      margin-top: 0.5rem;
    }

    .hlsf-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .hlsf-legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .hlsf-node-info {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      font-size: 0.85rem;
      display: none;
    }

    .hlsf-node-info.visible {
      display: block;
    }

    .modal-content input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #222;
      background: #0c0c0c;
      color: var(--text);
      font-size: 1rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .pill-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pill-button.primary { background: var(--accent); color: #022d15; }
    .pill-button.secondary { background: transparent; border: 1px solid #333; color: var(--text); }

    .pill-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.18);
    }

    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 136, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    .processing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      #app { padding: 1rem; }
      #header { flex-direction: column; align-items: flex-start; }
      .header-stats { flex-direction: column; gap: 0.5rem; }
      #input-area { flex-direction: column; }
      .button-group { flex-direction: column; }
      .btn { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="api-modal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true">
      <h2>Enter OpenAI API Key</h2>
      <p>Provide your OpenAI API key (sk-...) to begin using the HLSF Cognition Engine.</p>
      <input id="api-key-input" type="password" placeholder="sk-..." />
      <div class="modal-actions">
        <button id="api-cancel" class="pill-button secondary">Continue offline</button>
        <button id="api-confirm" class="pill-button primary">Save key</button>
      </div>
      <small style="opacity:0.65">‚ö†Ô∏è Note: Download this HTML file and run locally for API calls to work.</small>
    </div>
  </div>

  <div id="app">
    <div id="header">
      <div>HLSF Cognition Engine v2.0</div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">Cache Hit Rate</span>
          <span class="stat-value" id="cache-hit-rate">‚Äî</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Cached Tokens</span>
          <span class="stat-value" id="cached-tokens">‚Äî</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Session Cost</span>
          <span class="stat-value" id="session-cost">$0.00</span>
        </div>
      </div>
    </div>
    <div id="log"></div>
    <div id="input-area">
      <input id="command-input" type="text" placeholder="> Enter a prompt or /command" maxlength="600" autocomplete="off" />
      <div class="button-group">
        <button id="cancel-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
        <button id="send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
    <input id="db-file" type="file" accept=".json,application/json" style="display:none">
    <div class="hlsf-canvas-container hidden" id="hlsf-canvas-container">
      <div class="section-title">üî≠ HLSF Matrix Visualizer</div>
      <details id="hlsf-batch-log" open>
        <summary>Batch log</summary>
        <div id="hlsf-log-progress">
          <div id="hlsf-log-bar"></div>
        </div>
        <pre id="hlsf-log-stream"></pre>
        <button id="hlsf-log-download">Download log</button>
      </details>
      <canvas id="hlsf-canvas"></canvas>
      <div class="hlsf-controls">
        <div class="hlsf-control-group">
          <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
          <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
          <input id="hlsf-alpha" type="range" min="0.005" max="0.99" step="0.01" value="0.70">
        </div>
        <div class="hlsf-control-group">
          <label>Edge width <span id="edgew-val">0.02</span></label>
          <input id="edgew" type="range" min="0.01" max="1.00" step="0.005" value="0.02">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
          <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-color-mode">Edge coloring</label>
          <select id="hlsf-edge-color-mode">
            <option value="theme">Theme</option>
            <option value="weight">Weight</option>
            <option value="relation">Relation</option>
          </select>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">50</span></label>
          <input id="hlsf-relation-cap" type="number" min="1" max="50" step="1" value="50">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
          <input id="hlsf-edges-per-type" type="number" min="1" max="10" step="1" value="3">
        </div>
        <div class="hlsf-control-group">
          <label>Display options</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
            <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
            <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
            <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
            <button id="hlsf-toggle-layout" class="btn btn-secondary">Layout: Affinity</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-aff-thresh">Affinity threshold <span id="hlsf-aff-thresh-val">0.35</span></label>
          <input id="hlsf-aff-thresh" type="range" min="0.1" max="0.8" step="0.01" value="0.35">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-aff-iters">Affinity iterations <span id="hlsf-aff-iters-val">8</span></label>
          <input id="hlsf-aff-iters" type="range" min="1" max="20" step="1" value="8">
        </div>
        <div class="hlsf-control-group full-span">
          <em id="hlsf-affinity-summary" class="hlsf-mental-summary">Current mental state: Focused yet flexible attention.</em>
        </div>
        <div class="hlsf-control-group">
          <label>Rotation modes</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
            <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergence</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>View</label>
          <div class="hlsf-button-row">
            <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
            <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
            <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
            <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      MAX_TOKENS_PER_PROMPT: 500,
      MAX_TOKENS_PER_RESPONSE: 500,
      MAX_CONCURRENCY: 5,
      MAX_RETRY_ATTEMPTS: 3,
      RETRY_BASE_DELAY_MS: 500,
      DEFAULT_MODEL: 'gpt-4o-mini',
      MODEL_PRICING: {
        default: { inputPerMillion: 0.15, outputPerMillion: 0.60 },
        'gpt-4o-mini': { inputPerMillion: 0.15, outputPerMillion: 0.60 },
      },
      ESTIMATED_COMPLETION_RATIO: 0.7,
      ADJACENCY_TOKEN_ESTIMATES: {
        prompt: 220,
        completion: 320,
      },
    };

    const METRIC_SCOPE = { RUN: 'run', DB: 'db' };

    // Canonical 50-type display names
    const REL_EN = {
      "‚â°":"Identity","‚äÉ":"Contains","‚äÇ":"Is Contained By","‚âà":"Variant","‚àà":"Is Instance Of","‚àã":"Has Instance",
      "‚ä§":"Is Type Of","‚ä•":"Has Type","‚äè":"Part Of","‚äê":"Composes","‚Üî":"Mirrors","‚áå":"Inverts","‚à•":"Parallel To",
      "‚àº":"Adjacent To","‚Üí":"Next","‚áí":"Sequence Of","‚áê":"Preceded By","‚Ü†":"Follows","‚Üó":"Spatially Above","‚Üò":"Spatially Below",
      "‚Üù":"Symbolically Supports","‚Üß":"Symbolically Depends","‚â†":"Contrasts","‚äï":"Complements","‚äõ":"Associated With","‚àù":"Correlates With",
      "‚áù":"Causes","‚Üº":"Caused By","*":"Evokes","‚âú":"Represents","‚òÖ":"Symbolizes","‚Ü¶":"Refers To","‚ä¢":"Defines","‚ä£":"Is Defined By",
      "‚Ü∑":"Transforms To","‚Ü∂":"Transformed From","‚àò":"Functions As","‚ä®":"Interpreted As","‚óÅ":"Used With","‚áÑ":"Co-occurs With",
      "‚äó":"Synthesizes","√∑":"Divides Into","‚äò":"Opposes","‚Ü≥":"Leads To","‚Ü≤":"Results In","‚üÇ":"Orthogonal To","‚âàÃ∏":"Diverges From",
      "‚âç":"Equivalent In Form","‚âì":"Approximately Equals","‚âî":"Defined As"
    };

    // Return "‚àº Adjacent To"
    const relDisplay = k => `${k} ${REL_EN[k] ?? ''}`.trim();

    const RELKEY_ALIASES = (() => {
      const map = new Map();
      for (const [glyph, name] of Object.entries(REL_EN)) {
        map.set(`${glyph} ${name}`, glyph);
        map.set(name, glyph);
        map.set(name.toLowerCase(), glyph);
      }
      map.set('‚àó', '*');
      map.set('*', '*');
      map.set('‚ãÜ', '*');
      return map;
    })();

    const BatchLog = (() => {
      const buf = [];
      let lastFlush = 0;
      let ui = null;
      let bar = null;
      const max = 5000;
      const loggingEnabled = () => window.HLSF?.config?.batchLogging !== false;

      function mount() {
        ui = document.getElementById('hlsf-log-stream');
        bar = document.getElementById('hlsf-log-bar');
      }

      function push(ev) {
        if (!loggingEnabled()) return;
        const t = performance.now();
        buf.push({ t, ...ev });
        if (buf.length > max) buf.shift();
        flush(120);
      }

      function phase(name, evt = 'mark', meta) {
        push({ phase: name, evt, meta });
      }

      function progress(done, total) {
        if (!bar) return;
        if (!loggingEnabled()) {
          bar.style.width = '0%';
          return;
        }
        const pct = Math.floor((100 * done) / Math.max(1, total));
        bar.style.width = `${Math.min(100, Math.max(0, pct))}%`;
      }

      function flush(ms = 120) {
        if (!loggingEnabled()) return;
        const now = performance.now();
        if (!ui || now - lastFlush < ms) return;
        lastFlush = now;
        const tail = buf.slice(-200).map(e => {
          const dt = (e.t / 1000).toFixed(3);
          const tag = e.phase ? `[${e.phase}:${e.evt || 'mark'}]` : '';
          const meta = e.meta ? ` ${JSON.stringify(e.meta)}` : '';
          const msg = e.msg ? ` ${e.msg}` : '';
          return `${dt} ${tag}${msg}${meta}`.trimEnd();
        }).join('\n');
        ui.textContent = tail;
      }

      function toJSON() {
        return JSON.stringify(buf);
      }

      function clear() {
        buf.length = 0;
        lastFlush = 0;
        if (ui) ui.textContent = '';
        if (bar) bar.style.width = '0%';
      }

      function download() {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([toJSON()], { type: 'application/json' }));
        a.download = `hlsf_batch_log_${Date.now()}.json`;
        a.click();
      }

      window.addEventListener('load', () => {
        mount();
        document.getElementById('hlsf-log-download')?.addEventListener('click', download);
      });

      return { push, phase, progress, flush, clear, toJSON, mount };
    })();

    function normRelKey(k) {
      const cleaned = (k || '').trim();
      if (!cleaned) return null;
      if (REL_EN[cleaned]) return cleaned;
      const normalized = cleaned.replace(/\s+/g, ' ');
      const alias = RELKEY_ALIASES.get(normalized)
        || RELKEY_ALIASES.get(normalized.toLowerCase())
        || RELKEY_ALIASES.get(normalized.split(' ')[0]);
      return REL_EN[alias] ? alias : null;
    }

    function normalizeRelKeyForStats(k){
      const g = normRelKey(k);
      return REL_EN[g] ? g : null;
    }

    function renderRelTypeRow(glyph, count){
      return `${relDisplay(glyph)}: ${count} instances`;
    }

    // ---------------- HLSF matrix builder ----------------
    function buildMatrixForRecord(rec) {
      const edges = [];
      const rels = rec?.relationships || {};
      const keys = Object.keys(rels);
      for (const rawKey of keys) {
        const key = normRelKey(rawKey);
        if (!key) continue;
        const arr = Array.isArray(rels[rawKey]) ? rels[rawKey] : [];
        const items = arr
          .filter(x => x && typeof x.weight === 'number')
          .sort((a, b) => b.weight - a.weight);
        if (!items.length) continue;
        const agg = {
          rtype: key,
          aggWeight: items[0].weight,
          sizeWeight: items.reduce((s, x) => s + x.weight, 0),
          count: items.length,
          items
        };
        edges.push(agg);
      }
      const freq = typeof rec?.f === 'number'
        ? rec.f
        : typeof rec?.frequency === 'number'
          ? rec.frequency
          : typeof rec?.freq === 'number'
            ? rec.freq
            : 1;
      return { token: rec?.token || '', edges, f: freq };
    }

    function buildHLSFMatrices(db) {
      const raw = db?.full_token_data || [];
      const matrices = new Map();
      const freqs = [];
      for (const rec of raw) {
        const matrix = buildMatrixForRecord(rec);
        matrices.set(matrix.token, matrix);
        if (typeof matrix.f === 'number') freqs.push(matrix.f);
      }

      freqs.sort((a, b) => a - b);
      const freqStats = freqs.length
        ? {
            min: freqs[0],
            max: freqs[freqs.length - 1],
            p90: freqs[Math.max(0, Math.floor(freqs.length * 0.9) - 1)]
          }
        : { min: 0, max: 1, p90: 1 };

      window.HLSF = window.HLSF || {};
      window.HLSF.matrices = matrices;
      window.HLSF.metrics = Object.assign({}, window.HLSF.metrics, { freqStats });

      return matrices;
    }

    function parseHlsfArgs(str) {
      const out = { mode: 'full', tokens: [], glyphs: [], depth: 3.0 };
      const s = (str || '').trim();
      if (!s) return out;
      if (/^--conversation$/i.test(s)) { out.mode = 'conversation'; return out; }
      const m = s.match(/^--\[(.*)\]$/s);
      if (!m) return out;
      const parts = m[1].split(/\s*,\s*/).filter(Boolean);
      for (const p of parts) {
        const kv = p.split(/\s*=\s*/);
        if (kv.length === 2 && /^recursionDepth$/i.test(kv[0])) {
          out.depth = Math.max(0, parseFloat(kv[1]) || 0);
          continue;
        }
        if (/^[\u2200-\u2BFF\u{1F300}-\u{1FAFF}]+$/u.test(p)) out.glyphs.push(p);
        else out.tokens.push(p);
      }
      out.mode = out.glyphs.length ? 'glyphs' : 'tokens';
      return out;
    }

    function extractHlsfFlags(str) {
      const raw = (str || '').trim();
      if (!raw) return { text: '', flags: {} };

      const parts = raw.split(/\s+/);
      const remain = [];
      const flags = {};

      const parseValue = (part, index) => {
        const eqIdx = part.indexOf('=');
        if (eqIdx >= 0) return part.slice(eqIdx + 1);
        if (index + 1 < parts.length) return parts[index + 1];
        return '';
      };

      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const lower = part.toLowerCase();

        if (lower === '--nolog') { flags.batchLogging = false; continue; }
        if (lower === '--nowait') { flags.deferredRender = false; continue; }

        if (lower.startsWith('--scope')) {
          const value = parseValue(part, i).toLowerCase();
          if (!part.includes('=')) i += 1;
          if (value === METRIC_SCOPE.DB) flags.metricScope = METRIC_SCOPE.DB;
          else if (value === METRIC_SCOPE.RUN) flags.metricScope = METRIC_SCOPE.RUN;
          continue;
        }

        if (lower.startsWith('--depth')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const depth = parseFloat(value);
          if (Number.isFinite(depth)) flags.depth = depth;
          continue;
        }

        if (lower.startsWith('--types')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const valLower = typeof value === 'string' ? value.toLowerCase() : '';
          if (valLower === 'all' || valLower === 'infinity' || valLower === 'inf' || valLower === '‚àû') {
            flags.relationTypeCap = Infinity;
          } else {
            const n = parseInt(value, 10);
            if (Number.isFinite(n)) flags.relationTypeCap = n;
          }
          continue;
        }

        if (lower.startsWith('--ept')) {
          const value = parseValue(part, i);
          if (!part.includes('=')) i += 1;
          const valLower = typeof value === 'string' ? value.toLowerCase() : '';
          if (valLower === 'all' || valLower === 'infinity' || valLower === 'inf' || valLower === '‚àû') {
            flags.edgesPerType = Infinity;
          } else {
            const n = parseInt(value, 10);
            if (Number.isFinite(n)) flags.edgesPerType = n;
          }
          continue;
        }

        remain.push(part);
      }

      const text = remain.join(' ').trim();
      return { text, flags };
    }

    function buildIndex(db) {
      const idx = new Map();
      (db?.full_token_data || []).forEach(rec => {
        if (rec?.token) idx.set(rec.token, rec);
      });
      return idx;
    }

    async function loadOrGetIndex() {
      const db = getDb();
      if (!db) throw new Error('No DB loaded');
      if (window.HLSF.indexCache && window.HLSF.indexCacheSource === window.HLSF.dbCache) {
        return window.HLSF.indexCache;
      }
      loadGlyphMaps(db);
      const idx = buildIndex(db);
      window.HLSF.indexCache = idx;
      window.HLSF.indexCacheSource = window.HLSF.dbCache;
      return idx;
    }

    function getAnchorCap(idx) {
      const configuredCap = Number(window.HLSF?.config?.fullAnchorCap);
      if (Number.isFinite(configuredCap) && configuredCap > 0) {
        const size = idx instanceof Map ? idx.size : configuredCap;
        return Math.min(configuredCap, size);
      }
      return idx instanceof Map ? idx.size : 0;
    }

    function adjacencyStats(rec) {
      let relTypes = 0;
      let edges = 0;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          relTypes += 1;
          edges += arr.length;
        }
      }
      return { relTypes, edges };
    }

    function defaultAnchors(idx, k = 64) {
      const recs = Array.from(idx.values());
      recs.sort((a, b) => {
        const A = adjacencyStats(a);
        const B = adjacencyStats(b);
        return (B.edges - A.edges) || (B.relTypes - A.relTypes);
      });
      return recs.slice(0, k).map(r => r.token);
    }

    function signatureFor(rec) {
      const S = { weights: new Map(), neigh: new Set() };
      for (const arr of Object.values(rec?.relationships || {})) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const token = rel?.token;
          if (!token) continue;
          const weight = Number.isFinite(rel?.weight)
            ? rel.weight
            : Number.isFinite(rel?.w)
              ? rel.w
              : 1;
          S.weights.set(token, (S.weights.get(token) || 0) + weight);
          S.neigh.add(token);
        }
      }
      return S;
    }

    function cosine(a, b) {
      if (!a || !b) return 0;
      let dot = 0;
      let na = 0;
      let nb = 0;
      for (const [token, wa] of a.weights) {
        na += wa * wa;
        const wb = b.weights.get(token) || 0;
        if (wb) dot += wa * wb;
      }
      for (const wb of b.weights.values()) nb += wb * wb;
      const denom = Math.sqrt(na * nb);
      return denom ? dot / denom : 0;
    }

    function jaccard(a, b) {
      if (!a || !b) return 0;
      const A = a.neigh;
      const B = b.neigh;
      let inter = 0;
      const small = A.size <= B.size ? A : B;
      const big = A.size <= B.size ? B : A;
      for (const x of small) if (big.has(x)) inter += 1;
      const uni = A.size + B.size - inter;
      return uni ? inter / uni : 0;
    }

    function affinity(a, b) {
      return 0.6 * cosine(a, b) + 0.4 * jaccard(a, b);
    }

    function candidateMap(graph) {
      const nbr = new Map();
      const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
      for (const edge of edges) {
        const fromSet = nbr.get(edge.from) || (() => {
          const set = new Set();
          nbr.set(edge.from, set);
          return set;
        })();
        const toSet = nbr.get(edge.to) || (() => {
          const set = new Set();
          nbr.set(edge.to, set);
          return set;
        })();
        fromSet.add(edge.to);
        toSet.add(edge.from);
      }
      for (const [a, set] of nbr) {
        for (const b of [...set]) {
          const second = nbr.get(b) || new Set();
          for (const c of second) {
            if (c !== a) set.add(c);
          }
        }
      }
      return nbr;
    }

    function clusterByAffinity(graph, index, { thresh = 0.35, iters = 8 } = {}) {
      if (!graph || !index) return 0;
      const sig = new Map();
      for (const [token] of graph.nodes) {
        sig.set(token, signatureFor(index.get(token) || {}));
      }
      const cand = candidateMap(graph);
      for (const token of graph.nodes.keys()) {
        if (!cand.has(token)) cand.set(token, new Set());
      }
      const label = new Map();
      for (const token of graph.nodes.keys()) label.set(token, token);
      const limit = Math.max(1, Math.floor(iters));
      const threshold = Math.max(0, Math.min(1, Number(thresh) || 0));
      for (let i = 0; i < limit; i++) {
        let moved = 0;
        for (const [a, neighbors] of cand) {
          let best = label.get(a);
          let bestScore = 0;
          const scores = new Map();
          for (const b of neighbors) {
            const score = affinity(sig.get(a), sig.get(b));
            if (score < threshold) continue;
            const lbl = label.get(b);
            scores.set(lbl, (scores.get(lbl) || 0) + score);
          }
          for (const [lbl, total] of scores) {
            if (total > bestScore) {
              bestScore = total;
              best = lbl;
            }
          }
          if (best !== label.get(a)) {
            label.set(a, best);
            moved += 1;
          }
        }
        if (!moved) break;
      }
      const ids = [...new Set(label.values())].sort();
      const idMap = new Map(ids.map((k, idx) => [k, idx]));
      for (const [token, node] of graph.nodes) {
        node.cluster = idMap.get(label.get(token));
      }
      return idMap.size;
    }

    function applyAffinityClusters(graph, index) {
      if (!graph || !index) return 0;
      const config = window.HLSF?.config?.affinity || {};
      const threshold = Number.isFinite(config.threshold) ? config.threshold : 0.35;
      const iterations = Number.isFinite(config.iterations) ? config.iterations : 8;
      const count = clusterByAffinity(graph, index, { thresh: threshold, iters: iterations });
      graph.clusterCount = count;
      return count;
    }

    function recomputeAndRender() {
      const graph = window.HLSF?.currentGraph;
      const idx = window.HLSF?.lastCommand?.idx;
      if (graph && idx) {
        applyAffinityClusters(graph, idx);
      }
      debouncedLegacyRender();
    }

    function getRelationTypeCap() {
      const raw = window.HLSF?.config?.relationTypeCap;
      if (raw === Infinity) return Infinity;
      return clampRelationTypeCap(raw);
    }

    function getEdgesPerType() {
      const raw = window.HLSF?.config?.edgesPerType;
      if (raw === Infinity) return Infinity;
      return clampEdgesPerType(raw);
    }

    async function assembleGraphFromAnchorsLogged(anchorsInput, depthFloat, index, options = {}) {
      const opts = options || {};
      const fallbackAnchors = Array.isArray(options?.anchors) ? options.anchors : undefined;
      const legacySeeds = Array.isArray(options?.seeds) ? options.seeds : undefined;
      const anchors = anchorsInput ?? fallbackAnchors ?? legacySeeds ?? [];
      const graph = { nodes: new Map(), links: [], anchors: [...anchors] };
      const outSet = new Set();
      const inSet = new Set();
      let edgeTypeEnums = 0;
      const queue = [];
      let head = 0;
      let expanded = 0;
      let enqueued = 0;
      const tick = Math.max(1, Math.round(Number(window.HLSF?.config?.progressTick) || 250));
      const maxDepth = Math.floor(depthFloat);
      const frac = depthFloat - maxDepth;
      const loggingActive = !opts.silent && window.HLSF?.config?.batchLogging !== false;
      const logPhase = (evt, meta) => { if (loggingActive) BatchLog.phase('graph', evt, meta); };
      const logProgress = (done, total) => { if (loggingActive) BatchLog.progress(done, total); };
      const seenTriple = new Set();
      const visitedSrc = new Set();
      const fractionalNodes = new Set();
      const freqFor = (rec) => {
        if (!rec) return 1;
        if (Number.isFinite(rec.f)) return rec.f;
        if (Number.isFinite(rec.frequency)) return rec.frequency;
        if (Number.isFinite(rec.freq)) return rec.freq;
        return 1;
      };
      const ensureNode = (token, layer) => {
        if (!token) return null;
        const existing = graph.nodes.get(token);
        if (existing) {
          if (Number.isFinite(layer)) {
            const currentLayer = Number(existing.layer);
            if (!Number.isFinite(currentLayer) || layer < currentLayer) existing.layer = layer;
          }
          return existing;
        }
        const rec = index.get(token);
        if (!rec) return null;
        const node = { token, f: freqFor(rec), layer: Number.isFinite(layer) ? layer : 0, degree: 0 };
        graph.nodes.set(token, node);
        return node;
      };
      const pushLink = (from, to, rtype, weight, hiddenTokens = []) => {
        const key = `${from}|${rtype}|${to}`;
        if (seenTriple.has(key)) return false;
        seenTriple.add(key);
        const hidden = Array.isArray(hiddenTokens) ? hiddenTokens.filter(Boolean) : [];
        graph.links.push({ from, to, rtype, w: weight, hiddenTokens: hidden });
        outSet.add(from);
        inSet.add(to);
        const fromNode = graph.nodes.get(from);
        const toNode = graph.nodes.get(to);
        if (fromNode) fromNode.degree = (fromNode.degree || 0) + 1;
        if (toNode) toNode.degree = (toNode.degree || 0) + 1;
        expanded += 1;
        if (loggingActive && expanded % tick === 0) {
          logProgress(expanded, expanded + Math.max(0, queue.length - head));
        }
        return true;
      };
      const queueNext = (from, to, rtype, weight, depth) => {
        queue.push({ from, to, rtype, w: weight, depth });
        enqueued += 1;
      };
      const expandSource = (token, depth) => {
        const rec = index.get(token);
        if (!rec) return;
        ensureNode(token, depth);
        const matrix = buildMatrixForRecord(rec);
        const relations = Array.isArray(matrix?.edges) ? matrix.edges.slice(0, getRelationTypeCap()) : [];
        for (const relation of relations) {
          const rawItems = Array.isArray(relation?.items)
            ? relation.items.slice()
            : [];
          if (!rawItems.length) continue;
          const limit = getEdgesPerType();
          const visibleItems = limit === Infinity ? rawItems : rawItems.slice(0, limit);
          if (!visibleItems.length) continue;
          const hiddenItems = limit === Infinity ? [] : rawItems.slice(visibleItems.length);
          const hiddenTokens = hiddenItems.map(item => item?.token).filter(Boolean);
          let enumerated = false;
          const nextDepth = depth + 1;
          for (const item of visibleItems) {
            const target = item?.token;
            if (!target) continue;
            const targetRec = index.get(target);
            if (!targetRec) continue;
            ensureNode(target, nextDepth);
            const weight = Number.isFinite(item?.weight)
              ? item.weight
              : Number.isFinite(item?.w)
                ? item.w
                : relation?.aggWeight;
            const normalizedWeight = Number(weight) || 0;
            const added = pushLink(token, target, relation?.rtype, normalizedWeight, hiddenTokens);
            if (added) {
              enumerated = true;
              if (depth < maxDepth) {
                queueNext(token, target, relation?.rtype, normalizedWeight, nextDepth);
              } else if (frac > 0) {
                fractionalNodes.add(target);
              }
            }
          }
          if (enumerated) edgeTypeEnums += 1;
        }
      };

      for (const anchor of anchors) {
        if (!index.get(anchor)) continue;
        ensureNode(anchor, 0);
        expandSource(anchor, 0);
        visitedSrc.add(anchor);
      }

      logPhase('anchored', { anchors: anchors.length, queued: enqueued });

      while (head < queue.length) {
        const edge = queue[head++];
        if (!edge) break;
        if (edge.depth > maxDepth) continue;
        if (visitedSrc.has(edge.to)) continue;
        expandSource(edge.to, edge.depth);
        visitedSrc.add(edge.to);
        if (!opts.silent && expanded % 1000 === 0) {
          logPhase('tick', { expanded, queued: Math.max(0, queue.length - head), nodes: graph.nodes.size, link_instances: graph.links.length });
          await microtask();
        }
      }

      if (frac > 0 && fractionalNodes.size) {
        logPhase('fractional', { added: fractionalNodes.size });
      }

      logProgress(1, 1);
      const metrics = {
        nodes: outSet.size,
        edges: edgeTypeEnums,
        relationships: graph.links.length,
        anchors: [...outSet].filter((t) => inSet.has(t)).length,
      };
      graph._metrics = metrics;
      logPhase('summary', metrics);
      return graph;
    }

    function computeDbStats(index) {
      if (!(index instanceof Map)) {
        return {
          tokens: 0,
          edges: 0,
          relationships: 0,
          nodes: 0,
          anchors: 0,
          minEdges: { count: 0, tokens: [] },
          maxEdges: { count: 0, tokens: [] },
        };
      }

      const outSet = new Set();
      const inSet = new Set();
      let relInstances = 0;
      let edgeTypeEnums = 0;
      let minEdgeCount = Infinity;
      let maxEdgeCount = 0;
      const minEdgeTokens = new Set();
      const maxEdgeTokens = new Set();

      for (const [src, rec] of index) {
        if (!rec || typeof rec !== 'object') continue;
        const rels = rec.relationships || {};
        let srcHasType = 0;
        let srcEdgeCount = 0;
        for (const [rtype, arr] of Object.entries(rels)) {
          if (!Array.isArray(arr) || arr.length === 0) continue;
          srcHasType += 1;
          srcEdgeCount += arr.length;
          for (const rel of arr) {
            const tgt = rel?.token;
            if (!tgt) continue;
            relInstances += 1;
            outSet.add(src);
            inSet.add(tgt);
          }
        }
        edgeTypeEnums += srcHasType;

        if (srcEdgeCount < minEdgeCount) {
          minEdgeCount = srcEdgeCount;
          minEdgeTokens.clear();
          minEdgeTokens.add(src);
        } else if (srcEdgeCount === minEdgeCount) {
          minEdgeTokens.add(src);
        }

        if (srcEdgeCount > maxEdgeCount) {
          maxEdgeCount = srcEdgeCount;
          maxEdgeTokens.clear();
          maxEdgeTokens.add(src);
        } else if (srcEdgeCount === maxEdgeCount) {
          maxEdgeTokens.add(src);
        }
      }

      const tokens = index.size;
      const anchors = [...outSet].filter((t) => inSet.has(t)).length;

      if (minEdgeCount === Infinity) {
        minEdgeCount = 0;
      }

      const limitTokenList = (set) => {
        if (!(set instanceof Set) || set.size === 0) return [];
        const out = [];
        for (const token of set) {
          out.push(token);
          if (out.length >= 50) break;
        }
        return out;
      };

      return {
        tokens,
        edges: edgeTypeEnums,
        relationships: relInstances,
        nodes: outSet.size,
        anchors,
        minEdges: {
          count: minEdgeCount,
          tokens: limitTokenList(minEdgeTokens),
        },
        maxEdges: {
          count: maxEdgeCount,
          tokens: limitTokenList(maxEdgeTokens),
        },
      };
    }

    function ensureGraphMetrics(graph) {
      if (!graph) {
        return { nodes: 0, relationships: 0, anchors: 0, edges: 0 };
      }
      if (graph._metrics && typeof graph._metrics === 'object') return graph._metrics;
      const out = new Set();
      const inn = new Set();
      const links = Array.isArray(graph.links)
        ? graph.links
        : (Array.isArray(graph.edges) ? graph.edges : []);
      const edgeTypes = new Set();
      const triples = new Set();
      for (const edge of links) {
        if (edge?.from) out.add(edge.from);
        if (edge?.to) inn.add(edge.to);
        if (edge?.from && edge?.rtype) edgeTypes.add(`${edge.from}|${edge.rtype}`);
        if (edge?.from && edge?.to && edge?.rtype) triples.add(`${edge.from}|${edge.rtype}|${edge.to}`);
      }
      const anchors = [...out].filter((t) => inn.has(t)).length;
      return {
        nodes: out.size,
        relationships: triples.size || links.length,
        anchors,
        edges: edgeTypes.size || links.length,
      };
    }

    function microtask() {
      return new Promise(resolve => queueMicrotask(resolve));
    }

    function activeRelationTypes(index, scope, stateRelTypes) {
      const cap = clampRelationTypeCap(window.HLSF?.config?.relationTypeCap);
      if (scope === 'state' && stateRelTypes && Number.isFinite(stateRelTypes.maxPresent)) {
        return Math.min(cap, Math.max(0, stateRelTypes.maxPresent | 0));
      }
      return cap;
    }

    function nonEmptyTypes(index) {
      const has = new Set();
      if (index instanceof Map) {
        for (const [, rec] of index) {
          const rels = rec?.relationships;
          if (!rels || typeof rels !== 'object') continue;
          for (const [rtype, arr] of Object.entries(rels)) {
            if (Array.isArray(arr) && arr.length) has.add(rtype);
          }
        }
      }
      return [...has].sort((a, b) => a.localeCompare(b));
    }

    function computeDimension(index, scope, stateRelTypes) {
      const types = nonEmptyTypes(index);
      const Treq = activeRelationTypes(index, scope, stateRelTypes);
      const limited = types.slice(0, Math.max(0, Treq));
      return { D: 2 * limited.length, types: limited };
    }

    function degrees(rec) {
      let out = 0;
      let in_ = 0;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          out += 1;
          for (const rel of arr) {
            in_ += rel?.incoming ? 1 : 0;
          }
        }
      }
      return { out, in_ };
    }

    function signature(rec) {
      const weights = new Map();
      for (const arr of Object.values(rec?.relationships || {})) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const token = rel?.token;
          if (!token) continue;
          const weight = Number.isFinite(rel?.weight)
            ? rel.weight
            : Number.isFinite(rel?.w)
              ? rel.w
              : 1;
          weights.set(token, (weights.get(token) || 0) + weight);
        }
      }
      return weights;
    }

    function cosineSignature(a, b) {
      let dot = 0;
      let na = 0;
      let nb = 0;
      for (const [k, va] of a.entries()) {
        na += va * va;
        const vb = b.get(k) || 0;
        if (vb) dot += va * vb;
      }
      for (const vb of b.values()) nb += vb * vb;
      const denom = Math.sqrt(Math.max(na, 0) * Math.max(nb, 0));
      return denom ? dot / denom : 0;
    }

    function selectAnchors(index, D) {
      if (!(index instanceof Map) || D <= 0) return [];
      const sigs = new Map();
      const tokens = [...index.keys()].sort((a, b) => a.localeCompare(b));
      const allSigs = tokens.map(token => {
        const rec = index.get(token) || {};
        const sig = signature(rec);
        sigs.set(token, sig);
        return [token, sig];
      });
      const sample = allSigs.slice(0, Math.min(512, allSigs.length));
      const scored = tokens.map(token => {
        const rec = index.get(token) || {};
        const { out, in_ } = degrees(rec);
        const freq = Number.isFinite(rec?.frequency)
          ? rec.frequency
          : Number.isFinite(rec?.f)
            ? rec.f
            : Number.isFinite(rec?.freq)
              ? rec.freq
              : 0;
        let ac = 0;
        const sig = sigs.get(token) || new Map();
        for (const [, otherSig] of sample) {
          ac += cosineSignature(sig, otherSig);
        }
        ac /= Math.max(1, sample.length);
        const score = 0.4 * freq + 0.3 * out + 0.2 * in_ + 0.1 * ac;
        return { token, score, out, in_ };
      });
      scored.sort((a, b) => (b.score - a.score) || a.token.localeCompare(b.token));
      return scored.slice(0, D).map(entry => entry.token);
    }

    function clusterToAnchors(index, anchors) {
      const groups = new Map();
      if (!(index instanceof Map) || !Array.isArray(anchors)) return groups;
      const orderedAnchors = [...anchors];
      for (const anchor of orderedAnchors) {
        groups.set(anchor, []);
      }
      if (!orderedAnchors.length) return groups;
      const anchorSigs = new Map(orderedAnchors.map(a => [a, signature(index.get(a) || {})]));
      for (const [token, rec] of index.entries()) {
        if (anchorSigs.has(token)) continue;
        const sig = signature(rec || {});
        let best = orderedAnchors[0];
        let bestScore = -Infinity;
        for (const anchor of orderedAnchors) {
          const c = cosineSignature(sig, anchorSigs.get(anchor) || new Map());
          if (c > bestScore) {
            bestScore = c;
            best = anchor;
          }
        }
        groups.get(best).push(token);
      }
      for (const [anchor, list] of groups) {
        list.sort((a, b) => a.localeCompare(b));
      }
      return groups;
    }

    function packLevels(index, scope, state) {
      const stateRelTypes = state?.relationTypes || {};
      const { D, types } = computeDimension(index, scope, stateRelTypes);
      const tokensCount = scope === 'state'
        ? (state?.tokens instanceof Set ? state.tokens.size : index.size)
        : index.size;
      const anchors = selectAnchors(index, Math.min(D || tokensCount, tokensCount));
      const effectiveD = Math.min(D, Math.max(anchors.length, 0));
      const levels = [];
      levels.push({ cells: [{ anchor: null, tokens: anchors.slice(0, Math.min(effectiveD || anchors.length, anchors.length)) }] });

      if (!effectiveD || tokensCount <= effectiveD) {
        return { D, effectiveD: Math.min(tokensCount, effectiveD), levels, anchors, types };
      }

      const clusters = clusterToAnchors(index, anchors);
      const cells = [];
      for (const anchor of anchors) {
        const list = clusters.get(anchor) || [];
        const combined = [anchor, ...list];
        const cellTokens = combined.slice(0, effectiveD || combined.length);
        cells.push({ anchor, tokens: cellTokens });
      }
      levels.push({ cells });

      const pool = [];
      for (const anchor of anchors) {
        const list = clusters.get(anchor) || [];
        const combined = [anchor, ...list];
        if (combined.length > (effectiveD || combined.length)) {
          pool.push(...combined.slice(effectiveD));
        }
      }

      if (pool.length) {
        const L2cells = [];
        const span = Math.max(1, effectiveD || 1);
        const blocks = Math.ceil(pool.length / span);
        for (let i = 0; i < blocks; i++) {
          const anchor = cells[i % cells.length]?.anchor ?? null;
          const start = i * span;
          const slice = pool.slice(start, start + span);
          if (!slice.length) continue;
          L2cells.push({ anchor, tokens: slice });
        }
        if (L2cells.length) levels.push({ cells: L2cells });
      }

      return { D, effectiveD, levels, anchors, types };
    }

    function layoutPolygon(tokens, angles, radius, levelIndex) {
      const tau = Math.PI * 2;
      const out = [];
      if (!Array.isArray(tokens) || !tokens.length) return out;
      const useAngles = Array.isArray(angles) && angles.length ? angles : tokens.map((_, i) => (tau * i) / Math.max(1, tokens.length));
      for (let i = 0; i < tokens.length; i++) {
        const angle = useAngles[i % useAngles.length];
        const normAngle = normalizeAngle(angle);
        out.push({ token: tokens[i], angle: normAngle, radius, level: levelIndex, cellIndex: 0 });
      }
      return out;
    }

    function layoutSectorPolygon(tokens, baseAngle, sectorSpan, radius, levelIndex, cellIndex) {
      const tau = Math.PI * 2;
      const out = [];
      if (!Array.isArray(tokens) || !tokens.length) return out;
      if (tokens.length === 1) {
        out.push({ token: tokens[0], angle: normalizeAngle(baseAngle), radius, level: levelIndex, cellIndex });
        return out;
      }
      const step = sectorSpan / Math.max(tokens.length, 1);
      const start = baseAngle - (sectorSpan / 2) + step / 2;
      for (let i = 0; i < tokens.length; i++) {
        const angle = normalizeAngle(start + i * step);
        out.push({ token: tokens[i], angle, radius, level: levelIndex, cellIndex });
      }
      return out;
    }

    function normalizeAngle(angle) {
      const tau = Math.PI * 2;
      let a = angle % tau;
      if (a < 0) a += tau;
      return a;
    }

    function computeActiveAngles(types) {
      const count = Math.max(0, types.length * 2);
      if (!count) return [];
      const tau = Math.PI * 2;
      const step = tau / count;
      return Array.from({ length: count }, (_, i) => normalizeAngle(i * step));
    }

    function placeLevels(levels, effectiveD, activeAngles) {
      const positions = new Map();
      const cellsGeom = [];
      const placed = new Set();
      const anchorAngles = new Map();
      const levelCount = Array.isArray(levels) ? levels.length : 0;
      const tau = Math.PI * 2;
      let maxRadius = 0;

      if (!levelCount) {
        return { positions, cells: cellsGeom, maxRadius: 0, anchorAngles };
      }

      const first = levels[0]?.cells?.[0]?.tokens || [];
      const radius0 = 1;
      const l0 = layoutPolygon(first, activeAngles.slice(0, first.length), radius0, 0);
      maxRadius = Math.max(maxRadius, radius0);
      const cell0 = [];
      for (let i = 0; i < l0.length; i++) {
        const entry = l0[i];
        if (!positions.has(entry.token)) {
          positions.set(entry.token, entry);
          placed.add(entry.token);
          anchorAngles.set(entry.token, entry.angle);
        }
        cell0.push(entry);
      }
      cellsGeom.push({ level: 0, index: 0, anchor: null, tokens: cell0 });

      for (let levelIndex = 1; levelIndex < levelCount; levelIndex++) {
        const level = levels[levelIndex];
        const cells = Array.isArray(level?.cells) ? level.cells : [];
        const isLast = levelIndex === levelCount - 1;
        const radius = levelIndex + 1;
        maxRadius = Math.max(maxRadius, radius);
        const components = isLast ? cells.length : Math.max(activeAngles.length, cells.length, 1);
        const step = components ? tau / components : tau;
        for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
          const cell = cells[cellIndex];
          const anchor = cell?.anchor ?? null;
          let baseAngle;
          if (isLast) {
            baseAngle = cellIndex * step;
          } else if (levelIndex === 1 && anchor != null && anchorAngles.has(anchor)) {
            baseAngle = anchorAngles.get(anchor);
          } else if (activeAngles.length) {
            baseAngle = activeAngles[cellIndex % activeAngles.length];
          } else {
            baseAngle = cellIndex * step;
          }
          const tokens = Array.isArray(cell?.tokens) ? cell.tokens : [];
          const fresh = tokens.filter(token => !placed.has(token));
          const sectorSpan = step;
          const placedEntries = layoutSectorPolygon(fresh, baseAngle, sectorSpan, radius, levelIndex, cellIndex);
          for (const entry of placedEntries) {
            positions.set(entry.token, entry);
            placed.add(entry.token);
          }
          const geomTokens = tokens.map(token => {
            const existing = positions.get(token);
            if (existing) {
              return Object.assign({}, existing, { cellIndex });
            }
            const angle = normalizeAngle(baseAngle);
            return { token, angle, radius, level: levelIndex, cellIndex };
          });
          cellsGeom.push({ level: levelIndex, index: cellIndex, anchor, tokens: geomTokens });
        }
      }

      return { positions, cells: cellsGeom, maxRadius, anchorAngles };
    }

    function computeLayout(graph, index, options = {}) {
      if (!graph) return { nodes: 0, edges: 0 };
      const idx = index instanceof Map ? index : window.HLSF?.lastCommand?.idx;
      const baseIndex = idx instanceof Map ? idx : new Map();
      const config = window.HLSF?.config || {};
      const desiredScope = (options?.scope || config.hlsfScope || 'db').toLowerCase();
      let scope = desiredScope === 'state' ? 'state' : 'db';

      const sessionTokens = window.Session?.tokens instanceof Set ? window.Session.tokens : new Set();
      const scopedTokens = new Set();
      if (scope === 'state') {
        for (const token of sessionTokens) {
          if (baseIndex.has(token)) scopedTokens.add(token);
        }
        if (!scopedTokens.size) scope = 'db';
      }

      let scopedIndex;
      if (scope === 'state') {
        scopedIndex = new Map();
        for (const token of scopedTokens) {
          scopedIndex.set(token, baseIndex.get(token));
        }
      } else {
        scopedIndex = baseIndex;
        for (const token of baseIndex.keys()) scopedTokens.add(token);
      }

      if (!(scopedIndex instanceof Map) || scopedIndex.size === 0) {
        scopedIndex = baseIndex;
        for (const token of baseIndex.keys()) scopedTokens.add(token);
      }

      const typeList = nonEmptyTypes(scopedIndex);
      const packed = packLevels(scopedIndex, scope, { relationTypes: { maxPresent: typeList.length }, tokens: scopedTokens });
      const activeAngles = computeActiveAngles(packed.types || []);
      const placed = placeLevels(packed.levels, packed.effectiveD, activeAngles);
      const metrics = computeDbStats(scopedIndex);

      const positions = placed.positions;
      const ensurePosition = (token) => {
        if (positions.has(token)) return;
        const radius = (placed.maxRadius || 1) + 1;
        positions.set(token, { token, angle: 0, radius, level: packed.levels.length, cellIndex: 0 });
      };
      for (const token of scopedIndex.keys()) ensurePosition(token);

      const newNodes = new Map();
      for (const [token, rec] of scopedIndex.entries()) {
        const node = graph.nodes.get(token) || {};
        const freq = Number.isFinite(rec?.frequency)
          ? rec.frequency
          : Number.isFinite(rec?.f)
            ? rec.f
            : Number.isFinite(rec?.freq)
              ? rec.freq
              : node.f;
        node.token = token;
        if (Number.isFinite(freq)) node.f = freq;
        const pos = positions.get(token);
        if (pos) {
          node.layer = pos.level;
          node.cluster = pos.cellIndex;
        }
        newNodes.set(token, node);
      }
      graph.nodes = newNodes;

      const levelCount = Array.isArray(packed.levels) ? packed.levels.length : 0;
      const lastLevelComponents = levelCount ? (packed.levels[levelCount - 1]?.cells?.length || 0) : 0;
      const layout = {
        scope,
        dimension: packed.D,
        effectiveDimension: packed.effectiveD,
        anchors: packed.anchors,
        levels: packed.levels,
        cells: placed.cells,
        activeAngles,
        positions,
        maxRadius: placed.maxRadius || levelCount || 1,
        anchorAngles: placed.anchorAngles,
        metrics,
        levelCount,
        lastLevelComponents,
        types: packed.types,
      };

      graph.dimensionLayout = layout;
      graph.anchors = Array.isArray(packed.anchors) ? packed.anchors : graph.anchors;
      graph._metrics = metrics;

      const linkCount = Array.isArray(graph.links)
        ? graph.links.length
        : (Array.isArray(graph.edges) ? graph.edges.length : 0);
      return {
        nodes: newNodes.size,
        edges: linkCount,
        layout,
        metrics,
      };
    }

    function prepareBuffers(graph, layout, options = {}) {
      const glyphOnly = options?.glyphOnly === true;
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly;
      window.HLSF.currentLayoutSnapshot = layout;
      if (window.HLSF?.state) {
        window.HLSF.state.patches = new Map();
        window.HLSF.state.emergentRot = 0;
      }
    }

    function anchorsForMode(args, idx){
      let index = idx;
      if (!(index instanceof Map)) {
        const db = getDb();
        if (!db) throw new Error('No DB loaded');
        loadGlyphMaps(db);
        index = buildIndex(db);
      }

      if (args.mode === 'conversation') {
        const conv = [...(Session?.tokens || [])].filter(t => index.has(t));
        const anchors = conv.length ? conv : defaultAnchors(index, 32);
        return { anchors, idx: index };
      }

      if (args.mode === 'tokens') {
        let anchors = args.tokens.filter(t => index.has(t));
        if (!anchors.length) anchors = defaultAnchors(index, 32);
        return { anchors, idx: index };
      }

      if (args.mode === 'glyphs') {
        const glyphTokens = [];
        for (const glyph of args.glyphs) {
          const val = GlyphToToken.get(glyph);
          if (!val) continue;
          if (val instanceof Set) glyphTokens.push(...val);
          else if (Array.isArray(val)) glyphTokens.push(...val);
          else glyphTokens.push(val);
        }
        const toks = glyphTokens.filter(t => index.has(t));
        const anchors = toks.length ? toks : defaultAnchors(index, 32);
        return { anchors, idx: index, glyphOnly: true };
      }

      const cap = getAnchorCap(index);
      const limit = cap > 0 ? cap : index.size;
      return { anchors: defaultAnchors(index, limit), idx: index };
    }

    function nodeLabel(token, glyphOnly = false) {
      const glyph = TokenToGlyph.get(token);
      if (glyphOnly && glyph) return glyph;
      return glyph || token;
    }

    function edgeLabel(rtype) {
      if (typeof rtype !== 'string') return '';
      const cleaned = rtype.trim();
      if (!cleaned) return '';

      const normalized = normRelKey(cleaned);
      if (normalized) return REL_EN[normalized] || '';

      const withoutGlyph = cleaned.replace(/^[\p{S}\p{P}]+\s*/u, '');
      return withoutGlyph || cleaned;
    }

    function legacyPositions(graph, width, height, scale, centerX, centerY) {
      const anchorList = Array.isArray(graph?.anchors) && graph.anchors.length
        ? graph.anchors
        : Array.isArray(graph?.seeds) && graph.seeds.length
          ? graph.seeds
          : [...graph.nodes.keys()].slice(0, 1);
      const pos = new Map();
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;
      const Rc = Math.min(width, height) * 0.35 * scale;
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;

      anchorList.forEach((token, idx) => {
        const angle = (idx / Math.max(1, anchorList.length)) * Math.PI * 2 + rotation;
        const x = cx + Rc * Math.cos(angle);
        const y = cy + Rc * Math.sin(angle);
        pos.set(token, { x, y });
      });

      const groupByRoot = new Map();
      const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
      edges.forEach(edge => {
        if (!groupByRoot.has(edge.from)) groupByRoot.set(edge.from, []);
        groupByRoot.get(edge.from).push(edge);
      });

      for (const [root, edges] of groupByRoot.entries()) {
        const base = pos.get(root) || { x: cx, y: cy };
        const R = Math.min(width, height) * 0.18 * scale;
        const sorted = [...edges].sort((a, b) => b.w - a.w);
        const denom = Math.max(1, sorted.length - 1);
        sorted.forEach((edge, i) => {
          const theta = Math.PI * (i / denom);
          const x = base.x + R * Math.cos(theta);
          const y = base.y - R * Math.sin(theta);
          if (!pos.has(edge.to)) pos.set(edge.to, { x, y });
        });
      }

      return pos;
    }

    function clusterLevelLayout(graph, width, height, scale, centerX, centerY) {
      const rot = window.HLSF.state?.globalRot || 0;
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;
      let Lmax = 0;
      for (const node of graph.nodes.values()) {
        const layer = node?.layer;
        if (Number.isFinite(layer)) Lmax = Math.max(Lmax, layer | 0);
      }

      const layerCluster = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        const arr = layerCluster.get(key) || [];
        arr.push(token);
        layerCluster.set(key, arr);
      }

      const layers = Array.from({ length: Lmax + 1 }, () => new Map());
      for (const [key, toks] of layerCluster.entries()) {
        const [layerStr, clusterStr] = key.split(':');
        const layer = Number(layerStr) || 0;
        const cluster = Number(clusterStr) || 0;
        const bucket = layers[layer];
        toks.sort();
        bucket.set(cluster, toks);
      }

      const Rmax = Math.min(width, height) * 0.45 * scale;
      const dr = Rmax / Math.max(1, Lmax + 1);
      const pos = new Map();

      for (let layer = 0; layer < layers.length; layer++) {
        const entries = [...layers[layer].entries()]
          .sort((a, b) => b[1].length - a[1].length || a[0] - b[0]);
        const R = Math.max(20, dr * (layer + 1));
        const sectors = Math.max(1, entries.length);
        for (let s = 0; s < entries.length; s++) {
          const tokens = entries[s][1];
          const phi0 = rot + (s / sectors) * Math.PI * 2;
          const span = (Math.PI * 2) / sectors;
          const N = tokens.length;
          for (let i = 0; i < N; i++) {
            const theta = phi0 + (i / Math.max(1, N)) * span;
            const wobble = i % 2 ? 0.92 : 0.98;
            const r = R * wobble;
            pos.set(tokens[i], {
              x: cx + r * Math.cos(theta),
              y: cy + r * Math.sin(theta)
            });
          }
        }
      }
      return pos;
    }

    function ringPositions(graph, width, height, scale, centerX, centerY) {
      const cx = Number.isFinite(centerX) ? centerX : width / 2;
      const cy = Number.isFinite(centerY) ? centerY : height / 2;
      let L = 0;
      for (const node of graph.nodes.values()) {
        const rawLayer = node && Number.isFinite(node.layer) ? node.layer : 0;
        const layer = Math.max(0, Math.floor(rawLayer));
        if (layer > L) L = layer;
      }

      const rings = Array.from({ length: L + 1 }, () => []);
      for (const [token, node] of graph.nodes.entries()) {
        const layer = node && Number.isFinite(node.layer)
          ? Math.max(0, Math.floor(node.layer))
          : 0;
        rings[layer].push({ token, node });
      }

      for (const ring of rings) {
        ring.sort((a, b) => ((b.node?.degree || 0) - (a.node?.degree || 0)) || a.token.localeCompare(b.token));
      }

      const Rmax = Math.min(width, height) * 0.42 * scale;
      const dr = Rmax / Math.max(1, L + 1);
      const pos = new Map();
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;

      for (let layer = 0; layer < rings.length; layer++) {
        const ring = rings[layer];
        if (!ring.length) continue;
        const R = Math.max(20, dr * (layer + 1));
        const N = ring.length;
        for (let i = 0; i < N; i++) {
          const theta = (i / N) * 2 * Math.PI + rotation;
          pos.set(ring[i].token, {
            x: cx + R * Math.cos(theta),
            y: cy + R * Math.sin(theta)
          });
        }
      }

      return pos;
    }

    function drawClusterOverlays(ctx, graph, positions) {
      const byLC = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        const arr = byLC.get(key) || [];
        arr.push(token);
        byLC.set(key, arr);
      }
      ctx.save();
      for (const [key, tokens] of byLC) {
        if (tokens.length < 3) continue;
        const pts = tokens.map(t => positions.get(t)).filter(Boolean);
        if (pts.length < 3) continue;
        const color = paletteColor(`cluster-${key}`);
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawComposite(graph, opts = {}) {
      const cfg = window.HLSF.config;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found');
        return;
      }
      const ctx = window.HLSF.ctx || (window.HLSF.ctx = canvas.getContext('2d'));
      const dpr = window.devicePixelRatio || 1;
      const displayWidth = canvas.clientWidth || canvas.width || 0;
      const displayHeight = canvas.clientHeight || canvas.height || 0;
      const bufferWidth = Math.max(1, Math.round(displayWidth * dpr));
      const bufferHeight = Math.max(1, Math.round(displayHeight * dpr));
      if (canvas.width !== bufferWidth || canvas.height !== bufferHeight) {
        canvas.width = bufferWidth;
        canvas.height = bufferHeight;
      }
      const width = displayWidth || canvas.width / dpr;
      const height = displayHeight || canvas.height / dpr;
      const theme = cfg.whiteBg
        ? { bg: '#fff', fg: '#000', hint: '#444' }
        : { bg: '#000', fg: '#fff', hint: '#bbb' };
      const edgeColorMode = normalizeEdgeColorMode(cfg.edgeColorMode);
      const edgeWidthControl = document.getElementById('edgew');
      const edgeWidth = clampEdgeWidth(cfg.edgeWidth);
      const nodeScale = clampNodeSize(cfg.nodeSize);
      const showGlow = cfg.showNodeGlow === true;

      if (!window.HLSF.__centerInit) {
        window.HLSF.view.x = width / 2;
        window.HLSF.view.y = height / 2;
        syncViewToConfig();
        window.HLSF.__centerInit = true;
      }

      syncViewToConfig();
      const view = window.HLSF.view;
      const zoom = Number.isFinite(view.scale) ? view.scale : 1;

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.translate(view.x, view.y);
      ctx.scale(zoom, zoom);
      ctx.strokeStyle = theme.fg;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const controlValue = edgeWidthControl ? parseFloat(edgeWidthControl.value) : NaN;
      const edgeWidthValue = Number.isFinite(controlValue) ? controlValue : edgeWidth;
      const safeZoom = Math.max(zoom, 1e-4);
      const zoomAttenuation = Math.max(0.2, Math.min(5, 1 / Math.sqrt(safeZoom)));
      ctx.lineWidth = Math.max(0.01, edgeWidthValue * zoomAttenuation) * dpr;
      const fontScale = Math.max(0.35, Math.min(3, zoomAttenuation));
      ctx.font = `${Math.max(9, Math.round(12 * fontScale))}px 'Fira Code', monospace`;

      const layoutScale = 1;
      const layoutMode = normalizeLayout(window.HLSF.config.layout);
      let pos;
      if (layoutMode === 'dimension' && graph.dimensionLayout) {
        const dim = graph.dimensionLayout;
        const radialMax = Math.max(1, dim.maxRadius || 1);
        const radiusScale = Math.min(width, height) * 0.42 * layoutScale;
        pos = new Map();
        for (const [token, entry] of dim.positions.entries()) {
          const radius = (entry?.radius || 1) / radialMax * radiusScale;
          const angle = entry?.angle || 0;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          pos.set(token, { x, y });
        }
      } else if (layoutMode === 'affinity') {
        pos = clusterLevelLayout(graph, width, height, layoutScale, 0, 0);
      } else if (layoutMode === 'layered') {
        pos = ringPositions(graph, width, height, layoutScale, 0, 0);
      } else {
        pos = legacyPositions(graph, width, height, layoutScale, 0, 0);
      }

      const patches = computePatches(graph, pos);
      window.HLSF.state.patches = patches;
      const rotatedPositions = new Map();
      for (const [token, base] of pos.entries()) {
        const node = graph.nodes.get(token);
        rotatedPositions.set(token, rotatedPos(token, base, node));
      }

      if (layoutMode === 'affinity') {
        drawClusterOverlays(ctx, graph, rotatedPositions);
      }

      if (layoutMode === 'dimension' && graph.dimensionLayout) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        const polyWidth = Math.max(0.01, Math.min(1, edgeWidthValue * zoomAttenuation)) * dpr;
        ctx.lineWidth = polyWidth;
        ctx.strokeStyle = theme.hint;
        const cells = Array.isArray(graph.dimensionLayout.cells) ? graph.dimensionLayout.cells : [];
        for (const cell of cells) {
          const tokens = Array.isArray(cell?.tokens) ? cell.tokens : [];
          const pts = tokens
            .map(t => rotatedPositions.get(t.token))
            .filter(Boolean);
          if (pts.length < 3) continue;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          ctx.closePath();
          ctx.stroke();
        }
        ctx.restore();
      }

      const glyphOnly = opts.glyphOnly === true;

      ctx.lineWidth = Math.max(0.01, edgeWidthValue * zoomAttenuation) * dpr;

      if (cfg.showEdges !== false) {
        const batches = new Map();
        const edges = Array.isArray(graph.links) ? graph.links : Array.isArray(graph.edges) ? graph.edges : [];
        for (const edge of edges) {
          const fromPos = rotatedPositions.get(edge.from) || rotatedPositions.get(edge.to);
          const toPos = rotatedPositions.get(edge.to);
          if (!fromPos || !toPos) continue;
          const viewScale = window.HLSF?.view?.scale ?? zoom;
          const dx = (toPos.x - fromPos.x) * viewScale;
          const dy = (toPos.y - fromPos.y) * viewScale;
          if ((dx * dx + dy * dy) < 0.25) continue;
          const strokeColor = compositeEdgeStrokeColor(edge, edgeColorMode) || theme.fg;
          if (!batches.has(strokeColor)) batches.set(strokeColor, []);
          batches.get(strokeColor).push({ from: fromPos, to: toPos, edge });
        }
        for (const [color, edges] of batches.entries()) {
          ctx.strokeStyle = color;
          for (const { from, to, edge } of edges) {
            ctx.globalAlpha = edgeAlphaFromWeight(edge.w);
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
            if (cfg.showLabels !== false) {
              const mx = (from.x + to.x) / 2;
              const my = (from.y + to.y) / 2;
              ctx.globalAlpha = baseAlpha();
              const glyph = edgeLabel(edge.rtype);
              if (glyph) {
                ctx.fillStyle = theme.hint;
                ctx.fillText(glyph, mx, my - 10);
              }
              const hiddenTokens = Array.isArray(edge.hiddenTokens) ? edge.hiddenTokens : [];
              if (hiddenTokens.length) {
                const preview = hiddenTokens.slice(0, 3);
                let hiddenLabel = preview.join(', ');
                const remaining = hiddenTokens.length - preview.length;
                if (remaining > 0) hiddenLabel += ` +${remaining}`;
                if (hiddenLabel) {
                  const dx = to.x - from.x;
                  const dy = to.y - from.y;
                  const dist = Math.hypot(dx, dy) || 1;
                  const offset = 16;
                  const hx = to.x + (dx / dist) * offset;
                  const hy = to.y + (dy / dist) * offset;
                  ctx.globalAlpha = baseAlpha() * 0.75;
                  ctx.fillStyle = cfg.whiteBg ? 'rgba(0,0,0,0.45)' : 'rgba(255,255,255,0.45)';
                  ctx.fillText(hiddenLabel, hx, hy);
                  ctx.globalAlpha = baseAlpha();
                }
              }
              ctx.fillStyle = theme.fg;
            }
          }
        }
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = theme.fg;
      }

      for (const [token, data] of graph.nodes.entries()) {
        const position = rotatedPositions.get(token);
        if (!position) continue;
        const freq = typeof data.f === 'number' ? data.f : 1;
        const radius = Math.max(2, (4 + 2 * Math.log2(1 + Math.max(0, freq))) * nodeScale);
        ctx.globalAlpha = baseAlpha();
        ctx.save();
        if (showGlow) {
          ctx.shadowColor = 'rgba(0, 255, 136, 0.35)';
          ctx.shadowBlur = 14 * Math.max(1, zoom);
        }
        ctx.beginPath();
        ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        ctx.globalAlpha = 1.0;
        if (cfg.showLabels !== false) {
          ctx.globalAlpha = baseAlpha();
          ctx.fillStyle = theme.fg;
          ctx.fillText(nodeLabel(token, glyphOnly), position.x, position.y - (radius + 12));
          ctx.globalAlpha = 1.0;
        }
      }

      ctx.restore();
    }

    function computePatches(graph, pos) {
      const groups = new Map();
      for (const [token, node] of graph.nodes) {
        const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
        const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
        const key = `${layer}:${cluster}`;
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(token);
      }
      const patches = new Map();
      const prev = window.HLSF?.state?.patches;
      for (const [key, toks] of groups) {
        const pts = toks.map(t => pos.get(t)).filter(Boolean);
        if (!pts.length) continue;
        const cx = pts.reduce((sum, p) => sum + p.x, 0) / pts.length;
        const cy = pts.reduce((sum, p) => sum + p.y, 0) / pts.length;
        const prevPatch = prev instanceof Map ? prev.get(key) : null;
        const angle = prevPatch && Number.isFinite(prevPatch.angle) ? prevPatch.angle : 0;
        patches.set(key, { cx, cy, angle });
      }
      return patches;
    }

    function rotate_patches(dt) {
      const state = window.HLSF?.state;
      if (!state?.emergent?.on) return;
      const speed = Number.isFinite(state.emergent.speed) ? state.emergent.speed : 0;
      if (!speed) return;
      const patches = state.patches instanceof Map ? state.patches : null;
      if (!patches) return;
      const tau = Math.PI * 2;
      for (const patch of patches.values()) {
        const current = Number.isFinite(patch?.angle) ? patch.angle : 0;
        patch.angle = (current + speed * dt) % tau;
      }
    }

    function rotatedPos(token, basePos, node) {
      if (!basePos) return basePos;
      const state = window.HLSF?.state;
      if (!state?.emergent?.on) return basePos;
      const layer = Number.isFinite(node?.layer) ? (node.layer | 0) : 0;
      const cluster = Number.isFinite(node?.cluster) ? (node.cluster | 0) : 0;
      const patchKey = `${layer}:${cluster}`;
      const patch = state.patches instanceof Map ? state.patches.get(patchKey) : null;
      if (!patch) return basePos;
      const angle = Number.isFinite(patch.angle) ? patch.angle : 0;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const x = basePos.x - patch.cx;
      const y = basePos.y - patch.cy;
      return { x: patch.cx + c * x - s * y, y: patch.cy + s * x + c * y };
    }

    // ---------------- O20 layout ----------------
    function buildO20Layout(width, height, margin = 32) {
      const cx = width / 2;
      const cy = height / 2;
      const R = Math.min(cx, cy) - margin;
      const slots = [];
      for (let i = 0; i < 20; i++) {
        const theta = Math.PI * (i / 19);
        slots.push({
          x: cx + R * Math.cos(theta),
          y: cy - R * Math.sin(theta),
          theta
        });
      }
      return { cx, cy, R, slots };
    }

    function getCachedO20Layout(width, height, margin = 32) {
      window.HLSF = window.HLSF || {};
      const cache = window.HLSF.layoutCache;
      if (cache && cache.width === width && cache.height === height && cache.margin === margin) {
        return cache.layout;
      }
      const layout = buildO20Layout(width, height, margin);
      window.HLSF.layoutCache = { width, height, margin, layout };
      return layout;
    }

    function applyFrequencyVisuals(f) {
      const value = typeof f === 'number' ? f : 0;
      const stats = window.HLSF?.metrics?.freqStats;
      if (!stats || typeof stats.min !== 'number' || typeof stats.max !== 'number') {
        const clamped = Math.min(1, Math.max(0, value));
        return { norm: clamped, isHigh: value >= 1 };
      }
      const range = stats.max - stats.min;
      const norm = range === 0 ? 0 : (value - stats.min) / range;
      const clamped = Math.min(1, Math.max(0, norm));
      const threshold = typeof stats.p90 === 'number' ? stats.p90 : stats.max;
      return { norm: clamped, isHigh: value >= threshold };
    }

    // ---------------- Canvas renderer ----------------
    function drawHLSFMatrix(graph, opts = {}) {
      drawComposite(graph, opts);
    }

    let _anim = null;
    function animateComposite(graph, glyphOnly = false) {
      if (!graph) return;
      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawComposite(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function animateHLSF(graph, glyphOnly = false) {
      if (!graph) return;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found for animation');
        return;
      }

      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawHLSFMatrix(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function stopHLSFAnimation() {
      if (_anim) {
        cancelAnimationFrame(_anim);
        _anim = null;
      }
      if (window.HLSF) {
        window.HLSF.currentGraph = null;
        window.HLSF.currentGlyphOnly = false;
        window.HLSF.__centerInit = false;
      }
      if (typeof stopLegacyHLSFAnimation === 'function') {
        try {
          stopLegacyHLSFAnimation();
        } catch (err) {
          console.warn('Legacy HLSF animation stop failed:', err);
        }
      }
    }

    const MAX_REL_TYPES = 50;
    const MAX_EDGES_PER_TYPE = 10;

    function clampRelationTypeCap(value) {
      if (value === Infinity) return Infinity;
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (norm === 'all' || norm === '‚àû' || norm === 'infinity') return Infinity;
      }
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return MAX_REL_TYPES;
      if (numeric <= 0) return MAX_REL_TYPES;
      return Math.min(MAX_REL_TYPES, Math.max(1, numeric));
    }

    function clampEdgesPerType(value) {
      if (value === Infinity) return Infinity;
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (norm === 'all' || norm === '‚àû' || norm === 'infinity') return Infinity;
      }
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return 3;
      if (numeric <= 0) return 3;
      return Math.min(MAX_EDGES_PER_TYPE, Math.max(1, numeric));
    }

    function clampEdgeWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0.02;
      return Math.min(1, Math.max(0.01, numeric));
    }

    function clampNodeSize(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1;
      return Math.min(2.5, Math.max(0.5, numeric));
    }

    function normalizeEdgeColorMode(value) {
      switch (value) {
        case 'weight':
        case 'relation':
          return value;
        default:
          return 'theme';
      }
    }

    function normalizeMetricScope(value) {
      if (value === METRIC_SCOPE.DB) return METRIC_SCOPE.DB;
      if (typeof value === 'string' && value.toLowerCase() === METRIC_SCOPE.DB) return METRIC_SCOPE.DB;
      return METRIC_SCOPE.RUN;
    }

    function normalizeLayout(value) {
      const v = typeof value === 'string' ? value.toLowerCase() : value;
      switch (v) {
        case 'dimension':
        case 'affinity':
        case 'layered':
        case 'legacy':
          return v;
        default:
          return 'dimension';
      }
    }

    function layoutLabel(value) {
      switch (normalizeLayout(value)) {
        case 'dimension':
          return 'Dimension NAM';
        case 'affinity':
          return 'Clusters √ó Levels';
        case 'layered':
          return 'Layered';
        case 'legacy':
          return 'Legacy';
        default:
          return 'Dimension NAM';
      }
    }

    function describeAffinityMentalState(threshold, iterations) {
      const thr = Number.isFinite(threshold) ? threshold : 0.35;
      const iters = Number.isFinite(iterations) ? iterations : 8;
      const thrBand = thr <= 0.2 ? 'low'
        : thr <= 0.4 ? 'medium'
        : thr <= 0.6 ? 'high'
        : 'veryHigh';
      const iterBand = iters <= 4 ? 'brief'
        : iters <= 9 ? 'steady'
        : 'extended';

      const STATES = {
        low: {
          brief: {
            name: 'Impulsive ideation',
            desc: 'Weak ties are welcomed but the loop stops quickly, so early, noisy neighbors shape the clusters.'
          },
          steady: {
            name: 'Expansive brainstorming',
            desc: 'Low thresholds keep associative links flowing while a few passes weave them into loose but lively groups.'
          },
          extended: {
            name: 'Hypnagogic free association',
            desc: 'Almost every tenuous link survives repeated revisits, letting clusters blend in a dreamlike drift.'
          }
        },
        medium: {
          brief: {
            name: 'Decisive synthesis',
            desc: 'Moderate evidence is required but only a handful of passes occur, yielding balanced snap decisions.'
          },
          steady: {
            name: 'Focused yet flexible attention',
            desc: 'Clustering balances evidence with patience, producing well-formed communities without overthinking.'
          },
          extended: {
            name: 'Reflective integration',
            desc: 'Moderate filters paired with long deliberation polish clusters through repeated, thoughtful reconciliation.'
          }
        },
        high: {
          brief: {
            name: 'Surgical categorization',
            desc: 'Only strong alignments are heeded and the loop resolves quickly, carving crisp, selective groups.'
          },
          steady: {
            name: 'Structured analytical focus',
            desc: 'Strict similarity demands with measured revisits create tight, compartmentalized communities.'
          },
          extended: {
            name: 'Perfectionistic rumination',
            desc: 'High selectivity and many passes continually prune ambiguous members in search of immaculate boundaries.'
          }
        },
        veryHigh: {
          brief: {
            name: 'Rigid snap judgments',
            desc: 'Only the strongest neighbors are considered and the process halts fast, leaving fragmented results.'
          },
          steady: {
            name: 'Guarded deliberation',
            desc: 'Strict gates with limited revisits keep clusters narrow while cautiously revisiting edge cases.'
          },
          extended: {
            name: 'Tunnel-vision fixation',
            desc: 'Extreme selectivity applied over many rounds replays only the most forceful convictions.'
          }
        }
      };

      const preset = STATES[thrBand] && STATES[thrBand][iterBand]
        ? STATES[thrBand][iterBand]
        : null;
      if (preset) return preset;
      return {
        name: 'Adaptive clustering',
        desc: `Threshold ${thr.toFixed(2)} with ${iters} iteration${iters === 1 ? '' : 's'} blends evidence filtering with iterative refinement.`
      };
    }

    function updateAffinityAnnotations(wrapper, threshold, iterations) {
      if (!wrapper) return;
      const { name, desc } = describeAffinityMentalState(threshold, iterations);
      const nameEl = wrapper.querySelector('#hlsf-mental-name');
      if (nameEl) nameEl.textContent = name;
      const summaryEl = wrapper.querySelector('#hlsf-affinity-summary');
      if (summaryEl) summaryEl.textContent = `Current mental state: ${name}.`;
      const descEl = wrapper.querySelector('#hlsf-mental-desc');
      if (descEl) descEl.textContent = desc;
      const mechanicsEl = wrapper.querySelector('#hlsf-affinity-mechanics');
      if (mechanicsEl) {
        const thr = Number.isFinite(threshold) ? threshold : 0.35;
        const iters = Number.isFinite(iterations) ? iterations : 8;
        const iterWord = iters === 1 ? 'iteration' : 'iterations';
        mechanicsEl.textContent = `Neighbors must score at least ${thr.toFixed(2)} on the 60/40 cosine‚ÄìJaccard affinity mix to influence clustering. The loop will revisit labels for up to ${iters} ${iterWord} before settling.`;
      }
    }

    function ensureHLSFCanvas() {
      let wrapper = document.getElementById('hlsf-canvas-container');
      if (wrapper) {
        if (window.HLSF.config.deferredRender === false) wrapper.classList.remove('hidden');
      } else {
        if (!elements?.log) {
          console.warn('Log element not ready for HLSF canvas');
          return null;
        }

        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;

        wrapper = document.createElement('div');
        wrapper.id = 'hlsf-canvas-container';
        wrapper.className = 'hlsf-canvas-container';
        if (window.HLSF.config.deferredRender !== false) wrapper.classList.add('hidden');
        wrapper.innerHTML = `
          <div class="section-title">üî≠ HLSF Matrix Visualizer</div>
          <details id="hlsf-batch-log" open>
            <summary>Batch log</summary>
            <div id="hlsf-log-progress">
              <div id="hlsf-log-bar"></div>
            </div>
            <pre id="hlsf-log-stream"></pre>
            <button id="hlsf-log-download">Download log</button>
          </details>
          <canvas id="hlsf-canvas"></canvas>
          <div class="hlsf-controls">
            <div class="hlsf-control-group">
              <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
              <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
              <input id="hlsf-alpha" type="range" min="0.005" max="0.99" step="0.01" value="0.70">
            </div>
            <div class="hlsf-control-group">
              <label>Edge width <span id="edgew-val">0.02</span></label>
              <input id="edgew" type="range" min="0.01" max="1.00" step="0.005" value="0.02">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
              <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-color-mode">Edge coloring</label>
              <select id="hlsf-edge-color-mode">
                <option value="theme">Theme</option>
                <option value="weight">Weight</option>
                <option value="relation">Relation</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">${MAX_REL_TYPES}</span></label>
              <input id="hlsf-relation-cap" type="number" min="1" max="${MAX_REL_TYPES}" step="1" value="${MAX_REL_TYPES}">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-scope">Scope</label>
              <select id="hlsf-scope">
                <option value="db">DB</option>
                <option value="state">State</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label>Dimension metrics</label>
              <div class="hlsf-dimension-stats">
                <div>Anchors D: <span id="hlsf-dimension-d">‚Äî</span></div>
                <div>Level count L: <span id="hlsf-dimension-levels">‚Äî</span></div>
                <div>Last level components C: <span id="hlsf-dimension-last">‚Äî</span></div>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
              <input id="hlsf-edges-per-type" type="number" min="1" max="${MAX_EDGES_PER_TYPE}" step="1" value="3">
            </div>
            <div class="hlsf-control-group">
              <label>Display options</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
                <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
                <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
                <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
                <button id="hlsf-toggle-layout" class="btn btn-secondary">Layout: Affinity</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-aff-thresh">Affinity threshold <span id="hlsf-aff-thresh-val">0.35</span></label>
              <input id="hlsf-aff-thresh" type="range" min="0.1" max="0.8" step="0.01" value="0.35">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-aff-iters">Affinity iterations <span id="hlsf-aff-iters-val">8</span></label>
              <input id="hlsf-aff-iters" type="range" min="1" max="20" step="1" value="8">
            </div>
            <div class="hlsf-control-group">
              <em id="hlsf-affinity-summary" class="hlsf-mental-summary">Current mental state: Focused yet flexible attention.</em>
            </div>
            <div class="hlsf-control-group">
              <label>Affinity cognition</label>
              <div id="hlsf-affinity-mental-state" class="hlsf-mental-state">
                <div id="hlsf-mental-name" class="hlsf-mental-name">Focused yet flexible attention</div>
                <div id="hlsf-mental-desc" class="hlsf-mental-desc">Moderate evidence is required and several rounds are permitted, yielding balanced, well-formed communities without excessive rumination.</div>
                <div id="hlsf-affinity-mechanics" class="hlsf-mental-mechanics">Neighbors must score at least 0.35 on the 60/40 cosine‚ÄìJaccard affinity mix to influence clustering. The loop allows up to 8 iterations before settling.</div>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>Rotation modes</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
                <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergence</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>View</label>
              <div class="hlsf-button-row">
                <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
                <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
                <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
                <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
              </div>
            </div>
          </div>
        `;

        entry.appendChild(wrapper);
        elements.log.appendChild(entry);
        elements.log.scrollTop = elements.log.scrollHeight;
        BatchLog.mount();
      }

      const canvas = /** @type {HTMLCanvasElement|null} */ (wrapper.querySelector('#hlsf-canvas'));
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      bindHlsfControls(wrapper);
      syncHlsfControls(wrapper);

      return canvas;
    }

    function bindHlsfControls(wrapper) {
      if (!wrapper || wrapper.dataset.controlsBound === 'true') return;

      const canvas = wrapper.querySelector('#hlsf-canvas');
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      const scopeSelect = wrapper.querySelector('#hlsf-scope');
      if (scopeSelect) {
        scopeSelect.addEventListener('change', () => {
          const value = scopeSelect.value === 'state' ? 'state' : 'db';
          window.HLSF.config.hlsfScope = value;
          if (window.HLSF?.currentGraph && window.HLSF?.lastCommand?.idx) {
            rebuildHlsfFromLastCommand(true);
          } else {
            debouncedLegacyRender();
          }
        });
      }

      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      if (speedSlider && speedVal) {
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }

      const edgeWidthSlider = wrapper.querySelector('#edgew');
      const edgeWidthVal = wrapper.querySelector('#edgew-val');
      if (edgeWidthSlider && edgeWidthVal) {
        edgeWidthSlider.addEventListener('input', (e) => {
          const next = clampEdgeWidth(parseFloat(e.target.value));
          if (!Number.isFinite(next)) return;
          window.HLSF.config.edgeWidth = next;
          edgeWidthVal.textContent = next.toFixed(3);
          if (Math.abs(next - parseFloat(edgeWidthSlider.value)) > 1e-6) {
            edgeWidthSlider.value = next.toFixed(3);
          }
          requestRender();
        });
      }

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      if (nodeSizeSlider && nodeSizeVal) {
        nodeSizeSlider.addEventListener('input', (e) => {
          const next = clampNodeSize(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.nodeSize = next;
          nodeSizeVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(nodeSizeSlider.value)) > 1e-6) {
            nodeSizeSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      if (relationInput) {
        relationInput.addEventListener('input', () => {
          const next = clampRelationTypeCap(relationInput.value);
          window.HLSF.config.relationTypeCap = next;
          relationInput.value = String(next);
          if (relationVal) relationVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      if (edgesInput) {
        edgesInput.addEventListener('input', () => {
          const next = clampEdgesPerType(edgesInput.value);
          window.HLSF.config.edgesPerType = next;
          edgesInput.value = String(next);
          if (edgesVal) edgesVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const thresholdSlider = wrapper.querySelector('#hlsf-aff-thresh');
      const thresholdVal = wrapper.querySelector('#hlsf-aff-thresh-val');
      if (thresholdSlider) {
        thresholdSlider.addEventListener('input', () => {
          const raw = Number(thresholdSlider.value);
          const clamped = Number.isFinite(raw) ? Math.min(0.8, Math.max(0.1, raw)) : 0.35;
          const value = Math.round(clamped * 100) / 100;
          window.HLSF.config.affinity = Object.assign({}, window.HLSF.config.affinity, { threshold: value });
          thresholdSlider.value = value.toFixed(2);
          if (thresholdVal) thresholdVal.textContent = value.toFixed(2);
          const currentIters = window.HLSF.config.affinity?.iterations;
          updateAffinityAnnotations(wrapper, value, Number.isFinite(currentIters) ? currentIters : 8);
          recomputeAndRender();
        });
      }

      const iterSlider = wrapper.querySelector('#hlsf-aff-iters');
      const iterVal = wrapper.querySelector('#hlsf-aff-iters-val');
      if (iterSlider) {
        iterSlider.addEventListener('input', () => {
          const raw = Number(iterSlider.value);
          const value = Number.isFinite(raw) ? Math.min(20, Math.max(1, Math.round(raw))) : 8;
          window.HLSF.config.affinity = Object.assign({}, window.HLSF.config.affinity, { iterations: value });
          iterSlider.value = String(value);
          if (iterVal) iterVal.textContent = String(value);
          const currentThresh = window.HLSF.config.affinity?.threshold;
          updateAffinityAnnotations(wrapper, Number.isFinite(currentThresh) ? currentThresh : 0.35, value);
          recomputeAndRender();
        });
      }

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      if (edgeColorSelect) {
        edgeColorSelect.addEventListener('change', (e) => {
          const value = normalizeEdgeColorMode(e.target.value);
          window.HLSF.config.edgeColorMode = value;
          edgeColorSelect.value = value;
          debouncedLegacyRender();
        });
      }

      const zoomIn = wrapper.querySelector('#hlsf-zoom-in');
      if (zoomIn) {
        zoomIn.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 1.2));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const zoomOut = wrapper.querySelector('#hlsf-zoom-out');
      if (zoomOut) {
        zoomOut.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 0.8));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const reset = wrapper.querySelector('#hlsf-reset-view');
      if (reset) {
        reset.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          window.HLSF.view.scale = 1;
          if (canvasEl) {
            const width = canvasEl.clientWidth || canvasEl.width;
            const height = canvasEl.clientHeight || canvasEl.height;
            window.HLSF.view.x = width / 2;
            window.HLSF.view.y = height / 2;
          } else {
            window.HLSF.view.x = 0;
            window.HLSF.view.y = 0;
          }
          syncViewToConfig();
          requestRender();
        });
      }

      const portal = wrapper.querySelector('#hlsf-zoom-portal');
      if (portal) {
        portal.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          if (!canvasEl) return;
          const width = canvasEl.clientWidth || canvasEl.width;
          const height = canvasEl.clientHeight || canvasEl.height;
          const cx = width / 2;
          const cy = height / 2;
          const target = {
            x: cx,
            y: cy,
            scale: Math.max(1.5, window.HLSF.view.scale * 2),
          };
          animateViewport(target, 350);
        });
      }

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) {
        rotationBtn.addEventListener('click', () => {
          window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
          if (window.HLSF.config.rotationActive) {
            window.HLSF.config.emergentActive = false;
            window.HLSF.state.emergent.on = false;
          }
          syncHlsfControls(wrapper);
          requestRender();
        });
      }

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) {
        emergentBtn.addEventListener('click', () => {
          const state = window.HLSF.state.emergent;
          state.on = !state.on;
          window.HLSF.config.emergentActive = state.on;
          if (state.on) window.HLSF.config.rotationActive = false;
          syncHlsfControls(wrapper);
          requestRender();
        });
      }

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) {
        edgesBtn.addEventListener('click', () => {
          window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
          edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
          debouncedLegacyRender();
        });
      }

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) {
        labelsBtn.addEventListener('click', () => {
          window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
          labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
          debouncedLegacyRender();
        });
      }

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) {
        glowBtn.addEventListener('click', () => {
          window.HLSF.config.showNodeGlow = !window.HLSF.config.showNodeGlow;
          glowBtn.textContent = window.HLSF.config.showNodeGlow ? 'Glow: On' : 'Glow: Off';
          debouncedLegacyRender();
        });
      }

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) {
        bgBtn.addEventListener('click', () => {
          window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
          bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
          debouncedLegacyRender();
        });
      }

      const layoutBtn = wrapper.querySelector('#hlsf-toggle-layout');
      if (layoutBtn) {
        layoutBtn.addEventListener('click', () => {
          const layouts = ['dimension', 'affinity', 'layered', 'legacy'];
          const current = normalizeLayout(window.HLSF.config.layout);
          const index = layouts.indexOf(current);
          const next = layouts[(index + 1) % layouts.length];
          window.HLSF.config.layout = next;
          layoutBtn.textContent = `Layout: ${layoutLabel(next)}`;
          debouncedLegacyRender();
        });
      }

      const canvasEl = wrapper.querySelector('#hlsf-canvas');
      if (canvasEl) {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvasEl.addEventListener('mousedown', (e) => {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvasEl.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.view.x += dx;
          window.HLSF.view.y += dy;
          syncViewToConfig();
          lastX = e.clientX;
          lastY = e.clientY;
          requestRender();
        });

        canvasEl.addEventListener('mouseleave', () => {
          isDragging = false;
        });
      }

      const affinityCfg = window.HLSF.config?.affinity || {};
      const initialThresh = Number.isFinite(affinityCfg.threshold) ? affinityCfg.threshold : 0.35;
      const initialIters = Number.isFinite(affinityCfg.iterations) ? affinityCfg.iterations : 8;
      updateAffinityAnnotations(wrapper, initialThresh, initialIters);

      wrapper.dataset.controlsBound = 'true';
    }

    function syncHlsfControls(wrapper) {
      if (!wrapper) return;

      syncViewToConfig();
      const config = window.HLSF.config || {};
      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      const omega = Number.isFinite(config.rotationOmega) ? config.rotationOmega : 0;
      window.HLSF.config.rotationOmega = omega;
      if (speedSlider) speedSlider.value = omega.toFixed(2);
      if (speedVal) speedVal.textContent = omega.toFixed(2);

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      const alpha = clampAlpha(config.alpha);
      window.HLSF.config.alpha = alpha;
      if (alphaSlider) alphaSlider.value = alpha.toFixed(2);
      if (alphaVal) alphaVal.textContent = alpha.toFixed(2);

      const edgeWidthSlider = wrapper.querySelector('#edgew');
      const edgeWidthVal = wrapper.querySelector('#edgew-val');
      const edgeWidth = clampEdgeWidth(config.edgeWidth);
      window.HLSF.config.edgeWidth = edgeWidth;
      if (edgeWidthSlider) edgeWidthSlider.value = edgeWidth.toFixed(3);
      if (edgeWidthVal) edgeWidthVal.textContent = edgeWidth.toFixed(3);

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      const nodeSize = clampNodeSize(config.nodeSize);
      window.HLSF.config.nodeSize = nodeSize;
      if (nodeSizeSlider) nodeSizeSlider.value = nodeSize.toFixed(1);
      if (nodeSizeVal) nodeSizeVal.textContent = nodeSize.toFixed(1);

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      const relationCapRaw = config.relationTypeCap;
      const relationCap = relationCapRaw === Infinity
        ? Infinity
        : clampRelationTypeCap(relationCapRaw);
      window.HLSF.config.relationTypeCap = relationCap;
      if (relationInput) {
        relationInput.value = relationCap === Infinity ? String(MAX_REL_TYPES) : String(relationCap);
      }
      if (relationVal) relationVal.textContent = relationCap === Infinity ? '‚àû' : String(relationCap);

      const scopeSelect = wrapper.querySelector('#hlsf-scope');
      const normalizedScope = config.hlsfScope === 'state' ? 'state' : 'db';
      window.HLSF.config.hlsfScope = normalizedScope;
      if (scopeSelect) scopeSelect.value = normalizedScope;

      const dimLayout = window.HLSF?.currentGraph?.dimensionLayout || window.HLSF?.currentLayoutSnapshot?.layout || null;
      const dimDSpan = wrapper.querySelector('#hlsf-dimension-d');
      const dimLevelSpan = wrapper.querySelector('#hlsf-dimension-levels');
      const dimLastSpan = wrapper.querySelector('#hlsf-dimension-last');
      if (dimDSpan) dimDSpan.textContent = dimLayout ? String(dimLayout.dimension || 0) : '‚Äî';
      if (dimLevelSpan) dimLevelSpan.textContent = dimLayout ? String(dimLayout.levelCount || 0) : '‚Äî';
      if (dimLastSpan) dimLastSpan.textContent = dimLayout ? String(dimLayout.lastLevelComponents || 0) : '‚Äî';

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      const edgesRaw = config.edgesPerType;
      const edgesPerType = edgesRaw === Infinity
        ? Infinity
        : clampEdgesPerType(edgesRaw);
      window.HLSF.config.edgesPerType = edgesPerType;
      if (edgesInput) {
        edgesInput.value = edgesPerType === Infinity ? String(MAX_EDGES_PER_TYPE) : String(edgesPerType);
      }
      if (edgesVal) edgesVal.textContent = edgesPerType === Infinity ? '‚àû' : String(edgesPerType);

      const affinityCfg = (config.affinity && typeof config.affinity === 'object') ? config.affinity : {};
      const threshold = (() => {
        const raw = Number(affinityCfg.threshold);
        const clamped = Number.isFinite(raw) ? Math.min(0.8, Math.max(0.1, raw)) : 0.35;
        return Math.round(clamped * 100) / 100;
      })();
      const iterations = (() => {
        const raw = Number(affinityCfg.iterations);
        return Number.isFinite(raw) ? Math.min(20, Math.max(1, Math.round(raw))) : 8;
      })();
      window.HLSF.config.affinity = { threshold, iterations };

      const thresholdSlider = wrapper.querySelector('#hlsf-aff-thresh');
      const thresholdVal = wrapper.querySelector('#hlsf-aff-thresh-val');
      if (thresholdSlider) thresholdSlider.value = threshold.toFixed(2);
      if (thresholdVal) thresholdVal.textContent = threshold.toFixed(2);

      const iterSlider = wrapper.querySelector('#hlsf-aff-iters');
      const iterVal = wrapper.querySelector('#hlsf-aff-iters-val');
      if (iterSlider) iterSlider.value = String(iterations);
      if (iterVal) iterVal.textContent = String(iterations);

      updateAffinityAnnotations(wrapper, threshold, iterations);

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      const colorMode = normalizeEdgeColorMode(config.edgeColorMode);
      window.HLSF.config.edgeColorMode = colorMode;
      if (edgeColorSelect) edgeColorSelect.value = colorMode;

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) rotationBtn.textContent = config.rotationActive ? 'Stop Global' : 'Start Global';

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      const emergentActive = window.HLSF.state?.emergent?.on === true;
      window.HLSF.config.emergentActive = emergentActive;
      if (emergentBtn) emergentBtn.textContent = emergentActive ? 'Stop Emergence' : 'Start Emergence';

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) edgesBtn.textContent = config.showEdges ? 'Edges: On' : 'Edges: Off';

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) labelsBtn.textContent = config.showLabels ? 'Labels: On' : 'Labels: Off';

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) glowBtn.textContent = config.showNodeGlow ? 'Glow: On' : 'Glow: Off';

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) bgBtn.textContent = config.whiteBg ? 'BG: Light' : 'BG: Dark';

      const layoutBtn = wrapper.querySelector('#hlsf-toggle-layout');
      if (layoutBtn) {
        const layout = normalizeLayout(config.layout);
        window.HLSF.config.layout = layout;
        layoutBtn.textContent = `Layout: ${layoutLabel(layout)}`;
      }
    }

    window.HLSF = window.HLSF || {};
    const existingConfig = window.HLSF.config || {};
    const DEFAULT_BOOTSTRAP_DB = "HLSF_Database_2025-10-15.json";
    window.HLSF.config = Object.assign({
      bootstrapDbUrl: existingConfig.bootstrapDbUrl || DEFAULT_BOOTSTRAP_DB,
      rotationActive: true,
      rotationOmega: 0.30,
      alpha: 0.10,
      scale: 1,
      tx: 0,
      ty: 0,
      emergentActive: false,
      showEdges: true,
      showLabels: true,
      fillFaces: false,
      whiteBg: false,
      showEnglish: true,
      fullAnchorCap: 0,
      batchLogging: true,
      deferredRender: true,
      progressTick: 250,
      layout: 'dimension',
      hlsfScope: existingConfig.hlsfScope || 'db',
      metricScope: METRIC_SCOPE.RUN,
      relationTypeCap: MAX_REL_TYPES,
      edgesPerType: 3,
      edgeWidth: 0.02,
      nodeSize: 1,
      edgeColorMode: 'theme',
      showNodeGlow: false,
      affinity: { threshold: 0.35, iterations: 8 },
    }, existingConfig);
    const initialRelationCap = window.HLSF.config.relationTypeCap;
    window.HLSF.config.relationTypeCap = initialRelationCap === Infinity
      ? Infinity
      : clampRelationTypeCap(initialRelationCap);
    const initialEdgesPerType = window.HLSF.config.edgesPerType;
    window.HLSF.config.edgesPerType = initialEdgesPerType === Infinity
      ? Infinity
      : clampEdgesPerType(initialEdgesPerType);
    window.HLSF.config.edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
    window.HLSF.config.nodeSize = clampNodeSize(window.HLSF.config.nodeSize);
    window.HLSF.config.edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
    window.HLSF.config.showNodeGlow = window.HLSF.config.showNodeGlow === true;
    window.HLSF.config.layout = normalizeLayout(window.HLSF.config.layout);
    window.HLSF.config.batchLogging = window.HLSF.config.batchLogging !== false;
    window.HLSF.config.deferredRender = window.HLSF.config.deferredRender !== false;
    window.HLSF.config.progressTick = Math.max(1, Math.round(Number(window.HLSF.config.progressTick) || 250));
    window.HLSF.config.metricScope = normalizeMetricScope(window.HLSF.config.metricScope);
    const affinityCfg = window.HLSF.config.affinity;
    if (!affinityCfg || typeof affinityCfg !== 'object') {
      window.HLSF.config.affinity = { threshold: 0.35, iterations: 8 };
    } else {
      const rawThresh = Number(affinityCfg.threshold);
      const rawIters = Number(affinityCfg.iterations);
      window.HLSF.config.affinity.threshold = Number.isFinite(rawThresh)
        ? Math.round(Math.min(0.8, Math.max(0.1, rawThresh)) * 100) / 100
        : 0.35;
      window.HLSF.config.affinity.iterations = Number.isFinite(rawIters)
        ? Math.min(20, Math.max(1, Math.round(rawIters)))
        : 8;
    }
    const prevState = window.HLSF.state || {};
    window.HLSF.state = Object.assign({}, prevState);
    window.HLSF.state.globalRot = Number.isFinite(prevState.globalRot) ? prevState.globalRot : 0;
    const emergentState = prevState.emergent && typeof prevState.emergent === 'object'
      ? prevState.emergent
      : {};
    window.HLSF.state.emergent = Object.assign({ on: false, speed: 0.25 }, emergentState);
    window.HLSF.state.emergentRot = Number.isFinite(prevState.emergentRot) ? prevState.emergentRot : 0;
    if (!(window.HLSF.state.patches instanceof Map)) window.HLSF.state.patches = new Map();
    window.HLSF.view = Object.assign({ x: 0, y: 0, scale: 1 }, window.HLSF.view || {});
    if (!Number.isFinite(window.HLSF.view.x)) window.HLSF.view.x = 0;
    if (!Number.isFinite(window.HLSF.view.y)) window.HLSF.view.y = 0;
    if (!Number.isFinite(window.HLSF.view.scale) || window.HLSF.view.scale <= 0) window.HLSF.view.scale = 1;

    function syncViewToConfig() {
      if (!window.HLSF?.config || !window.HLSF?.view) return;
      window.HLSF.config.scale = window.HLSF.view.scale;
      window.HLSF.config.tx = window.HLSF.view.x;
      window.HLSF.config.ty = window.HLSF.view.y;
    }
    window.HLSF.canvas = window.HLSF.canvas || null;
    window.HLSF.ctx = window.HLSF.ctx || null;
    window.HLSF.nodes = window.HLSF.nodes || [];
    window.HLSF.animationFrame = window.HLSF.animationFrame || null;
    window.HLSF.geometry = window.HLSF.geometry || {};
    window.HLSF.rendering = window.HLSF.rendering || {};
    window.HLSF.__centerInit = window.HLSF.__centerInit || false;
    window.HLSF.indexCache = window.HLSF.indexCache || null;
    window.HLSF.indexCacheSource = window.HLSF.indexCacheSource || null;

    const clampAlpha = (value) => {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return NaN;
      return Math.min(0.99, Math.max(0.005, numeric));
    };
    window.HLSF.config.alpha = (() => {
      const initial = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(initial) ? initial : 0.1;
    })();
    const baseAlpha = () => {
      const resolved = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(resolved) ? resolved : 0.1;
    };

    function hideVisualizer() {
      const el = document.getElementById('hlsf-canvas-container');
      if (el) el.classList.add('hidden');
    }

    function showVisualizer() {
      const el = document.getElementById('hlsf-canvas-container');
      if (el) el.classList.remove('hidden');
    }
    const edgeAlphaFromWeight = (w) => {
      const preferred = Number.isFinite(w) ? clampAlpha(w) : NaN;
      if (Number.isFinite(preferred)) return preferred;
      return baseAlpha();
    };

    const EDGE_COLOR_PALETTE = [
      '#00ff88', '#ffd54f', '#ff6f91', '#64b5f6', '#ce93d8',
      '#ff8a65', '#4dd0e1', '#9ccc65', '#f06292', '#ba68c8'
    ];

    function paletteColor(key) {
      if (!key) return EDGE_COLOR_PALETTE[0];
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = (hash * 33 + key.charCodeAt(i)) | 0;
      }
      const index = Math.abs(hash) % EDGE_COLOR_PALETTE.length;
      return EDGE_COLOR_PALETTE[index];
    }

    function normalizedIntensity(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(1, numeric));
    }

    function weightToColor(value) {
      const t = normalizedIntensity(value);
      const r = Math.round(255 - 90 * t);
      const g = Math.round(160 + 80 * t);
      const b = Math.round(120 + 16 * (1 - t));
      const alpha = 0.45 + 0.45 * t;
      return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2)})`;
    }

    function nodeEdgeStrokeColor(node, index, mode) {
      if (mode === 'relation') {
        return paletteColor(`${node.token}-${index}`);
      }
      if (mode === 'weight') {
        return weightToColor(node.attention ?? 0);
      }
      return null;
    }

    function compositeEdgeStrokeColor(edge, mode) {
      if (mode === 'relation') {
        return paletteColor(edge.rtype || `${edge.from}->${edge.to}`);
      }
      if (mode === 'weight') {
        return weightToColor(edge.w ?? 0);
      }
      return null;
    }

    function stepRotation(dt) {
      const w = window.HLSF.config.rotationOmega || 0;
      const tau = 2 * Math.PI;
      if (window.HLSF.config.rotationActive && w) {
        window.HLSF.state.globalRot = (window.HLSF.state.globalRot + dt * w) % tau;
      }
      rotate_patches(dt);
      if (window.HLSF.state?.emergent?.on) {
        const speed = Number.isFinite(window.HLSF.state.emergent.speed) ? window.HLSF.state.emergent.speed : 0;
        if (speed) {
          window.HLSF.state.emergentRot = (window.HLSF.state.emergentRot + dt * speed) % tau;
        }
      }
    }

    let TokenToGlyph = new Map();
    let GlyphToToken = new Map();

    function loadGlyphMaps(db) {
      if (!db) return;
      if (!(TokenToGlyph instanceof Map)) TokenToGlyph = new Map();
      if (!(GlyphToToken instanceof Map)) GlyphToToken = new Map();
      TokenToGlyph.clear();
      GlyphToToken.clear();
      (db.token_glyph_map || []).forEach(({ token, glyph }) => {
        if (token && glyph) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
      (db.glyph_token_map || []).forEach(({ glyph, token }) => {
        if (glyph && token) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
    }

    window.CognitionEngine = window.CognitionEngine || {
      state: {},
      cache: {},
      api: {},
      processing: {},
    };

    window.GlyphSystem = window.GlyphSystem || {
      ledger: null,
      encode: () => '',
      decode: () => '',
      export: () => ({}),
    };

    // ---- Glyph crypto core ----
    const LEDGER_KEY = "HLSF_GLYPH_LEDGER_V1";
    const GLYPH_SET = Array.from("‚¨£‚¨ß‚¨©‚¨°‚¨™‚¨®‚¨§‚¨ü‚¨¢‚¨•‚¨†‚¨ô‚¨ò‚¨ó‚¨ñ‚¨ï‚¨î‚¨ì‚¨í‚¨ë"); // limited symbols
    const GLYPH_SEP = " "; // delimiter between glyph-weight pairs
    const NUM_FMT = n => Number(n).toString(); // unlimited precision as given

    function hydrateLedgerMaps(ledger) {
      TokenToGlyph.clear();
      GlyphToToken.clear();
      const map = ledger?.glyph_map || {};
      for (const glyph of Object.keys(map)) {
        const entries = Array.isArray(map[glyph]) ? map[glyph] : [];
        for (const entry of entries) {
          if (!entry || !entry.token) continue;
          TokenToGlyph.set(entry.token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(entry.token);
        }
      }
    }

    // Load/save ledger
    function loadLedger() {
      let ledger;
      try {
        const raw = localStorage.getItem(LEDGER_KEY);
        ledger = raw ? JSON.parse(raw) : null;
      } catch {
        ledger = null;
      }
      if (!ledger || typeof ledger !== 'object') {
        ledger = { version: "1.0", created_at: new Date().toISOString(), glyph_map: {} };
      } else {
        ledger.version = ledger.version || "1.0";
        ledger.created_at = ledger.created_at || new Date().toISOString();
        ledger.glyph_map = ledger.glyph_map || {};
      }
      hydrateLedgerMaps(ledger);
      return ledger;
    }
    function saveLedger(ledger) {
      try {
        localStorage.setItem(LEDGER_KEY, JSON.stringify(ledger));
      } catch (err) {
        console.warn('Failed to persist glyph ledger:', err);
      }
    }

    // ---- HLSF constants
    const TOKEN_CACHE_PREFIX = 'hlsf_token_';
    const DB_RAW_KEY = 'HLSF_DB_RAW';        // stores JSON export text
    const API_KEY_STORAGE_KEY = 'HLSF_API_KEY';
    const DB_INDEX_KEY = 'HLSF_DB_INDEX';    // array of token strings

    function parseMaybeNdjson(text) {
      try { return JSON.parse(text); } catch {}
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const rows = [];
      for (const ln of lines) {
        try { rows.push(JSON.parse(ln)); } catch {}
      }
      return rows.length ? rows : null;
    }

    function coerceDb(input) {
      const data = (typeof input === 'string') ? parseMaybeNdjson(input.replace(/^\uFEFF/, '')) : input;
      if (!data) throw new Error('Unparseable JSON/NDJSON');
      if (data && !Array.isArray(data) && Array.isArray(data.full_token_data)) {
        return Object.assign({}, data, { full_token_data: data.full_token_data });
      }
      if (Array.isArray(data)) return { full_token_data: data };
      throw new Error('Invalid database format. Expected full_token_data array.');
    }

    function normalizeRecord(rec) {
      if (!rec || typeof rec.token !== 'string') return null;
      const rels = rec.relationships && typeof rec.relationships === 'object' ? rec.relationships : {};
      const out = { token: rec.token, relationships: rels, cached_at: rec.cached_at || null };
      for (const [key, value] of Object.entries(rec)) {
        if (key === 'token' || key === 'relationships' || key === 'cached_at') continue;
        out[key] = value;
      }
      return out;
    }

    function loadDbObject(dbLike) {
      const db = coerceDb(dbLike);
      const raw = Array.from(db.full_token_data || []);
      const clean = raw.map(normalizeRecord).filter(Boolean);
      if (!clean.length) throw new Error('No valid token records');
      // Reset existing cached tokens so the cache matches the imported database
      const existingKeys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const key of existingKeys) {
        safeStorageRemove(key);
      }
      const now = new Date().toISOString();
      for (const record of clean) {
        const payload = Object.assign({ cached_at: now }, record);
        if (!payload.cached_at) payload.cached_at = now;
        const cacheKey = getCacheKey(record.token);
        safeStorageSet(cacheKey, JSON.stringify(payload));
      }
      const out = Object.assign({}, db, { full_token_data: clean });
      localStorage.setItem(DB_RAW_KEY, JSON.stringify(out));
      const index = clean.map(r => r.token);
      localStorage.setItem(DB_INDEX_KEY, JSON.stringify(index));
      window.HLSF.dbCache = out;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      window.HLSF.indexCache = null;
      window.HLSF.indexCacheSource = null;
      state.hlsfReady = false;
      if (typeof buildHLSFMatrices === 'function') {
        try {
          buildHLSFMatrices(out);
        } catch (err) {
          console.warn('Failed to rebuild HLSF matrices:', err);
        }
      }
      updateHeaderCounts();
      return clean.length;
    }

    function refreshDbReference(recordLike) {
      const normalized = normalizeRecord(recordLike);
      if (!normalized) return;

      if (!normalized.cached_at) {
        normalized.cached_at = new Date().toISOString();
      }

      let db = window.HLSF.dbCache;
      if (!db || typeof db !== 'object') {
        try {
          const raw = localStorage.getItem(DB_RAW_KEY);
          if (raw) {
            db = JSON.parse(raw);
          }
        } catch (err) {
          console.warn('Failed to hydrate existing DB snapshot:', err);
          db = null;
        }
      }

      if (!db || typeof db !== 'object') {
        db = { full_token_data: [] };
      }

      if (!Array.isArray(db.full_token_data)) {
        db.full_token_data = Array.isArray(db.full_token_data)
          ? db.full_token_data.filter(Boolean).map(normalizeRecord).filter(Boolean)
          : [];
      }

      const entries = db.full_token_data;
      const idx = entries.findIndex(rec => rec && rec.token === normalized.token);
      if (idx >= 0) {
        const existing = entries[idx] || {};
        entries[idx] = Object.assign({}, existing, normalized);
        if (!entries[idx].cached_at) entries[idx].cached_at = normalized.cached_at;
      } else {
        entries.push(normalized);
      }

      window.HLSF.dbCache = db;
      try {
        safeStorageSet(DB_RAW_KEY, JSON.stringify(db));
      } catch (err) {
        console.warn('Failed to persist updated DB snapshot:', err);
      }
      window.HLSF.indexCache = null;
      window.HLSF.indexCacheSource = null;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      state.hlsfReady = false;
      updateHeaderCounts();
    }

    function getDb() {
      if (window.HLSF.dbCache) return window.HLSF.dbCache;
      let raw = null;
      try {
        raw = localStorage.getItem(DB_RAW_KEY);
        if (!raw) {
          const legacy = localStorage.getItem('hlsf_db_raw');
          if (legacy) {
            localStorage.setItem(DB_RAW_KEY, legacy);
            localStorage.removeItem('hlsf_db_raw');
            raw = legacy;
          }
        }
      } catch (err) {
        console.warn('Failed to read DB from storage:', err);
        raw = null;
      }
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        window.HLSF.dbCache = parsed;
        return parsed;
      } catch (err) {
        console.warn('Stored DB is not valid JSON:', err);
        return null;
      }
    }

    // Symbolic glyphs for complex number representation
    const GLYPH_LIBRARY = [
      '‚óâ', '‚óà', '‚óá', '‚óÜ', '‚óä', '‚óã', '‚óè', '‚óê', '‚óë', '‚óí',
      '‚óì', '‚òâ', '‚äô', '‚äö', '‚äõ', '‚äú', '‚äù', '‚óé', '‚óç', '‚óå',
      '‚ñ≥', '‚ñ≤', '‚ñΩ', '‚ñº', '‚óÅ', '‚ñ∑', '‚óÄ', '‚ñ∂', '‚¨ü', '‚¨†',
      '‚¨°', '‚¨¢', '‚¨£', '‚¨§', '‚¨•', '‚¨¶', '‚¨ß', '‚¨®', '‚¨©', '‚¨™',
      '‚¨´', '‚¨¨', '‚¨≠', '‚¨Æ', '‚¨Ø', '‚≠ê', '‚òÖ', '‚òÜ', '‚ú¶', '‚úß',
      '‚ú∂', '‚ú∑', '‚ú∏', '‚úπ', '‚ú∫', '‚úª', '‚úº', '‚úΩ', '‚úæ', '‚úø',
      '‚ùÄ', '‚ùÅ', '‚ùÇ', '‚ùÉ', '‚ùÑ', '‚ùÖ', '‚ùÜ', '‚ùá', '‚ùà', '‚ùâ',
      '‚öô', '‚öõ', '‚öù', '‚öû', '‚öü', '‚ö¨', '‚ö≠', '‚öÆ', '‚öØ', '‚ö∞'
    ];

    const RELATIONSHIP_PRIORITIES = new Map([
      ['‚â°', 1.0], ['‚äÉ', 1.0], ['‚äÇ', 0.8], ['‚âà', 0.7], ['‚àà', 0.9], ['‚àã', 0.9],
      ['‚ä§', 0.9], ['‚ä•', 0.9], ['‚äè', 0.8], ['‚äê', 0.8], ['‚Üî', 0.7], ['‚áå', 0.7],
      ['‚à•', 0.6], ['‚àº', 0.5], ['‚Üí', 0.5], ['‚áí', 0.5], ['‚áê', 0.5], ['‚Ü†', 0.5],
      ['‚Üó', 0.4], ['‚Üò', 0.4], ['‚áù', 1.0], ['‚áÇ', 0.7], ['‚â†', 0.8], ['‚äï', 0.8],
      ['‚äõ', 0.7], ['‚àù', 0.7], ['‚áù Causes', 1.0], ['‚áê Caused By', 0.9],
      ['‚àó', 0.7], ['‚âú', 0.9], ['‚ãÜ', 0.8], ['7‚Üí', 0.7], ['‚ä¢', 0.9], ['‚ä£', 0.9],
      ['‚Ü∑', 0.8], ['‚Ü∂', 0.8], ['‚ó¶', 0.9], ['|=', 0.9], ['‚óÅ', 0.6], ['‚áÑ', 0.6],
      ['‚äó', 0.9], ['√∑', 0.7], ['‚äò', 0.8], ['√ó', 0.8], ['¬¨', 0.8], ['‚Ä†', 0.8],
      ['‚ä†', 0.8], ['/‚àà', 0.8], ['‚ä¨', 0.8], ['‚ä©', 0.9], ['‚ä®', 0.9], ['?', 0.5],
      ['‚ö°', 0.7], ['‚áí Attention', 0.7], ['‚Ü∂ Self-Reference', 0.7], ['‚àß', 0.6],
      ['‚Ü≠', 0.6], ['‚ñ∑‚óÅ', 0.6]
    ]);

    // ============================================
    // STATE
    // ============================================
    const state = {
      apiKey: '',
      isProcessing: false,
      sessionStats: {
        totalApiCalls: 0,
        totalCacheHits: 0,
        totalCostUsd: 0,
      },
      hlsfReady: false,
    };

    state.hlsfReady = false;
    window.CognitionEngine.state = state;

    let currentAbortController = null;

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      log: document.getElementById('log'),
      input: document.getElementById('command-input'),
      sendBtn: document.getElementById('send-btn'),
      cancelBtn: document.getElementById('cancel-btn'),
      apiModal: document.getElementById('api-modal'),
      apiKeyInput: document.getElementById('api-key-input'),
      apiConfirmBtn: document.getElementById('api-confirm'),
      apiCancelBtn: document.getElementById('api-cancel'),
      cacheHitRate: document.getElementById('cache-hit-rate'),
      cachedTokens: document.getElementById('cached-tokens'),
      sessionCost: document.getElementById('session-cost'),
      dbFileInput: document.getElementById('db-file'),
    };

    // ============================================
    // UTILITIES
    // ============================================
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validatePrompt(prompt) {
      if (!prompt || typeof prompt !== 'string') {
        throw new Error('Invalid prompt: must be non-empty string');
      }
      if (prompt.length > 10000) {
        throw new Error('Prompt too long: max 10000 characters');
      }
      return prompt.trim();
    }

    function safeStorageGet(key, defaultValue = null) {
      try {
        const item = localStorage.getItem(key);
        if (item == null) return defaultValue;
        try {
          return JSON.parse(item);
        } catch {
          return item;
        }
      } catch (err) {
        console.warn(`Storage read failed for ${key}:`, err);
        return defaultValue;
      }
    }

    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        console.warn(`Storage write failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.warn(`Storage remove failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageKeys(prefix = '') {
      try {
        return Object.keys(localStorage).filter(k => k.startsWith(prefix));
      } catch (err) {
        console.warn('Storage keys enumeration failed:', err);
        return [];
      }
    }

    function isValidApiKey(key) {
      if (typeof key !== 'string') return false;
      const trimmed = key.trim();
      if (!trimmed) return false;
      if (!trimmed.startsWith('sk-')) return false;
      return trimmed.length >= 20;
    }

    function tokenize(text) {
      if (!text) return [];
      return text.trim()
        .split(/[^\p{L}\p{N}\-']+/u)
        .filter(Boolean)
        .map(t => t.toLowerCase());
    }

    function estimateTokensForText(text) {
      return tokenize(text).length;
    }

    function estimateTokensForMessages(messages) {
      if (!Array.isArray(messages)) return 0;
      let total = 0;
      for (const message of messages) {
        if (!message) continue;
        const contentTokens = estimateTokensForText(message.content || '');
        const roleTokens = message.role ? 4 : 0;
        total += contentTokens + roleTokens;
      }
      return total + 3; // minimal overhead for chat formatting
    }

    function estimateCompletionTokens(promptTokenCount) {
      const ratio = CONFIG.ESTIMATED_COMPLETION_RATIO ?? 0.7;
      const estimate = Math.round(promptTokenCount * ratio);
      return Math.max(32, estimate);
    }

    function getModelPricing(model) {
      const pricing = CONFIG.MODEL_PRICING?.[model];
      return pricing || CONFIG.MODEL_PRICING?.default || { inputPerMillion: 0, outputPerMillion: 0 };
    }

    function estimateCostUsd(promptTokens = 0, completionTokens = 0, model = CONFIG.DEFAULT_MODEL) {
      const pricing = getModelPricing(model);
      return ((promptTokens * pricing.inputPerMillion) + (completionTokens * pricing.outputPerMillion)) / 1_000_000;
    }

    const Session = (() => {
      const existing = window.Session && typeof window.Session === 'object'
        ? window.Session
        : {};
      const session = Object.assign({ tokens: new Set() }, existing);
      window.Session = session;
      return session;
    })();

    function addConversationTokens(arr) {
      for (const token of arr || []) {
        if (token) Session.tokens.add(token);
      }
    }

    function onUserPromptSubmitted(text) {
      const toks = text.trim().split(/\s+/).filter(Boolean);
      addConversationTokens(toks);
    }

    function formatCurrency(amountUsd) {
      if (!amountUsd || isNaN(amountUsd)) return '$0.0000';
      const abs = Math.abs(amountUsd);
      if (abs > 0 && abs < 0.0001) {
        return amountUsd < 0 ? '-<$0.0001' : '<$0.0001';
      }
      const decimals = abs >= 1 ? 2 : abs >= 0.01 ? 3 : 4;
      const prefix = amountUsd < 0 ? '-$' : '$';
      return `${prefix}${Math.abs(amountUsd).toFixed(decimals)}`;
    }

    function getCachedTokenCount() {
      return safeStorageKeys(TOKEN_CACHE_PREFIX).length;
    }

    // ============================================
    // COMPLEX NUMBER ENCODING & GLYPH SYSTEM
    // ============================================
    
    // Convert token to complex number representation
    // Magnitude = attention score, Phase = semantic hash
    function tokenToComplexNumber(token, tokenData) {
      const attentionScore = tokenData?.attention_score || 0.5;
      const magnitude = attentionScore; // 0.0 to 1.0
      
      // Generate phase from token's semantic properties
      let phaseHash = 0;
      for (let i = 0; i < token.length; i++) {
        phaseHash = ((phaseHash << 5) - phaseHash) + token.charCodeAt(i);
        phaseHash = phaseHash & phaseHash;
      }
      
      // Normalize phase to 0-2œÄ
      const phase = (Math.abs(phaseHash) % 360) * (Math.PI / 180);
      
      // Calculate real and imaginary parts
      const real = magnitude * Math.cos(phase);
      const imaginary = magnitude * Math.sin(phase);
      
      return { real, imaginary, magnitude, phase };
    }

    const memoizedComplexNumber = (() => {
      const cache = new Map();
      return (token, tokenData) => {
        const score = tokenData?.attention_score ?? 0;
        const key = `${token}_${score}`;
        if (cache.has(key)) return cache.get(key);
        const result = tokenToComplexNumber(token, tokenData);
        cache.set(key, result);
        return result;
      };
    })();

    // Map complex number to glyph from library
    function complexToGlyph(complex) {
      // Use magnitude and phase to select glyph
      const magnitudeIndex = Math.floor(complex.magnitude * 7); // 0-7 range
      const phaseIndex = Math.floor((complex.phase / (2 * Math.PI)) * 10); // 0-9 range
      const glyphIndex = (magnitudeIndex * 10 + phaseIndex) % GLYPH_LIBRARY.length;
      return GLYPH_LIBRARY[glyphIndex];
    }

    // Generate glyph ledger for all cached tokens
    function generateGlyphLedger() {
      const ledger = new Map();
      const reverseMap = new Map(); // glyph -> tokens
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);

      for (const key of keys) {
        try {
          const tokenData = safeStorageGet(key);
          if (!tokenData?.token) continue;
          const token = tokenData.token;
          const complex = memoizedComplexNumber(token, tokenData);
          const glyph = complexToGlyph(complex);

          ledger.set(token, {
            glyph,
            complex: {
              real: complex.real.toFixed(4),
              imaginary: complex.imaginary.toFixed(4),
              magnitude: complex.magnitude.toFixed(4),
              phase: complex.phase.toFixed(4)
            },
            attention_score: tokenData.attention_score || 0
          });
          
          // Track consolidation - multiple tokens per glyph
          if (!reverseMap.has(glyph)) {
            reverseMap.set(glyph, []);
          }
          reverseMap.get(glyph).push(token);
        } catch (err) {
          console.error('Failed to process token:', key, err);
        }
      }
      
      return { ledger, reverseMap };
    }

    // Consolidate similar tokens to same glyph
    function findConsolidatedTokens(reverseMap) {
      const consolidated = [];
      for (const [glyph, tokens] of reverseMap.entries()) {
        if (tokens.length > 1) {
          consolidated.push({ glyph, tokens, count: tokens.length });
        }
      }
      return consolidated.sort((a, b) => b.count - a.count);
    }

    // Encode message using glyph ledger
    function encodeMessage(message, ledger) {
      const tokens = tokenize(message);
      const encoded = [];
      const unknown = [];
      
      for (const token of tokens) {
        const entry = ledger.get(token);
        if (entry) {
          encoded.push(entry.glyph);
        } else {
          encoded.push('‚óå'); // Unknown token marker
          unknown.push(token);
        }
      }
      
      return {
        encoded: encoded.join(''),
        coverage: ((tokens.length - unknown.length) / tokens.length * 100).toFixed(1),
        unknown
      };
    }

    // Decode message using reverse glyph map
    function decodeMessage(encoded, reverseMap) {
      const glyphs = Array.from(encoded);
      const decoded = [];
      
      for (const glyph of glyphs) {
        const tokens = reverseMap.get(glyph);
        if (tokens && tokens.length > 0) {
          // Use first token (could use most common or context-aware selection)
          decoded.push(tokens[0]);
        } else {
          decoded.push('[?]');
        }
      }
      
      return decoded.join(' ');
    }

    // Export glyph ledger for inter-system transmission
    function exportGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        ledger_version: "1.0",
        description: "HLSF Symbolic Glyph Encryption Ledger - Complex Number Token Encoding",
        specification: {
          encoding: "Complex numbers (magnitude=attention, phase=semantic_hash)",
          glyph_library_size: GLYPH_LIBRARY.length,
          representation: "Unicode symbolic glyphs",
          consolidation: "Similar tokens map to same glyph based on complex number proximity"
        },
        statistics: {
          total_tokens: ledger.size,
          unique_glyphs: reverseMap.size,
          consolidation_ratio: (ledger.size / reverseMap.size).toFixed(2),
          consolidated_groups: consolidated.length
        },
        glyph_ledger: Object.fromEntries(ledger),
        reverse_mapping: Object.fromEntries(
          Array.from(reverseMap.entries()).map(([glyph, tokens]) => [glyph, tokens])
        ),
        consolidated_tokens: consolidated,
        encryption_examples: generateEncryptionExamples(ledger, reverseMap)
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Glyph_Ledger_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return exportData;
    }

    window.GlyphSystem.ledger = null;
    window.GlyphSystem.encode = function encode(message) {
      const result = encryptTextToGlyphs(message || '');
      window.GlyphSystem.ledger = loadLedger();
      return { encoded: result.encrypted, coverage: result.coverage, unknown: result.unknown };
    };
    window.GlyphSystem.decode = function decode(encoded) {
      return decryptGlyphsToText(encoded || '');
    };
    window.GlyphSystem.export = function exportLedgerSnapshot() {
      return loadLedger();
    };

    function generateEncryptionExamples(ledger, reverseMap) {
      const examples = [
        "hello world",
        "consciousness",
        "quantum entanglement"
      ];
      
      return examples.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          plaintext: msg,
          encoded: result.encoded,
          coverage: result.coverage + '%',
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
    }

    function showGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      // Show sample encoded messages
      const sampleMessages = [
        "What is consciousness?",
        "Explain quantum mechanics",
        "The nature of reality"
      ];
      
      const encodedSamples = sampleMessages.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          original: msg,
          encoded: result.encoded,
          coverage: result.coverage,
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">üîê Symbolic Glyph Encryption Ledger</div>
        
        <div class="adjacency-insight">
          <strong>üìê Complex Number Encoding:</strong><br>
          ‚Ä¢ Each token ‚Üí Complex number (magnitude + phase)<br>
          ‚Ä¢ Magnitude = Attention score (0.0-1.0)<br>
          ‚Ä¢ Phase = Semantic hash (0-2œÄ radians)<br>
          ‚Ä¢ Glyph = Visual representation of complex coordinates
        </div>

        <div class="adjacency-insight">
          <strong>üìä Ledger Statistics:</strong><br>
          ‚Ä¢ Total tokens: <strong>${ledger.size}</strong><br>
          ‚Ä¢ Unique glyphs: <strong>${reverseMap.size}</strong><br>
          ‚Ä¢ Consolidation ratio: <strong>${(ledger.size / reverseMap.size).toFixed(2)}:1</strong><br>
          ‚Ä¢ Efficiency gain: <strong>${(100 - (reverseMap.size / ledger.size * 100)).toFixed(1)}%</strong>
        </div>

        <div class="adjacency-insight">
          <strong>üîÑ Token Consolidation (Similar tokens ‚Üí Same glyph):</strong><br>
          ${consolidated.slice(0, 5).map(c => 
            `‚Ä¢ <span style="font-size: 1.5em;">${c.glyph}</span> ‚Üí ${c.tokens.slice(0, 3).join(', ')}${c.tokens.length > 3 ? '...' : ''} (${c.count} tokens)`
          ).join('<br>')}
          ${consolidated.length === 0 ? '<em>No consolidation yet - need more diverse tokens</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>üîê Encrypted Message Examples:</strong><br>
          ${encodedSamples.map(s => `
            <div style="margin: 0.75rem 0; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <div style="opacity: 0.7; font-size: 0.85em;">Original:</div>
              <div style="margin: 0.25rem 0;">${s.original}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Encrypted (${s.coverage}% coverage):</div>
              <div style="font-size: 1.3em; letter-spacing: 0.1em; color: var(--accent); margin: 0.25rem 0;">${s.encoded}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Decoded:</div>
              <div style="margin: 0.25rem 0;">${s.decoded}</div>
            </div>
          `).join('')}
        </div>

        <details>
          <summary>üìñ View full glyph mapping (first 20 tokens)</summary>
          <pre>${JSON.stringify(
            Object.fromEntries(Array.from(ledger.entries()).slice(0, 20)),
            null, 2
          )}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          üí° <strong>Usage:</strong> This ledger enables secure inter-system communication. 
          Messages encoded with glyphs can be transmitted efficiently and decoded by any system 
          with the same ledger. The consolidation reduces message size while maintaining semantic meaning.
        </div>
      `);
    }

    // ============================================
    // LOGGING
    // ============================================
    function batchLogUpdates(entries) {
      const fragment = document.createDocumentFragment();
      entries.forEach(entry => fragment.appendChild(entry));
      elements.log.appendChild(fragment);
      elements.log.scrollTop = elements.log.scrollHeight;
    }

    function addLog(content, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>${content}`;
      batchLogUpdates([entry]);
      return entry;
    }

    function appendLog(msg, type = 'info') {
      if (typeof msg === 'string') return addLog(msg, type);
      return addLog(sanitize(String(msg)), type);
    }

    function logStatus(msg) {
      return appendLog(`<div class="processing-indicator"><span class="spinner"></span>${sanitize(msg)}</div>`, 'status');
    }
    function logError(msg) { return appendLog(`üî¥ ${sanitize(msg)}`, 'error'); }
    window.logOK = (msg) => addLog(`‚úÖ ${sanitize(String(msg))}`, 'success');
    function logWarning(msg) { return appendLog(`‚ö†Ô∏è ${sanitize(msg)}`, 'warning'); }
    function logFinal(msg) { return appendLog(`‚úÖ ${sanitize(msg)}`, 'success'); }

    function debounce(fn, delay) {
      let timeout;
      return function debounced(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    async function safeAsync(fn, errorMsg) {
      try {
        return await fn();
      } catch (err) {
        logError(`${errorMsg}: ${err.message}`);
        console.error(errorMsg, err);
        return null;
      }
    }

    // ============================================
    // STATS
    // ============================================
    function updateStats() {
      const { totalApiCalls, totalCacheHits, totalCostUsd } = state.sessionStats;
      const total = totalApiCalls + totalCacheHits;
      const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) + '%' : '‚Äî';

      const cachedCount = getCachedTokenCount();

      elements.cacheHitRate.textContent = hitRate;
      elements.cachedTokens.textContent = cachedCount;
      elements.sessionCost.textContent = formatCurrency(totalCostUsd);

      // Visual feedback for database growth
      if (cachedCount > 0) {
        elements.cachedTokens.style.color = cachedCount > 50 ? '#00ff88' : '#ffd54f';
      }
    }

    function updateHeaderCounts() {
      updateStats();
    }

    // ============================================
    // CACHE
    // ============================================
    function getCacheKey(token) {
      const normalized = token == null ? '' : String(token);
      return `${TOKEN_CACHE_PREFIX}${normalized.toLowerCase()}`;
    }

    function isTokenCached(token) {
      try {
        return localStorage.getItem(getCacheKey(token)) != null;
      } catch {
        return false;
      }
    }

    function updateTokenIndex(token) {
      if (!token) return;

      let index = safeStorageGet(DB_INDEX_KEY, []);
      if (!Array.isArray(index)) index = [];
      if (!index.includes(token)) {
        index.push(token);
        safeStorageSet(DB_INDEX_KEY, JSON.stringify(index));
      }
    }

    function getFromCache(token) {
      try {
        const raw = safeStorageGet(getCacheKey(token));
        if (!raw) return null;
        state.sessionStats.totalCacheHits++;
        updateStats();
        return raw;
      } catch { return null; }
    }

    function saveToCache(token, data) {
      try {
        const payloadData = Object.assign({ token }, data, {
          cached_at: new Date().toISOString(),
        });
        const recordToken = (typeof payloadData.token === 'string' && payloadData.token)
          ? payloadData.token
          : token;
        payloadData.token = recordToken;
        const payload = JSON.stringify(payloadData);
        const ok = safeStorageSet(getCacheKey(recordToken), payload);
        if (!ok) return;
        updateTokenIndex(recordToken);
        refreshDbReference(payloadData);
      } catch (err) {
        if (err.name === 'QuotaExceededError') {
          logWarning('Cache full. Use /reset to clear old data.');
        }
      }
    }

    window.CognitionEngine.cache = {
      get: getFromCache,
      set: saveToCache,
      key: getCacheKey,
    };

    // ============================================
    // OPENAI API
    // ============================================
    async function callOpenAI(messages, options = {}) {
      if (!state.apiKey) throw new Error('No API key configured');

      const body = {
        model: options.model || CONFIG.DEFAULT_MODEL,
        messages,
        max_tokens: options.max_tokens ?? CONFIG.MAX_TOKENS_PER_RESPONSE,
        temperature: options.temperature || 0.7,
      };

      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
        if (currentAbortController?.signal.aborted) {
          const error = new Error('Cancelled');
          error.name = 'AbortError';
          throw error;
        }

        attempt++;
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.apiKey}`,
            },
            body: JSON.stringify(body),
          });

          if (response.status === 429 && attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
            await new Promise(r => setTimeout(r, CONFIG.RETRY_BASE_DELAY_MS * Math.pow(2, attempt - 1)));
            continue;
          }

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `API error (${response.status})`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error?.message) errorMessage = errorData.error.message;
            } catch (e) {
              if (errorText) errorMessage = errorText;
            }
            
            if (response.status === 401) errorMessage = 'Invalid API key';
            else if (response.status === 403) errorMessage = 'Access forbidden - check billing setup';
            else if (response.status === 429) errorMessage = 'Rate limit exceeded';
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          state.sessionStats.totalApiCalls++;

          const content = data.choices?.[0]?.message?.content?.trim() || '';
          const usage = data.usage || {};
          const promptTokens = usage.prompt_tokens ?? estimateTokensForMessages(messages);
          const completionTokens = usage.completion_tokens ?? estimateTokensForText(content);
          const callCost = estimateCostUsd(promptTokens, completionTokens, body.model);
          state.sessionStats.totalCostUsd += callCost;
          updateStats();

          return content;
        } catch (err) {
          if (err.name === 'AbortError') throw err;
          if (err.message === 'Failed to fetch') {
            throw new Error('Network error - check connection or download HTML to run locally');
          }
          if (attempt === CONFIG.MAX_RETRY_ATTEMPTS) throw err;
        }
      }
    }

    window.CognitionEngine.api = {
      callOpenAI,
    };

    // ============================================
    // ADJACENCY
    // ============================================
    class ProgressTracker {
      constructor(total, label) {
        this.total = total;
        this.current = 0;
        this.label = label;
        this.element = logStatus(`‚è≥ ${label} (0/${total})`);
      }

      increment(count = 1) {
        this.current += count;
        const percent = this.total === 0 ? 100 : Math.round((this.current / this.total) * 100);
        if (this.element) {
          this.element.innerHTML = `‚è≥ ${this.label} (${this.current}/${this.total}) - ${percent}%`;
        }
      }

      complete(message) {
        if (this.element) {
          this.element.innerHTML = `‚úÖ ${message || `${this.label} complete`}`;
        }
      }
    }

    async function fetchAdjacency(token, context) {
      if (currentAbortController?.signal.aborted) {
        throw new Error('AbortError');
      }

      const cached = getFromCache(token);
      if (cached) {
        return { ...cached, cache_hit: true };
      }

      if (!state.apiKey) return { token, relationships: {}, offline: true };

      const prompt = `Token: "${token}"
Context: "${context}"

For this token, identify the most relevant adjacent tokens across relationship types. For each that applies, provide related tokens with weights 0.01-1.00.

Relationship types: ‚â° Identity, ‚äÉ Contains, ‚äÇ Is Contained By, ‚âà Variant, ‚àà Is Instance Of, ‚àã Has Instance, ‚ä§ Is Type Of, ‚ä• Has Type, ‚äè Part Of, ‚äê Composes, ‚Üî Mirrors, ‚áå Inverts, ‚à• Parallel To, ‚àº Adjacent To, ‚Üí Next, ‚áí Sequence Of, ‚áê Preceded By, ‚Ü† Follows, ‚Üó Spatially Above, ‚Üò Spatially Below, ‚áù Symbolically Supports, ‚áÇ Symbolically Depends, ‚â† Contrasts, ‚äï Complements, ‚äõ Associated With, ‚àù Correlates With, ‚áù Causes, ‚áê Caused By, ‚àó Evokes, ‚âú Represents, ‚ãÜ Symbolizes, 7‚Üí Refers To, ‚ä¢ Defines, ‚ä£ Is Defined By, ‚Ü∑ Transforms To, ‚Ü∂ Transformed From, ‚ó¶ Functions As, |= Interpreted As, ‚óÅ Used With, ‚áÑ Co-occurs With, ‚äó Synthesizes, √∑ Divides Into, ‚äò Opposes, √ó Rejects, ¬¨ Negates, ‚Ä† Destroys, ‚ä† Blocks, /‚àà Invalidates, ‚ä¨ Contradicts, ‚ä© Asserts, ‚ä® Provides Evidence, ? Uncertainty, ‚ö° Memory, ‚áí Attention, ‚Ü∂ Self-Reference, ‚àß Perspective, ‚Ü≠ Continuity, ‚ñ∑‚óÅ Relationality

Return JSON: {"token": "${token}", "relationships": {"‚â°": [{"token": "...", "weight": 0.95}], ...}}`;

      let safePrompt;
      try {
        safePrompt = validatePrompt(prompt);
      } catch (err) {
        logError(`Prompt validation failed for ${token}: ${err.message}`);
        return { token, relationships: {}, error: 'invalid_prompt' };
      }

      const content = await safeAsync(
        () => callOpenAI([
          { role: 'system', content: 'You are an HLSF token adjacency analyzer.' },
          { role: 'user', content: safePrompt },
        ]),
        `Adjacency fetch failed for ${token}`
      );

      if (!content) {
        return { token, relationships: {}, error: 'request_failed' };
      }

      try {
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const parsed = JSON.parse(content.slice(jsonStart, jsonEnd + 1));
        saveToCache(token, parsed);
        return { ...parsed, cache_hit: false };
      } catch {
        return { token, relationships: {}, error: 'Parse failed' };
      }
    }

    async function batchFetchAdjacencies(tokens, context, label) {
      const results = new Map();
      const unique = [...new Set(tokens)];

      const progress = new ProgressTracker(unique.length, label);

      let processed = 0;
      for (let i = 0; i < unique.length; i += CONFIG.MAX_CONCURRENCY) {
        if (currentAbortController?.signal.aborted) {
          progress.complete(`${label} cancelled (${processed}/${unique.length})`);
          break;
        }

        const batch = unique.slice(i, i + CONFIG.MAX_CONCURRENCY);
        const settled = await Promise.allSettled(batch.map(t => fetchAdjacency(t, context)));
        
        settled.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            results.set(batch[idx], result.value);
          }
        });

        processed += batch.length;
        progress.increment(batch.length);
      }

      const hits = Array.from(results.values()).filter(r => r.cache_hit).length;
      progress.complete(`${label}: ${hits} cached, ${results.size - hits} new`);
      return results;
    }

    window.CognitionEngine.processing = {
      fetchAdjacency,
      batchFetchAdjacencies,
    };

    function calculateAttention(matrices) {
      for (const entry of matrices.values()) {
        let weightSum = 0, totalEdges = 0;
        const rels = entry?.relationships || {};
        
        for (const [rel, edges] of Object.entries(rels)) {
          const priority = RELATIONSHIP_PRIORITIES.get(rel) || 0.3;
          if (Array.isArray(edges)) {
            edges.forEach(edge => {
              weightSum += (edge.weight || 0) * priority;
              totalEdges++;
            });
          }
        }
        
        entry.attention_score = totalEdges > 0 ? Number((weightSum / totalEdges).toFixed(3)) : 0;
        entry.total_relationships = totalEdges;
      }
      return matrices;
    }

    function summarizeAttention(matrices) {
      const summary = [];
      for (const [token, data] of matrices.entries()) {
        summary.push({ 
          token, 
          attention: data.attention_score || 0, 
          total: data.total_relationships || 0 
        });
      }
      return summary.sort((a, b) => b.attention - a.attention).slice(0, 10);
    }

    function formatTopTokens(topTokens) {
      const { ledger } = generateGlyphLedger();
      return topTokens.map(t => {
        const glyphEntry = ledger.get(t.token);
        const glyph = glyphEntry ? glyphEntry.glyph : '‚óå';
        return `<span class="token-highlight">${glyph} ${t.token}</span> (${t.attention.toFixed(2)})`;
      }).join(', ');
    }

    function extractKeyRelationships(matrices) {
      const relationships = [];
      let count = 0;
      for (const [token, data] of matrices.entries()) {
        if (count >= 5) break;
        const rels = data?.relationships || {};
        for (const [rel, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges) || edges.length === 0) continue;
          const topEdge = edges.sort((a, b) => b.weight - a.weight)[0];
          relationships.push(`${token} ${rel} ${topEdge.token} (${topEdge.weight.toFixed(2)})`);
          count++;
          if (count >= 5) break;
        }
      }
      return relationships;
    }

    // ============================================
    // HLSF VISUALIZATION
    // ============================================

    function polygonVertices(center, radius, sides) {
      const vertices = [];
      const angleStep = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep - Math.PI / 2;
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return vertices;
    }

    function deriveAdjacencyPolygon(center, baseRadius, relationships) {
      const entries = Object.entries(relationships || {})
        .filter(([, edges]) => Array.isArray(edges) && edges.length > 0)
        .map(([relType, edges]) => {
          const weightSum = edges.reduce((sum, edge) => {
            const weight = typeof edge.weight === 'number' ? edge.weight : 0;
            return sum + weight;
          }, 0);
          const avgWeight = edges.length > 0 ? weightSum / edges.length : 0;
          return {
            relType,
            count: edges.length,
            avgWeight
          };
        })
        .sort((a, b) => a.relType.localeCompare(b.relType));

      if (entries.length === 0) {
        return {
          vertices: polygonVertices(center, baseRadius * 0.8, 3),
          anchorIndex: 0,
          adjacencyTypes: 0
        };
      }

      const vertexCount = Math.max(entries.length + 1, 3);
      const baseAngle = -Math.PI / 2;
      const angleStep = (2 * Math.PI) / vertexCount;
      const maxCount = Math.max(...entries.map(entry => entry.count));

      const vertices = [];
      const anchor = [center[0], center[1] - baseRadius];
      vertices.push(anchor);

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const normalizedWeight = Math.min(1, Math.max(0, entry.avgWeight));
        const countFactor = maxCount > 0 ? entry.count / maxCount : 0;
        const radialFactor = 0.85 + normalizedWeight * 0.35 + countFactor * 0.25;
        const radius = baseRadius * radialFactor;
        const angle = baseAngle + angleStep * (i + 1);
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }

      let fillerIndex = entries.length;
      while (vertices.length < 3) {
        const angle = baseAngle + angleStep * (fillerIndex + 1);
        vertices.push([
          center[0] + baseRadius * 0.75 * Math.cos(angle),
          center[1] + baseRadius * 0.75 * Math.sin(angle)
        ]);
        fillerIndex++;
      }

      return {
        vertices,
        anchorIndex: 0,
        adjacencyTypes: entries.length
      };
    }

    function buildBaseTriangles(vertices, sides) {
      if (sides < 3) return [];
      const triangles = [];
      const center = vertices.reduce((acc, v) =>
        [acc[0] + v[0] / sides, acc[1] + v[1] / sides], [0, 0]);

      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        triangles.push([center, vertices[i], vertices[next]]);
      }
      return triangles;
    }

    function rotateTrianglesAround(triangles, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return triangles.map(tri => tri.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      }));
    }

    function rotatePointsAround(points, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      });
    }

    function scalePointsAround(points, center, scale) {
      if (!Array.isArray(points)) return [];
      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * scale,
          center[1] + dy * scale
        ];
      });
    }

    function scaleTrianglesAround(triangles, center, scale) {
      if (!Array.isArray(triangles)) return [];
      return triangles.map(tri => scalePointsAround(tri, center, scale));
    }

    window.HLSF.geometry = {
      polygonVertices,
      buildBaseTriangles,
      rotateTrianglesAround,
      rotatePointsAround,
      scalePointsAround,
      scaleTrianglesAround,
      deriveAdjacencyPolygon,
    };

    let hlsfNodes = [];

    function buildHLSFNodes() {
      const graph = window.HLSF_GRAPH;
      let tokenRecords = [];

      if (graph?.tokens instanceof Map) {
        tokenRecords = Array.from(graph.tokens.values());
      } else if (graph?.tokens && typeof graph.tokens === 'object') {
        tokenRecords = Object.values(graph.tokens);
      }

      let sourceLabel = '';

      if (tokenRecords.length === 0) {
        const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
        console.log(`Scanning ${keys.length} cached tokens from storage for HLSF build`);

        for (const key of keys) {
          try {
            const tokenData = safeStorageGet(key);
            if (!tokenData?.token) {
              console.warn('Token missing from data:', key);
              continue;
            }
            tokenRecords.push(tokenData);
          } catch (err) {
            console.error('Failed to process token:', key, err);
          }
        }

        if (graph) {
          graph.tokens = new Map(tokenRecords.map(record => [record.token, record]));
        }

        sourceLabel = '(storage scan)';
      } else {
        sourceLabel = '(graph cache)';
      }

      console.log(`Building HLSF nodes from ${tokenRecords.length} cached tokens ${sourceLabel}`.trim());

      const nodes = [];

      for (const tokenData of tokenRecords) {
        try {
          const token = tokenData.token;

          if (!token) {
            console.warn('Token missing from data:', tokenData);
            continue;
          }

          const rels = tokenData.relationships || {};

          // Count adjacencies
          let adjacencyCount = 0;
          for (const edges of Object.values(rels)) {
            if (Array.isArray(edges)) adjacencyCount += edges.length;
          }
          const adjacencyTypes = Object.values(rels)
            .filter(edges => Array.isArray(edges) && edges.length > 0)
            .length;

          const attention = typeof tokenData.attention_score === 'number'
            ? tokenData.attention_score
            : 0.5;
          const complex = memoizedComplexNumber(token, { ...tokenData, attention_score: attention });
          const glyph = complexToGlyph(complex);

          // Position based on complex number
          const x = complex.real * 2;
          const y = complex.imaginary * 2;

          // Radius based on attention
          const radius = 0.3 + attention * 0.4;

          // Build polygon derived from adjacency structure
          const shape = deriveAdjacencyPolygon([x, y], radius, rels);
          const sides = shape.vertices.length;

          // Color based on attention
          let color;
          if (attention >= 0.8) color = [0, 255, 136];
          else if (attention >= 0.5) color = [255, 213, 79];
          else color = [255, 119, 119];

          nodes.push({
            token,
            glyph,
            center: [x, y],
            radius,
            sides,
            attention,
            adjacencyCount,
            adjacencyTypes,
            anchorIndex: shape.anchorIndex,
            color,
            vertices: shape.vertices,
            triangles: null // Will be computed
          });
        } catch (err) {
          console.error('Failed to process token for HLSF:', tokenData, err);
        }
      }

      console.log(`Built ${nodes.length} HLSF nodes`);
      
      // Generate triangles for each node
      for (const node of nodes) {
        try {
          node.triangles = buildBaseTriangles(node.vertices, node.sides);
        } catch (err) {
          console.error(`Failed to build triangles for ${node.token}:`, err);
          node.triangles = [];
        }
      }
      
      return nodes;
    }

    function initHLSFCanvas() {
      console.log('Initializing HLSF Canvas...');
      
      try {
        // Build nodes first to check if we have data
        hlsfNodes = buildHLSFNodes();
        
        if (hlsfNodes.length === 0) {
          logWarning('No cached tokens found for HLSF. Process some queries first to populate the database.');
          return;
        }
        
        console.log(`Creating canvas UI for ${hlsfNodes.length} nodes`);
        
        const container = document.createElement('div');
        container.className = 'hlsf-canvas-container';
      container.innerHTML = `
        <div style="margin-bottom: 1rem;">
          <div class="section-title">üåå HLSF: Hierarchical-Level Semantic Framework</div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">
            Geometric token visualization. Each polygon fans outward from a primary corner based on
            adjacency types, forming unique base-level shapes per matrix. Triangular subdivisions show
            hierarchical structure.
          </div>
        </div>
        <canvas id="hlsf-canvas" width="1200" height="600"></canvas>
        <div class="hlsf-controls">
          <div class="hlsf-control-group">
            <label>Rotation Speed</label>
            <input type="range" id="hlsf-rotation-speed" min="0" max="5" step="0.01" value="0.30">
            <span id="hlsf-speed-val">0.30</span>
          </div>

          <div class="hlsf-control-group">
            <label>Alpha Transparency</label>
            <input type="range" id="hlsf-alpha" min="0.005" max="0.99" step="0.01" value="0.10">
            <span id="hlsf-alpha-val">0.10</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>View Controls</label>
            <div class="hlsf-button-row">
              <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
              <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
              <button id="hlsf-zoom-portal" class="btn btn-secondary">Portal</button>
              <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Rotation Modes</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-rotation" class="btn btn-primary">Start Global</button>
              <button id="hlsf-toggle-emergent" class="btn btn-success">Start Emergence</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Display Options</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-edges" class="btn btn-neutral">Edges: On</button>
              <button id="hlsf-toggle-labels" class="btn btn-neutral">Labels: On</button>
              <button id="hlsf-toggle-bg" class="btn btn-neutral">BG: Dark</button>
            </div>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.85rem;">
          <strong>Controls:</strong> Drag to pan ‚Ä¢ Scroll to zoom ‚Ä¢ Each polygon = token matrix ‚Ä¢
          Fan vertices = adjacency types ‚Ä¢ Color = attention score<br>
          <strong>Modes:</strong> Global rotation = all polygons rotate around center ‚Ä¢ 
          Emergent rotation = each polygon rotates around its own center
        </div>
      `;
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
      entry.appendChild(container);
      elements.log.appendChild(entry);
      elements.log.scrollTop = elements.log.scrollHeight;
      
      // Initialize canvas
      window.HLSF.canvas = document.getElementById('hlsf-canvas');
      window.HLSF.ctx = window.HLSF.canvas.getContext('2d');
      
      console.log('Canvas initialized:', window.HLSF.canvas ? 'success' : 'failed');
      
      // Setup controls
      const speedSlider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (speedSlider && speedVal) {
        const omega = Number.isFinite(window.HLSF.config.rotationOmega)
          ? window.HLSF.config.rotationOmega
          : 0;
        speedSlider.value = omega.toFixed(2);
        speedVal.textContent = omega.toFixed(2);
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        const alpha = baseAlpha();
        alphaSlider.value = alpha.toFixed(2);
        alphaVal.textContent = alpha.toFixed(2);
        window.HLSF.config.alpha = alpha;
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }
      
      const globalZoomIn = document.getElementById('hlsf-zoom-in');
      if (globalZoomIn) {
        globalZoomIn.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 1.2));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const globalZoomOut = document.getElementById('hlsf-zoom-out');
      if (globalZoomOut) {
        globalZoomOut.addEventListener('click', () => {
          const view = window.HLSF.view;
          const next = Math.min(12, Math.max(0.25, view.scale * 0.8));
          window.HLSF.view.scale = next;
          syncViewToConfig();
          requestRender();
        });
      }

      const globalReset = document.getElementById('hlsf-reset-view');
      if (globalReset) {
        globalReset.addEventListener('click', () => {
          window.HLSF.view.scale = 1;
          const canvasEl = window.HLSF.canvas;
          if (canvasEl) {
            const width = canvasEl.clientWidth || canvasEl.width;
            const height = canvasEl.clientHeight || canvasEl.height;
            window.HLSF.view.x = width / 2;
            window.HLSF.view.y = height / 2;
          } else {
            window.HLSF.view.x = 0;
            window.HLSF.view.y = 0;
          }
          syncViewToConfig();
          requestRender();
        });
      }

      const globalPortal = document.getElementById('hlsf-zoom-portal');
      if (globalPortal) {
        globalPortal.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          if (!canvasEl) return;
          const width = canvasEl.clientWidth || canvasEl.width;
          const height = canvasEl.clientHeight || canvasEl.height;
          animateViewport({
            x: width / 2,
            y: height / 2,
            scale: Math.max(1.5, window.HLSF.view.scale * 2),
          }, 350);
        });
      }

      const rotationBtn = document.getElementById('hlsf-toggle-rotation');
      rotationBtn.addEventListener('click', () => {
        window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
        if (window.HLSF.config.rotationActive) {
          window.HLSF.state.emergent.on = false;
          window.HLSF.config.emergentActive = false;
          document.getElementById('hlsf-toggle-emergent').textContent = 'Start Emergence';
        }
        rotationBtn.textContent = window.HLSF.config.rotationActive ? 'Stop Global' : 'Start Global';
        requestRender();
      });

      const emergentBtn = document.getElementById('hlsf-toggle-emergent');
      emergentBtn.addEventListener('click', () => {
        const state = window.HLSF.state.emergent;
        state.on = !state.on;
        window.HLSF.config.emergentActive = state.on;
        if (state.on) {
          window.HLSF.config.rotationActive = false;
          document.getElementById('hlsf-toggle-rotation').textContent = 'Start Global';
        }
        emergentBtn.textContent = state.on ? 'Stop Emergence' : 'Start Emergence';
        requestRender();
      });
      
      const edgesBtn = document.getElementById('hlsf-toggle-edges');
      edgesBtn.addEventListener('click', () => {
        window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
        edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
        debouncedLegacyRender();
      });

      const labelsBtn = document.getElementById('hlsf-toggle-labels');
      labelsBtn.addEventListener('click', () => {
        window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
        labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
        debouncedLegacyRender();
      });

      const bgBtn = document.getElementById('hlsf-toggle-bg');
      bgBtn.addEventListener('click', () => {
        window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
        bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
        debouncedLegacyRender();
      });
      
      // Mouse interaction
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      
      window.HLSF.canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      window.HLSF.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.view.x += dx;
          window.HLSF.view.y += dy;
          syncViewToConfig();
          lastX = e.clientX;
          lastY = e.clientY;
          requestRender();
        }
      });
      
      window.HLSF.canvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        window.HLSF.view.scale = Math.min(12, Math.max(0.25, window.HLSF.view.scale * factor));
        syncViewToConfig();
        requestRender();
      }, { passive: false });
      
      // Center view
      if (window.HLSF.canvas) {
        const width = window.HLSF.canvas.clientWidth || window.HLSF.canvas.width;
        const height = window.HLSF.canvas.clientHeight || window.HLSF.canvas.height;
        window.HLSF.view.x = width / 2;
        window.HLSF.view.y = height / 2;
      } else {
        window.HLSF.view.x = 0;
        window.HLSF.view.y = 0;
      }
      syncViewToConfig();
      
      // Build nodes
      window.HLSF.nodes = hlsfNodes;
      
      // Initial render
      renderLegacyHLSF();

      // Start animation
      animateLegacyHLSF();
      
      logOK(`HLSF visualization initialized with ${hlsfNodes.length} token matrices`);
      
      } catch (err) {
        logError(`Failed to initialize HLSF canvas: ${err.message}`);
        console.error('HLSF canvas error:', err);
        throw err;
      }
    }

    function strokePolygon(ctx, verts) {
      if (!verts || verts.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(verts[0][0], verts[0][1]);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i][0], verts[i][1]);
      ctx.closePath();
      ctx.stroke();
    }

    function strokeTriangles(ctx, tris) {
      if (!tris) return;
      for (const t of tris) strokePolygon(ctx, t);
    }

    function worldToScreen(x, y) {
      const sx = x * (200 * window.HLSF.config.scale) + window.HLSF.config.tx;
      const sy = -y * (200 * window.HLSF.config.scale) + window.HLSF.config.ty;
      return [sx, sy];
    }

    function renderLegacyHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not initialized for renderHLSF');
        return;
      }

      try {
        const ctx = window.HLSF.ctx;
        const width = window.HLSF.canvas.width;
        const height = window.HLSF.canvas.height;
        const theme = window.HLSF.config.whiteBg
          ? { bg: '#ffffff', fg: '#000000', grid: 'rgba(0, 0, 0, 0.05)' }
          : { bg: '#0a0a0a', fg: '#ffffff', grid: 'rgba(0, 255, 136, 0.05)' };
        const nodeScale = clampNodeSize(window.HLSF.config.nodeSize);
        const edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
        const edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
        const effectiveEdgeWidth = edgeWidth * Math.max(0.6, window.HLSF.config.scale || 1);

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = theme.bg;
        ctx.strokeStyle = theme.fg;
        ctx.lineWidth = 1;

        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = theme.grid;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        ctx.strokeStyle = theme.fg;
        if (window.HLSF.config.fillFaces === true) {
          /* intentionally unused now */
        }

        for (const node of window.HLSF.nodes) {
          let triangles = Array.isArray(node.triangles) ? node.triangles : [];
          let vertices = Array.isArray(node.vertices) ? node.vertices : [];
          let centerPoint = Array.isArray(node.center) ? node.center : [0, 0];
          const nodeColor = Array.isArray(node.color) ? node.color : [0, 255, 136];
          const [r, g, b] = nodeColor;

          if (window.HLSF.config.emergentActive) {
            const angle = window.HLSF.state?.emergentRot ?? 0;
            triangles = rotateTrianglesAround(triangles, node.center, angle);
            vertices = rotatePointsAround(vertices, node.center, angle);
          } else if (window.HLSF.config.rotationActive) {
            const angle = window.HLSF.state?.globalRot ?? 0;
            triangles = rotateTrianglesAround(triangles, [0, 0], angle);
            vertices = rotatePointsAround(vertices, [0, 0], angle);
            centerPoint = rotatePointsAround([node.center], [0, 0], angle)[0];
          }

          const scalePivot = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
            ? centerPoint
            : node.center;
          if (Math.abs(nodeScale - 1) > 1e-3) {
            triangles = scaleTrianglesAround(triangles, scalePivot, nodeScale);
            vertices = scalePointsAround(vertices, scalePivot, nodeScale);
          }

          triangles = Array.isArray(triangles) ? triangles : [];
          vertices = Array.isArray(vertices) ? vertices : [];

          const screenTriangles = triangles.map(tri => tri.map(([x, y]) => worldToScreen(x, y)));
          const screenVertices = vertices.map(([x, y]) => worldToScreen(x, y));

          ctx.globalAlpha = baseAlpha();
          ctx.strokeStyle = theme.fg;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.save();
          if (window.HLSF.config.showNodeGlow) {
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.35)`;
            ctx.shadowBlur = 16 * Math.max(1, window.HLSF.config.scale || 1);
          }

          strokePolygon(ctx, screenVertices);
          strokeTriangles(ctx, screenTriangles);
          ctx.restore();

          if (window.HLSF.config.showEdges && screenVertices.length > 1) {
            const anchorIndex = typeof node.anchorIndex === 'number' ? node.anchorIndex : 0;
            const anchor = screenVertices[anchorIndex];
            for (let i = 0; i < screenVertices.length; i++) {
              if (i === anchorIndex) continue;
              const [vx, vy] = screenVertices[i];
              const strokeColor = nodeEdgeStrokeColor(node, i, edgeColorMode) || theme.fg;
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = effectiveEdgeWidth;
              ctx.beginPath();
              ctx.moveTo(anchor[0], anchor[1]);
              ctx.lineTo(vx, vy);
              ctx.stroke();
            }
            ctx.strokeStyle = theme.fg;
          }

          ctx.globalAlpha = 1.0;

          if (window.HLSF.config.showLabels) {
            const centerForLabel = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
              ? centerPoint
              : node.center;
            const [sx, sy] = worldToScreen(centerForLabel[0], centerForLabel[1]);
            ctx.save();
            if (window.HLSF.config.showNodeGlow) {
              ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
              ctx.shadowBlur = 18 * Math.max(1, window.HLSF.config.scale || 1);
            }
            ctx.globalAlpha = baseAlpha();
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
            ctx.font = `${Math.max(12, 20 * window.HLSF.config.scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.glyph, sx, sy);
            ctx.restore();

            ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${Math.max(9, 11 * window.HLSF.config.scale)}px Fira Code, monospace`;
            ctx.fillText(node.token, sx, sy + 25 * window.HLSF.config.scale);
            ctx.globalAlpha = 1.0;
          }
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
        ctx.font = '12px Fira Code, monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Nodes: ${window.HLSF.nodes.length} | Zoom: ${window.HLSF.config.scale.toFixed(2)}x`, 10, 20);

      } catch (err) {
        console.error('Error rendering HLSF:', err);
      }
    }

    const debouncedLegacyRender = debounce(() => {
      if (window.HLSF?.currentGraph) {
        drawComposite(window.HLSF.currentGraph, { glyphOnly: window.HLSF.currentGlyphOnly === true });
      } else {
        renderLegacyHLSF();
      }
    }, 16);

    function requestRender() {
      debouncedLegacyRender();
    }

    function animateViewport(target, ms = 300) {
      const view = window.HLSF.view;
      const start = performance.now();
      const s0 = { x: view.x, y: view.y, scale: view.scale };
      const duration = Number.isFinite(ms) ? Math.max(16, ms) : 300;
      function step(t) {
        const k = Math.min(1, (t - start) / duration);
        const eased = k * (2 - k);
        view.x = s0.x + eased * ((target?.x ?? s0.x) - s0.x);
        view.y = s0.y + eased * ((target?.y ?? s0.y) - s0.y);
        const targetScale = Number.isFinite(target?.scale) ? Math.max(0.1, target.scale) : s0.scale;
        view.scale = s0.scale + eased * (targetScale - s0.scale);
        syncViewToConfig();
        requestRender();
        if (k < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    let _legacyLast = null;
    function animateLegacyHLSF(now) {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not ready for animation');
        return;
      }

      try {
        const timestamp = typeof now === 'number' ? now : performance.now();
        const last = _legacyLast ?? timestamp;
        const dt = (timestamp - last) / 1000;
        _legacyLast = timestamp;
        stepRotation(dt);

        if (window.HLSF.config.rotationActive || window.HLSF.config.emergentActive) {
          renderLegacyHLSF();
        }
      } catch (err) {
        console.error('Error in HLSF animation:', err);
      }

      window.HLSF.animationFrame = requestAnimationFrame(animateLegacyHLSF);
    }

    function stopLegacyHLSFAnimation() {
      try {
        if (window.HLSF && window.HLSF.animationFrame) {
          cancelAnimationFrame(window.HLSF.animationFrame);
          window.HLSF.animationFrame = null;
        }
        if (window.HLSF && window.HLSF.config) {
          window.HLSF.config.rotationActive = false;
          window.HLSF.config.emergentActive = false;
        }
        if (window.HLSF?.state?.emergent) {
          window.HLSF.state.emergent.on = false;
          window.HLSF.state.emergentRot = 0;
        }
        _legacyLast = null;
      } catch (err) {
        console.warn('Error stopping HLSF animation:', err);
      }
    }

    window.HLSF.rendering = {
      render: renderLegacyHLSF,
      animate: animateLegacyHLSF,
      stop: stopLegacyHLSFAnimation,
    };
    function computeRelHistogramEntries(db) {
      const hist = new Map();
      for (const rec of db.full_token_data || []) {
        const rels = rec?.relationships || {};
        for (const key of Object.keys(rels)) {
          const glyph = normalizeRelKeyForStats(key);
          if (!glyph) continue;
          const edges = Array.isArray(rels[key]) ? rels[key] : [];
          if (!edges.length) continue;
          hist.set(glyph, (hist.get(glyph) || 0) + edges.length);
        }
      }
      return [...hist.entries()].sort((a, b) => b[1] - a[1]);
    }

    function computeRelHistogram(db, entries){
      const base = Array.isArray(entries) ? entries : computeRelHistogramEntries(db);
      return base.map(([glyph, count]) => renderRelTypeRow(glyph, count));
    }

    function edgeSignatureForMerge(edge) {
      if (!edge || typeof edge !== 'object') return '';
      const token = edge.token ?? '';
      const relType = edge.type ?? edge.relationship ?? '';
      const weight = Number.isFinite(edge.weight)
        ? edge.weight
        : Number.isFinite(edge.w)
          ? edge.w
          : Number.isFinite(edge.attention)
            ? edge.attention
            : 0;
      return `${token}::${relType}::${weight}`;
    }

    function mergeRelationshipLists(existing, incoming) {
      const base = Array.isArray(existing) ? existing : [];
      const next = Array.isArray(incoming) ? incoming : [];
      if (base.length === 0) return next.slice();
      if (next.length === 0) return base.slice();

      const merged = base.slice();
      const seen = new Set(base.map(edgeSignatureForMerge));
      for (const edge of next) {
        const sig = edgeSignatureForMerge(edge);
        if (!seen.has(sig)) {
          seen.add(sig);
          merged.push(edge);
        }
      }
      return merged;
    }

    function mergeTokenRecords(existing, incoming) {
      if (!existing) return incoming;
      if (!incoming) return existing;

      const merged = Object.assign({}, existing, incoming);
      const baseRels = existing.relationships || {};
      const incomingRels = incoming.relationships || {};
      const relKeys = new Set([...Object.keys(baseRels), ...Object.keys(incomingRels)]);
      const outRels = {};
      for (const key of relKeys) {
        outRels[key] = mergeRelationshipLists(baseRels[key], incomingRels[key]);
      }
      merged.relationships = outRels;
      if (!merged.cached_at) {
        merged.cached_at = existing.cached_at || incoming.cached_at || null;
      }
      return merged;
    }

    function analyzeDatabaseMetadata() {
      const tokenFrequency = new Map();
      const index = new Map();
      let totalAttentionScore = 0;
      let oldestToken = null;
      let newestToken = null;

      const addRecord = (rec) => {
        const normalized = normalizeRecord(rec);
        if (!normalized) return;
        const existing = index.get(normalized.token);
        const merged = mergeTokenRecords(existing, normalized);
        index.set(normalized.token, merged);
      };

      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) addRecord(rec);
      }

      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const key of keys) {
        try {
          const data = safeStorageGet(key);
          if (data && typeof data === 'object') {
            addRecord(data);
          }
        } catch (err) {
          console.error('Failed to parse token:', key, err);
        }
      }

      const tokens = Array.from(index.values());

      const relTypeMaxCache = new Map();
      let maxAdjacencyMatrixCount = 0;
      const maxAdjacencyMatrixTokens = new Set();

      const cachedTokenSet = new Set();
      for (const key of index.keys()) {
        if (key == null) continue;
        cachedTokenSet.add(String(key).toLowerCase());
      }

      const sessionTokenSet = window.Session?.tokens instanceof Set ? window.Session.tokens : new Set();
      let cachedSessionTokens = 0;
      for (const token of sessionTokenSet) {
        if (!token) continue;
        if (cachedTokenSet.has(String(token).toLowerCase())) {
          cachedSessionTokens += 1;
        }
      }
      const sessionTokenCount = sessionTokenSet instanceof Set ? sessionTokenSet.size : 0;
      const sessionCoverage = sessionTokenCount > 0 ? cachedSessionTokens / sessionTokenCount : 0;

      for (const data of tokens) {
        if (!data || typeof data !== 'object') continue;

        if (data.cached_at) {
          const timestamp = new Date(data.cached_at);
          if (!Number.isNaN(timestamp.getTime())) {
            if (!oldestToken || timestamp < new Date(oldestToken.cached_at)) {
              oldestToken = data;
            }
            if (!newestToken || timestamp > new Date(newestToken.cached_at)) {
              newestToken = data;
            }
          }
        }

        const rels = data.relationships || {};
        const adjacencyNeighbors = new Set();
        for (const [relType, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges)) continue;
          const glyph = normalizeRelKeyForStats(relType);
          if (!glyph) continue;

          const uniqueTargets = new Set();

          for (const edge of edges) {
            const rawToken = edge?.token;
            const normalizedToken = typeof rawToken === 'string' ? rawToken.trim() : '';
            if (normalizedToken) {
              const freqKey = normalizedToken.toLowerCase();
              tokenFrequency.set(freqKey, (tokenFrequency.get(freqKey) || 0) + 1);
              adjacencyNeighbors.add(normalizedToken);
              uniqueTargets.add(normalizedToken);
            }
          }

          if (uniqueTargets.size > 0) {
            const entry = relTypeMaxCache.get(glyph);
            if (!entry || uniqueTargets.size > entry.count) {
              const tokensWithPeak = new Set();
              const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
              if (sourceToken) tokensWithPeak.add(sourceToken);
              relTypeMaxCache.set(glyph, { count: uniqueTargets.size, tokens: tokensWithPeak });
            } else if (uniqueTargets.size === entry.count) {
              const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
              if (sourceToken) entry.tokens.add(sourceToken);
            }
          }
        }

        if (adjacencyNeighbors.size > 0) {
          if (adjacencyNeighbors.size > maxAdjacencyMatrixCount) {
            maxAdjacencyMatrixCount = adjacencyNeighbors.size;
            maxAdjacencyMatrixTokens.clear();
            const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
            if (sourceToken) maxAdjacencyMatrixTokens.add(sourceToken);
          } else if (adjacencyNeighbors.size === maxAdjacencyMatrixCount) {
            const sourceToken = typeof data.token === 'string' ? data.token.trim() : '';
            if (sourceToken) maxAdjacencyMatrixTokens.add(sourceToken);
          }
        }

        if (data.attention_score) {
          totalAttentionScore += data.attention_score;
        }
      }

      const limitList = (collection, max = 10) => {
        const out = [];
        if (!collection) return out;
        if (Array.isArray(collection)) {
          for (const value of collection) {
            if (value == null || value === '') continue;
            out.push(value);
            if (out.length >= max) break;
          }
          return out;
        }
        if (typeof collection[Symbol.iterator] === 'function') {
          for (const value of collection) {
            if (value == null || value === '') continue;
            out.push(value);
            if (out.length >= max) break;
          }
        }
        return out;
      };

      let maxRelTypeCount = 0;
      const maxRelTypeEntries = [];
      for (const [glyph, info] of relTypeMaxCache.entries()) {
        if (!info || !Number.isFinite(info.count)) continue;
        if (info.count <= 0) continue;
        if (info.count > maxRelTypeCount) {
          maxRelTypeCount = info.count;
          maxRelTypeEntries.length = 0;
        }
        if (info.count === maxRelTypeCount) {
          maxRelTypeEntries.push({
            type: glyph,
            tokens: limitList(info.tokens, 10),
          });
        }
      }

      const maxAdjacencyMatrixSummary = {
        count: maxAdjacencyMatrixCount,
        tokens: limitList(maxAdjacencyMatrixTokens, 10),
      };

      const relHistogramEntries = computeRelHistogramEntries({ full_token_data: tokens });
      const relHistogramRows = computeRelHistogram(null, relHistogramEntries);
      const dbStats = computeDbStats(index);
      const totalRelationships = dbStats.relationships;
      const topRelationships = relHistogramEntries.slice(0, 10);
      const topRelationshipRows = relHistogramRows.slice(0, 10);

      const topTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);

      const highAttentionTokens = tokens
        .filter(t => t?.attention_score)
        .sort((a, b) => (b.attention_score || 0) - (a.attention_score || 0))
        .slice(0, 10);

      const adjacencyCostPerToken = estimateCostUsd(
        CONFIG.ADJACENCY_TOKEN_ESTIMATES.prompt,
        CONFIG.ADJACENCY_TOKEN_ESTIMATES.completion
      );

      return {
        totalTokens: dbStats.tokens,
        totalRelationships,
        avgAttentionScore: tokens.length > 0 ? (totalAttentionScore / tokens.length).toFixed(3) : 0,
        topRelationships,
        topRelationshipRows,
        relHistogramRows,
        topTokens,
        highAttentionTokens,
        oldestToken,
        newestToken,
        estimatedValue: tokens.length * adjacencyCostPerToken,
        rawData: tokens,
        dbStats,
        sessionTokenCount,
        cachedSessionTokens,
        sessionCoverage,
        maxRelTypeTokens: {
          count: maxRelTypeCount,
          types: maxRelTypeEntries,
        },
        maxAdjacencyMatrixTokens: maxAdjacencyMatrixSummary,
      };
    }

    function showDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      const dbStats = Object.assign({
        tokens: metadata.totalTokens,
        relationships: metadata.totalRelationships,
        nodes: 0,
        edges: 0,
        anchors: 0,
        minEdges: { count: 0, tokens: [] },
        maxEdges: { count: 0, tokens: [] },
      }, metadata.dbStats || {});

      const formatEdgeTokens = (edgeInfo) => {
        if (!edgeInfo || !Array.isArray(edgeInfo.tokens) || edgeInfo.tokens.length === 0) {
          return '';
        }
        const maxDisplay = 5;
        const rendered = edgeInfo.tokens.slice(0, maxDisplay)
          .map(token => `<span class="token-highlight">${token}</span>`)
          .join(', ');
        const extraCount = edgeInfo.tokens.length - maxDisplay;
        const extra = extraCount > 0
          ? ` <small style="opacity: 0.65;">(+${extraCount} more)</small>`
          : '';
        return `${rendered}${extra}`;
      };

      const formatEdgeSummary = (edgeInfo) => {
        const count = Number.isFinite(edgeInfo?.count) ? edgeInfo.count : 0;
        const tokensDisplay = formatEdgeTokens(edgeInfo);
        if (tokensDisplay) {
          return `<strong>${count}</strong> (${tokensDisplay})`;
        }
        if ((dbStats.tokens || 0) === 0) {
          return `<strong>${count}</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        return `<strong>${count}</strong>`;
      };

      const minEdgeSummary = formatEdgeSummary(dbStats.minEdges);
      const maxEdgeSummary = formatEdgeSummary(dbStats.maxEdges);

      const sessionTokenCount = metadata.sessionTokenCount || 0;
      const coverageRatioRaw = (typeof metadata.sessionCoverage === 'number' && Number.isFinite(metadata.sessionCoverage))
        ? metadata.sessionCoverage
        : 0;
      const coverageRatio = Math.min(Math.max(coverageRatioRaw, 0), 1);
      const coverageDisplay = sessionTokenCount > 0 ? `${(coverageRatio * 100).toFixed(1)}%` : '0.0%';
      const coverageCountSummary = sessionTokenCount > 0
        ? `Coverage: <strong>${metadata.cachedSessionTokens || 0}</strong> / <strong>${sessionTokenCount}</strong> (${coverageDisplay})`
        : 'Coverage: No session tokens observed yet';

      const formatHighlightList = (tokens, maxDisplay = 5) => {
        if (!Array.isArray(tokens) || tokens.length === 0) return '';
        const rendered = tokens.slice(0, maxDisplay)
          .map(token => `<span class="token-highlight">${token}</span>`)
          .join(', ');
        const extraCount = tokens.length - maxDisplay;
        const extra = extraCount > 0
          ? ` <small style="opacity: 0.65;">(+${extraCount} more)</small>`
          : '';
        return `${rendered}${extra}`;
      };

      const maxRelTypeTokens = metadata.maxRelTypeTokens || { count: 0, types: [] };
      const maxRelTypeSummary = (() => {
        const count = Number.isFinite(maxRelTypeTokens?.count) ? maxRelTypeTokens.count : 0;
        if (count <= 0) {
          return `<strong>0</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        const entries = Array.isArray(maxRelTypeTokens.types) ? maxRelTypeTokens.types : [];
        if (entries.length === 0) {
          return `<strong>${count}</strong>`;
        }
        const [primary, ...rest] = entries;
        const typeLabel = primary?.type ? relDisplay(primary.type) : 'Unknown';
        const tokenDisplay = formatHighlightList(primary?.tokens || []);
        const extraTypes = rest.length;
        const extraTypeNote = extraTypes > 0
          ? ` <small style="opacity: 0.65;">(+${extraTypes} other type${extraTypes === 1 ? '' : 's'})</small>`
          : '';
        const tokenNote = tokenDisplay ? ` ‚Äî ${tokenDisplay}` : '';
        return `<strong>${count}</strong> via <span class="token-highlight">${typeLabel}</span>${tokenNote}${extraTypeNote}`;
      })();

      const maxAdjacencyMatrixTokens = metadata.maxAdjacencyMatrixTokens || { count: 0, tokens: [] };
      const maxAdjacencySummary = (() => {
        const count = Number.isFinite(maxAdjacencyMatrixTokens?.count) ? maxAdjacencyMatrixTokens.count : 0;
        if (count <= 0) {
          return `<strong>0</strong> <small style="opacity: 0.65;">(n/a)</small>`;
        }
        const tokenDisplay = formatHighlightList(maxAdjacencyMatrixTokens.tokens || []);
        return tokenDisplay
          ? `<strong>${count}</strong> ‚Äî ${tokenDisplay}`
          : `<strong>${count}</strong>`;
      })();

      let maturityLevel;
      let maturityColor;
      let maturityMessage;
      if (sessionTokenCount === 0) {
        maturityLevel = 'Early';
        maturityColor = 'var(--accent)';
        maturityMessage = 'No session tokens analyzed yet. Run a prompt to begin building cache coverage.';
      } else if (coverageRatio >= 0.95) {
        maturityLevel = 'Mature';
        maturityColor = 'var(--success)';
        maturityMessage = 'Cached knowledge covers 95%+ of observed inputs and outputs. Most queries reuse stored insights.';
      } else if (coverageRatio >= 0.6) {
        maturityLevel = 'Growing';
        maturityColor = 'var(--warning)';
        maturityMessage = 'Coverage is building. Many session tokens are cached but new ones still appear.';
      } else {
        maturityLevel = 'Early';
        maturityColor = 'var(--accent)';
        maturityMessage = 'Cache coverage is limited. Expect frequent new adjacency generation.';
      }

      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">üìä Collective Database Metadata</div>
        
        <div class="adjacency-insight">
          <strong>üåê Knowledge Base Status:</strong> <span style="color: ${maturityColor}; font-weight: bold;">${maturityLevel}</span><br>
          <small style="opacity: 0.8;">${maturityMessage}</small><br>
          <small style="opacity: 0.8; display: block; margin-top: 0.25rem;">${coverageCountSummary}</small>
        </div>

        <div class="adjacency-insight">
          <strong>üíæ Database Size:</strong><br>
          ‚Ä¢ Total cached tokens: <strong>${metadata.totalTokens}</strong><br>
          ‚Ä¢ Total relationships: <strong>${metadata.totalRelationships}</strong><br>
          ‚Ä¢ Graph nodes (‚â•1 outgoing): <strong>${dbStats.nodes}</strong><br>
          ‚Ä¢ Edge types enumerated: <strong>${dbStats.edges}</strong><br>
          ‚Ä¢ Anchors (in ‚à© out): <strong>${dbStats.anchors}</strong><br>
          ‚Ä¢ Minimum edges per token: ${minEdgeSummary}<br>
          ‚Ä¢ Maximum edges per token: ${maxEdgeSummary}<br>
          ‚Ä¢ Max tokens in a relationship type: ${maxRelTypeSummary}<br>
          ‚Ä¢ Max tokens per adjacency matrix: ${maxAdjacencySummary}<br>
          ‚Ä¢ Average attention score: <strong>${metadata.avgAttentionScore}</strong><br>
          ‚Ä¢ Network density: <strong>${(metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)}</strong> edges/token<br>
          ‚Ä¢ Estimated saved cost: <strong>${formatCurrency(metadata.estimatedValue || 0)}</strong>
        </div>

        <div class="adjacency-insight">
          <strong>üìà Most Common Relationship Types:</strong><br>
          ${metadata.topRelationshipRows.map(row =>
            `‚Ä¢ <span class="token-highlight">${row}</span>`
          ).join('<br>')}
          ${metadata.topRelationshipRows.length === 0 ? '<em>No relationships cached yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>üî• Most Referenced Tokens (Hub Concepts):</strong><br>
          <small style="opacity: 0.8;">These tokens appear most frequently across relationships - they represent core concepts in the knowledge graph.</small><br><br>
          ${metadata.topTokens.slice(0, 10).map(([token, count]) => 
            `‚Ä¢ <span class="token-highlight">${token}</span>: ${count} references`
          ).join('<br>')}
          ${metadata.topTokens.length === 0 ? '<em>No hub concepts identified yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>‚≠ê Highest Attention Tokens:</strong><br>
          <small style="opacity: 0.8;">Tokens with the strongest weighted relationships - highly salient concepts.</small><br><br>
          ${metadata.highAttentionTokens.map(t => 
            `‚Ä¢ <span class="token-highlight">${t.token}</span>: ${t.attention_score} (${t.total_relationships || 0} edges)`
          ).join('<br>')}
          ${metadata.highAttentionTokens.length === 0 ? '<em>No high-attention tokens yet</em>' : ''}
        </div>

        ${metadata.oldestToken ? `
        <div class="adjacency-insight">
          <strong>üìÖ Database Timeline:</strong><br>
          ‚Ä¢ Oldest entry: <strong>${metadata.oldestToken.token}</strong> (${new Date(metadata.oldestToken.cached_at).toLocaleString()})<br>
          ‚Ä¢ Newest entry: <strong>${metadata.newestToken.token}</strong> (${new Date(metadata.newestToken.cached_at).toLocaleString()})
        </div>
        ` : ''}

        <details>
          <summary>üìä View knowledge graph analytics</summary>
          <pre>${JSON.stringify({
            database_maturity: maturityLevel,
            network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
            top_5_relationship_types: metadata.topRelationships.slice(0, 5).map(([rel]) => relDisplay(rel)),
            relationship_histogram_named: metadata.relHistogramRows,
            top_5_hub_concepts: metadata.topTokens.slice(0, 5).map(([token]) => token),
            db_graph_metrics: dbStats,
            relationship_type_peaks: {
              max_tokens: metadata.maxRelTypeTokens?.count || 0,
              types: (metadata.maxRelTypeTokens?.types || []).map(entry => ({
                type: entry.type,
                type_display: relDisplay(entry.type),
                tokens: entry.tokens,
              })),
            },
            adjacency_matrix_peaks: {
              max_tokens: metadata.maxAdjacencyMatrixTokens?.count || 0,
              tokens: metadata.maxAdjacencyMatrixTokens?.tokens || [],
            },
            growth_metrics: {
              tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
              avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)
            },
            session_cache_coverage: {
              observed_tokens: sessionTokenCount,
              cached_tokens: metadata.cachedSessionTokens || 0,
              coverage_ratio: Number(coverageRatio.toFixed(3)),
              coverage_percent: sessionTokenCount > 0 ? Number((coverageRatio * 100).toFixed(1)) : 0
            }
          }, null, 2)}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          üí° <strong>Insight:</strong> This metadata represents the collective intelligence being built. 
          In a server deployment, this would be shared across all users, with each query contributing 
          to a growing knowledge base that makes future queries faster and cheaper. The database also 
          powers the symbolic glyph encryption system for secure inter-system communication.
        </div>
      `);
    }

    function exportDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      const dbStats = Object.assign({
        tokens: metadata.totalTokens,
        relationships: metadata.totalRelationships,
        nodes: 0,
        edges: 0,
        anchors: 0,
        minEdges: { count: 0, tokens: [] },
        maxEdges: { count: 0, tokens: [] },
      }, metadata.dbStats || {});

      const sessionTokenCount = metadata.sessionTokenCount || 0;
      const coverageRatioRaw = (typeof metadata.sessionCoverage === 'number' && Number.isFinite(metadata.sessionCoverage))
        ? metadata.sessionCoverage
        : 0;
      const coverageRatio = Math.min(Math.max(coverageRatioRaw, 0), 1);
      const coveragePercent = sessionTokenCount > 0 ? Number((coverageRatio * 100).toFixed(1)) : 0;
      const maturityLevel = sessionTokenCount === 0
        ? 'early'
        : (coverageRatio >= 0.95 ? 'mature' : coverageRatio >= 0.6 ? 'growing' : 'early');

      const exportData = {
        export_timestamp: new Date().toISOString(),
        readme: {
          description: "HLSF Cognition Engine - Collective Database Metadata Export",
          purpose: "This export contains the complete adjacency token database and analytics. It represents the collective intelligence built through token relationship analysis.",
          usage: "This data can be imported into a server-side database to bootstrap a new deployment or shared for analysis.",
          version: "2.0"
        },
        database_stats: {
          total_tokens: metadata.totalTokens,
          total_relationships: metadata.totalRelationships,
          graph_nodes: dbStats.nodes,
          edge_types_enumerated: dbStats.edges,
          anchors: dbStats.anchors,
          min_edges_per_token: {
            count: Number.isFinite(dbStats.minEdges?.count) ? dbStats.minEdges.count : 0,
            tokens: Array.isArray(dbStats.minEdges?.tokens) ? dbStats.minEdges.tokens : [],
          },
          max_edges_per_token: {
            count: Number.isFinite(dbStats.maxEdges?.count) ? dbStats.maxEdges.count : 0,
            tokens: Array.isArray(dbStats.maxEdges?.tokens) ? dbStats.maxEdges.tokens : [],
          },
          max_tokens_per_relationship_type: {
            count: metadata.maxRelTypeTokens?.count || 0,
            types: (metadata.maxRelTypeTokens?.types || []).map(entry => ({
              type: entry.type,
              type_display: relDisplay(entry.type),
              tokens: entry.tokens,
            })),
          },
          max_tokens_per_adjacency_matrix: {
            count: metadata.maxAdjacencyMatrixTokens?.count || 0,
            tokens: metadata.maxAdjacencyMatrixTokens?.tokens || [],
          },
          avg_attention_score: metadata.avgAttentionScore,
          estimated_value_usd: metadata.estimatedValue.toFixed(2),
          maturity_level: maturityLevel,
          session_token_count: sessionTokenCount,
          session_tokens_cached: metadata.cachedSessionTokens || 0,
          session_token_coverage_ratio: Number(coverageRatio.toFixed(3)),
          session_token_coverage_percent: coveragePercent
        },
        relationship_distribution: Object.fromEntries(metadata.topRelationships),
        relationship_distribution_named: Object.fromEntries(metadata.topRelationships.map(([glyph, count]) => [relDisplay(glyph), count])),
        hub_concepts: Object.fromEntries(metadata.topTokens),
        high_attention_tokens: metadata.highAttentionTokens.map(t => ({
          token: t.token,
          attention_score: t.attention_score,
          total_relationships: t.total_relationships
        })),
        knowledge_graph_metrics: {
          network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(3),
          avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
          tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
          oldest_entry: metadata.oldestToken?.cached_at,
          newest_entry: metadata.newestToken?.cached_at,
          date_range_days: metadata.oldestToken && metadata.newestToken ? 
            Math.ceil((new Date(metadata.newestToken.cached_at) - new Date(metadata.oldestToken.cached_at)) / (1000 * 60 * 60 * 24)) : 0
        },
        full_token_data: metadata.rawData
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      logOK(`Database metadata exported: ${metadata.totalTokens} tokens, ${metadata.totalRelationships} relationships, ${(new Blob([JSON.stringify(exportData)]).size / 1024).toFixed(1)}KB`);
    }

    async function importHLSFDBFromFile(file) {
      const txt = await file.text();
      const count = loadDbObject(txt);
      const db = getDb();
      if (!db) return;
      const seen = [];
      for (const rec of db.full_token_data || []) {
        safeStorageSet(TOKEN_CACHE_PREFIX + rec.token, JSON.stringify(rec));
        seen.push(rec.token);
      }
      safeStorageSet(DB_INDEX_KEY, JSON.stringify(seen));
      state.hlsfReady = false;
      window.HLSF_GRAPH = null;
      updateStats();
      addLog(`üìä Import: ${seen.length} tokens (${count} normalized).`);
      updateHeaderCounts();
    }

    function importDatabaseData(data, source = 'file') {
      try {
        const normalizedCount = loadDbObject(data);
        const db = getDb();
        if (!db) throw new Error('Failed to hydrate database');

        state.hlsfReady = false;
        let totalTokens = 0;
        try {
          totalTokens = loadDbObject(data);
        } catch (err) {
          console.warn('Failed to persist raw DB snapshot:', err);
        }

        const tokenData = data.full_token_data;
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        const seen = new Set();

        for (const token of tokenData) {
          if (!token?.token) continue;

          const key = getCacheKey(token.token);
          const existing = safeStorageGet(key);
          seen.add(token.token);

          if (existing) {
            const existingData = typeof existing === 'string' ? JSON.parse(existing) : existing;
            const importedDate = new Date(token.cached_at || 0);
            const existingDate = new Date(existingData?.cached_at || 0);

            if (importedDate > existingDate) {
              safeStorageSet(key, JSON.stringify(token));
              updated++;
            } else {
              skipped++;
            }
          } else {
            safeStorageSet(key, JSON.stringify(token));
            imported++;
          }
        }

        if (!totalTokens) {
          safeStorageSet(DB_INDEX_KEY, JSON.stringify(Array.from(seen)));
        }
        updateStats();

        const summary = [];
        if (imported > 0) summary.push(`${imported} new tokens imported`);
        if (updated > 0) summary.push(`${updated} tokens updated`);
        if (skipped > 0) summary.push(`${skipped} existing tokens kept`);
        if (!summary.length) summary.push('no cache changes');

        logOK(`Database imported from ${source}: ${summary.join(', ')}, normalized ${normalizedCount} tokens`);

        if (data?.database_stats) {
          addLog(`<div class="adjacency-insight">
            üìä <strong>Import Summary:</strong><br>
            ‚Ä¢ Source maturity: ${data.database_stats.maturity_level}<br>
            ‚Ä¢ Total tokens in source: ${data.database_stats.total_tokens}<br>
            ‚Ä¢ Total relationships: ${data.database_stats.total_relationships}<br>
            ‚Ä¢ Estimated value: ${data.database_stats.estimated_value_usd}
          </div>`);
        }

        return { imported, skipped, updated, seen: Array.from(seen), normalizedCount };
      } catch (err) {
        logError(`Import failed: ${err.message || err}`);
        return null;
      }
    }

    // ============================================
    // COMMANDS
    // ============================================
    const COMMANDS = window.COMMANDS = window.COMMANDS || Object.create(null);

    function registerCommand(name, handler) {
      if (!name || typeof handler !== 'function') return;
      const key = name.startsWith('/') ? name.toLowerCase() : `/${name.toLowerCase()}`;
      COMMANDS[key] = handler;
    }

    async function tryBootstrapDb() {
      if (getDb()) return true;

      let href = null;
      try {
        const url = new URL(location.href);
        href = url.searchParams.get('db') || window.HLSF.config.bootstrapDbUrl;
      } catch (err) {
        console.warn('Failed to parse bootstrap URL:', err);
      }

      if (!href) return false;

      try {
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
        return true;
      } catch (e) {
        logStatus(`Bootstrap DB fetch failed: ${String(e.message || e)}`);
        return false;
      }
    }

    function dbIndex() {
      const db = getDb();
      const idx = new Map();
      (db?.full_token_data || []).forEach(record => {
        if (record?.token) idx.set(record.token, record);
      });
      return idx;
    }

    function tokenWeight(token, idx) {
      const rec = idx.get(token);
      if (!rec) return 0.5;
      const relationships = Object.values(rec.relationships || {});
      const weights = [];
      for (const arr of relationships) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const w = rel?.weight;
          if (typeof w === 'number' && Number.isFinite(w)) weights.push(w);
        }
      }
      if (!weights.length) return 0.5;
      const maxW = Math.max(...weights);
      const meanW = weights.reduce((sum, value) => sum + value, 0) / weights.length;
      return Math.max(0.01, Math.min(1.0, 0.6 * maxW + 0.4 * meanW));
    }

    function hashGlyphForToken(token) {
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i = 0; i < token.length; i++) {
        h ^= token.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return GLYPH_SET[h % GLYPH_SET.length];
    }

    function glyphForToken(token) {
      if (!TokenToGlyph.has(token)) {
        // Ensure existing ledger mappings are available before hashing
        if (!TokenToGlyph.size) loadLedger();
      }
      return TokenToGlyph.get(token) || hashGlyphForToken(token);
    }

    function ledgerAdd(ledger, glyph, token, weight) {
      if (!ledger.glyph_map[glyph]) ledger.glyph_map[glyph] = [];
      const arr = ledger.glyph_map[glyph];
      const numericWeight = Number(weight);
      const now = Date.now();
      const found = arr.find(entry => entry.token === token);
      if (found) {
        found.w = numericWeight;
        found.t = now;
      } else {
        arr.push({ token, w: numericWeight, t: now });
      }
      TokenToGlyph.set(token, glyph);
      if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
      GlyphToToken.get(glyph).add(token);
      return ledger;
    }

    function ledgerBestToken(ledger, glyph, weight) {
      const arr = Array.isArray(ledger.glyph_map[glyph]) ? ledger.glyph_map[glyph] : [];
      if (!arr.length) return null;
      let best = arr[0];
      let bestDistance = Math.abs((best?.w ?? 0) - weight);
      for (let i = 1; i < arr.length; i++) {
        const candidate = arr[i];
        const distance = Math.abs((candidate?.w ?? 0) - weight);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      }
      return best?.token || null;
    }

    function parseGlyphFloatSequence(input) {
      const tokens = [];
      if (!input) return tokens;
      const segments = input.trim().split(/\s+/);
      for (const segment of segments) {
        if (!segment) continue;
        let cursor = 0;
        while (cursor < segment.length) {
          let glyph = null;
          for (const candidate of GLYPH_SET) {
            if (segment.startsWith(candidate, cursor)) {
              if (!glyph || candidate.length > glyph.length) glyph = candidate;
            }
          }
          if (!glyph) break;
          cursor += glyph.length;
          let nextGlyphIndex = segment.length;
          for (const candidate of GLYPH_SET) {
            const idx = segment.indexOf(candidate, cursor);
            if (idx !== -1 && idx < nextGlyphIndex) nextGlyphIndex = idx;
          }
          const numberPortion = segment.slice(cursor, nextGlyphIndex);
          cursor = nextGlyphIndex;
          let weight = parseFloat(numberPortion);
          if (!Number.isFinite(weight)) weight = 0.5;
          tokens.push({ glyph, weightStr: numberPortion, weight });
        }
      }
      return tokens;
    }

    function encryptTextToGlyphs(plain, options = {}) {
      const { persistUnknown = true } = options || {};
      const idx = dbIndex();
      const ledger = loadLedger();
      const words = (plain || '').trim().split(/\s+/).filter(Boolean);
      const out = [];
      const unknown = [];
      let covered = 0;
      let mutated = false;

      for (const word of words) {
        const glyph = glyphForToken(word);
        const weight = tokenWeight(word, idx);
        if (persistUnknown || idx.has(word)) {
          ledgerAdd(ledger, glyph, word, weight);
          mutated = true;
        }
        out.push(glyph + NUM_FMT(weight));
        if (idx.has(word)) covered++;
        else unknown.push(word);
      }

      if (mutated) saveLedger(ledger);
      const encrypted = out.join(GLYPH_SEP);
      const coverage = words.length ? (100 * covered / words.length).toFixed(1) : '0.0';
      return { encrypted, coverage, unknown };
    }

    function decryptGlyphsToText(cipher) {
      const ledger = loadLedger();
      const pairs = parseGlyphFloatSequence(cipher || '');
      const out = [];
      const unresolved = [];
      let resolved = 0;

      for (const pair of pairs) {
        const token = ledgerBestToken(ledger, pair.glyph, pair.weight);
        if (token) {
          out.push(token);
          resolved++;
        } else {
          out.push('<?>');
          unresolved.push({ glyph: pair.glyph, weight: pair.weight });
        }
      }

      const coverage = pairs.length ? (100 * resolved / pairs.length).toFixed(1) : '0.0';
      return { decrypted: out.join(' '), coverage, unresolved };
    }

    function cmdLedger(arg) {
      const ledger = loadLedger();
      const [sub] = (arg || '').trim().split(/\s+/);
      if (sub === 'export') {
        const blob = new Blob([JSON.stringify(ledger, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `glyph_ledger_${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);
        return logFinal('Ledger exported.');
      }
      if (sub === 'import') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = async e => {
          try {
            const file = e.target.files?.[0];
            if (!file) return;
            const text = await file.text();
            const imported = JSON.parse(text);
            hydrateLedgerMaps(imported);
            saveLedger(imported);
            logFinal('Ledger imported.');
          } catch (err) {
            logError(`Ledger import failed: ${err.message}`);
          }
        };
        input.click();
        return;
      }

      const lines = [];
      const map = ledger.glyph_map || {};
      const glyphs = Object.keys(map).sort();
      for (const glyph of glyphs) {
        const arr = Array.isArray(map[glyph]) ? map[glyph] : [];
        if (!arr.length) continue;
        const latest = [...arr].sort((a, b) => (b?.t ?? 0) - (a?.t ?? 0))[0];
        const weightStr = NUM_FMT(latest?.w ?? 0);
        lines.push(`${glyph} ${weightStr} ‚Üí ${latest?.token || ''}`.trim());
      }
      return logFinal(lines.length ? lines.join('\n') : 'Ledger empty.');
    }

    function cmdGlyph(argsStr) {
      const idx = dbIndex();
      const tokens = (argsStr || '').trim().split(/\s+/).filter(Boolean);
      if (!tokens.length) {
        logError('Usage: /glyph <token1 token2 ...>');
        return;
      }
      const ledger = loadLedger();
      const outputs = [];
      for (const token of tokens) {
        const glyph = glyphForToken(token);
        const weight = tokenWeight(token, idx);
        ledgerAdd(ledger, glyph, token, weight);
        outputs.push(glyph + NUM_FMT(weight));
      }
      saveLedger(ledger);
      logFinal(outputs.join(GLYPH_SEP));
    }

    function cmdEncrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /encrypt <text>');
        return;
      }
      const { encrypted, coverage } = encryptTextToGlyphs(text, { persistUnknown: true });
      logFinal(`üîê ${encrypted}\nCoverage: ${coverage}%`);
    }

    function cmdDecrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /decrypt <glyph+float sequence>');
        return;
      }
      const { decrypted, coverage } = decryptGlyphsToText(text);
      logFinal(`üîì ${decrypted}\nCoverage: ${coverage}%`);
    }


    async function cmdImport() {
      const input = document.getElementById('db-file');
      if (!input) {
        logError('File input unavailable');
        return;
      }
      input.value = '';
      input.onchange = async e => {
        try {
          const f = e.target.files?.[0];
          if (!f) return;
          const text = await f.text();
          const n = loadDbObject(text);
          logFinal(`DB loaded. Tokens: ${n}`);
        } catch (err) {
          logError(String(err.message || err));
        } finally {
          e.target.value = '';
          input.onchange = null;
        }
      };
      input.click();
    }

    async function cmdLoadDb(arg) {
      try {
        const href = (arg || '').trim() || window.HLSF.config.bootstrapDbUrl;
        if (!href) throw new Error('Usage: /loaddb <url-or-path>');
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
      } catch (e) {
        logError(`load failed: ${String(e.message || e)}`);
      }
    }

    async function cmdHlsf(rawArgs) {
      if (!getDb()) {
        const ok = await tryBootstrapDb();
        if (!ok) {
          logError('No DB loaded. Use /loaddb or /import.');
          return;
        }
      }

      const originalArgs = (rawArgs || '').trim();
      const { text: sanitizedArgs, flags } = extractHlsfFlags(originalArgs);
      const args = parseHlsfArgs(sanitizedArgs);
      const prevBatchLogging = window.HLSF.config.batchLogging;
      const prevDeferred = window.HLSF.config.deferredRender;
      const runOptions = {
        batchLogging: flags.batchLogging ?? (prevBatchLogging !== false),
        deferredRender: flags.deferredRender ?? (prevDeferred !== false),
      };
      window.HLSF.config.batchLogging = runOptions.batchLogging;
      window.HLSF.config.deferredRender = runOptions.deferredRender;

      if (flags.metricScope) {
        window.HLSF.config.metricScope = normalizeMetricScope(flags.metricScope);
      }
      if (Object.prototype.hasOwnProperty.call(flags, 'relationTypeCap')) {
        window.HLSF.config.relationTypeCap = flags.relationTypeCap === Infinity
          ? Infinity
          : clampRelationTypeCap(flags.relationTypeCap);
      }
      if (Object.prototype.hasOwnProperty.call(flags, 'edgesPerType')) {
        window.HLSF.config.edgesPerType = flags.edgesPerType === Infinity
          ? Infinity
          : clampEdgesPerType(flags.edgesPerType);
      }

      BatchLog.clear();

      const canvas = ensureHLSFCanvas();
      if (!canvas) {
        window.HLSF.config.batchLogging = prevBatchLogging;
        window.HLSF.config.deferredRender = prevDeferred;
        logError('Unable to initialize canvas for HLSF rendering.');
        return;
      }

      if (runOptions.deferredRender) hideVisualizer();
      else showVisualizer();

      const loggingActive = window.HLSF.config.batchLogging !== false;
      const start = performance.now();

      const time = async (name, fn) => {
        const phaseStart = performance.now();
        if (loggingActive) BatchLog.phase(name, 'start');
        try {
          const result = await fn();
          if (loggingActive) {
            BatchLog.phase(name, 'end', { dt: (performance.now() - phaseStart) | 0 });
          }
          return result;
        } catch (err) {
          if (loggingActive) BatchLog.phase(name, 'error', { err: String(err) });
          throw err;
        }
      };

      try {
        if (loggingActive) {
          BatchLog.phase('hlsf', 'start', {
            args: originalArgs || '',
            resolved: sanitizedArgs || '',
            flags: runOptions,
            scope: window.HLSF.config.metricScope,
          });
        }

        const index = await time('index', async () => loadOrGetIndex());
        const { anchors, idx, glyphOnly } = await time('anchors', async () => anchorsForMode(args, index));
        const effectiveIndex = idx || index;
        const metricScope = window.HLSF.config.metricScope || METRIC_SCOPE.RUN;
        let anchorsToUse = Array.isArray(anchors) ? [...anchors] : [];
        if (metricScope === METRIC_SCOPE.DB) {
          anchorsToUse = effectiveIndex instanceof Map ? Array.from(effectiveIndex.keys()) : anchorsToUse;
        }

        if (!Array.isArray(anchorsToUse) || !anchorsToUse.length) {
          logError('DB is empty. Use /loaddb or /import.');
          return;
        }

        let depth = Number.isFinite(args.depth) ? args.depth : 3;
        if (Number.isFinite(flags.depth)) depth = flags.depth;
        if (metricScope === METRIC_SCOPE.DB) depth = 0;

        let graph = null;
        let runMetrics = { nodes: 0, edges: 0, relationships: 0, anchors: 0 };
        let layoutResult = null;

        if (metricScope === METRIC_SCOPE.RUN) {
          graph = await time('graph', async () => assembleGraphFromAnchorsLogged(anchorsToUse, depth, effectiveIndex));
          await time('cluster', async () => { applyAffinityClusters(graph, effectiveIndex); });
          layoutResult = await time('layout', async () => computeLayout(graph, effectiveIndex, { scope: window.HLSF?.config?.hlsfScope }));
          await time('stage', async () => prepareBuffers(graph, layoutResult, { glyphOnly: glyphOnly === true }));
          await time('render', async () => {
            showVisualizer();
            drawComposite(graph, { glyphOnly: glyphOnly === true });
            animateComposite(graph, glyphOnly === true);
          });
          runMetrics = graph?._metrics || ensureGraphMetrics(graph);
        } else {
          if (loggingActive) BatchLog.phase('graph', 'skip', { scope: METRIC_SCOPE.DB });
          stopHLSFAnimation();
          hideVisualizer();
          window.HLSF.currentGraph = null;
          window.HLSF.currentGlyphOnly = false;
          runMetrics = computeDbStats(effectiveIndex);
        }

        const dbStats = metricScope === METRIC_SCOPE.RUN
          ? computeDbStats(effectiveIndex)
          : runMetrics;

        window.HLSF.metrics = Object.assign({}, window.HLSF.metrics || {}, { db: dbStats });

        const suffix = originalArgs ? ` ${originalArgs}` : '';
        const layoutInfo = layoutResult?.layout || graph?.dimensionLayout || null;
        const dimVal = layoutInfo ? layoutInfo.dimension || 0 : 0;
        const levelCount = layoutInfo ? layoutInfo.levelCount || 0 : 0;
        const lastComponents = layoutInfo ? layoutInfo.lastLevelComponents || 0 : 0;
        const scopeUsed = (layoutInfo?.scope || window.HLSF?.config?.hlsfScope || 'db').toString().toLowerCase();
        logOK(`/hlsf${suffix} ‚Üí nodes ${runMetrics.nodes} / ${dbStats.nodes}, edges ${runMetrics.edges} / ${dbStats.edges}, relationships ${runMetrics.relationships} / ${dbStats.relationships}, anchors ${runMetrics.anchors} / ${dbStats.anchors} D=${dimVal}, levels=${levelCount}, last_level_components=${lastComponents}, scope=${scopeUsed}`);
        addLog(`‚ìò run / db ‚Ä¢ tokens(db) ${dbStats.tokens}`);

        if (runMetrics.relationships < runMetrics.edges) {
          addLog('‚ö† run relationships < run edge-types; check dedupe or caps.');
        }
        if (window.HLSF.config.metricScope === METRIC_SCOPE.RUN && runMetrics.nodes > dbStats.tokens) {
          addLog('‚ö† run nodes > db tokens; index inconsistency.');
        }

        window.HLSF.lastCommand = {
          rawArgs: originalArgs,
          resolvedArgs: sanitizedArgs,
          args,
          anchors: [...anchorsToUse],
          idx: effectiveIndex,
          glyphOnly: glyphOnly === true,
          depth,
          flags: runOptions,
          metricScope,
        };
        syncHlsfControls(document.getElementById('hlsf-canvas-container'));

        if (loggingActive) {
          BatchLog.phase('hlsf', 'end', {
            total_ms: (performance.now() - start) | 0,
            nodes: runMetrics.nodes,
            edges: runMetrics.edges,
            relationships: runMetrics.relationships,
            anchors: runMetrics.anchors,
            metric_scope: metricScope,
            db_nodes: dbStats.nodes,
            db_edges: dbStats.edges,
            db_relationships: dbStats.relationships,
            db_tokens: dbStats.tokens,
            dimension: dimVal,
            levels: levelCount,
            last_level_components: lastComponents,
            scope: scopeUsed,
          });
        }
      } finally {
        window.HLSF.config.batchLogging = prevBatchLogging;
        window.HLSF.config.deferredRender = prevDeferred;
      }
    }

    async function runHlsfSafely(args) {
      try {
        await cmdHlsf(args);
      } catch (err) {
        if (window.HLSF?.config?.batchLogging !== false) {
          BatchLog.phase('hlsf', 'fatal', { err: String(err) });
        }
        showVisualizer();
        logError(String(err?.message || err));
      }
    }

    async function rebuildHlsfFromLastCommand(logUpdate = false) {
      const last = window.HLSF?.lastCommand;
      if (!last || !last.idx || !Array.isArray(last.anchors) || !last.anchors.length) return null;
      if (last.metricScope === METRIC_SCOPE.DB) {
        if (logUpdate) {
          const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
          logStatus(`‚Üª /hlsf${suffix} (scope=db) ‚Üí metrics-only run; nothing to rebuild.`);
        }
        return null;
      }
      try {
        const depth = Number.isFinite(last.depth) ? last.depth : 3;
        const graph = await assembleGraphFromAnchorsLogged(last.anchors, depth, last.idx, { silent: true });
        applyAffinityClusters(graph, last.idx);
        const layout = computeLayout(graph, last.idx, { scope: window.HLSF?.config?.hlsfScope });
        prepareBuffers(graph, layout, { glyphOnly: last.glyphOnly === true });
        showVisualizer();
        drawComposite(graph, { glyphOnly: last.glyphOnly === true });
        animateComposite(graph, last.glyphOnly === true);
        syncHlsfControls(document.getElementById('hlsf-canvas-container'));
        if (logUpdate) {
          const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
          const m = graph?._metrics || ensureGraphMetrics(graph);
          logStatus(`‚Üª /hlsf${suffix} ‚Üí nodes ${m.nodes}, edges ${m.edges}, relationships ${m.relationships}, anchors ${m.anchors}`);
        }
        return graph;
      } catch (err) {
        console.warn('Failed to rebuild HLSF command:', err);
        return null;
      }
    }

    function cmdScheme(arg) {
      const mode = (arg || '').toLowerCase();
      window.HLSF.config.whiteBg = mode === 'white';
      if (window.HLSF.currentGraph) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Scheme: ${window.HLSF.config.whiteBg ? 'Black lines on white' : 'White lines on black'}`);
    }

    function cmdSpin(arg) {
      const value = (arg || '').toLowerCase();
      window.HLSF.config.rotationActive = /^(on|true|1)$/i.test(value) || (!value && true);
      if (window.HLSF.currentGraph && !_anim) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Rotation: ${window.HLSF.config.rotationActive ? 'on' : 'off'}`);
    }

    function cmdOmega(arg) {
      const w = parseFloat(arg);
      if (!Number.isFinite(w)) {
        logError('Usage: /omega <rad/s>');
        return;
      }
      window.HLSF.config.rotationOmega = w;
      const slider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (slider) slider.value = w.toFixed(2);
      if (speedVal) speedVal.textContent = w.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Rotation omega = ${w.toFixed(2)} rad/s`);
    }

    function cmdAlpha(arg) {
      const parsed = parseFloat(arg);
      if (!Number.isFinite(parsed)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      const a = clampAlpha(parsed);
      if (!Number.isFinite(a)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      window.HLSF.config.alpha = a;
      const slider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (slider) slider.value = a.toFixed(2);
      if (alphaVal) alphaVal.textContent = a.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Alpha = ${a.toFixed(2)}`);
    }

    async function cmd_import() {
      await cmdImport();
    }

    async function cmd_loaddb(args) {
      const joined = Array.isArray(args) ? args.join(' ') : args;
      await cmdLoadDb(joined);
    }

    function getRelationshipPriority(relType) {
      if (RELATIONSHIP_PRIORITIES instanceof Map) {
        return RELATIONSHIP_PRIORITIES.get(relType) ?? 1;
      }
      if (typeof RELATIONSHIP_PRIORITIES === 'object' && RELATIONSHIP_PRIORITIES !== null) {
        return RELATIONSHIP_PRIORITIES[relType] ?? 1;
      }
      return 1;
    }

    function* iterTokenRecords() {
      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) yield rec;
        return;
      }
      const idxRaw = safeStorageGet(DB_INDEX_KEY, []);
      const idx = Array.isArray(idxRaw) ? idxRaw : [];
      const keys = idx.length ? idx.map(t => TOKEN_CACHE_PREFIX + t)
                              : safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const k of keys) {
        const rec = safeStorageGet(k);
        if (rec) yield rec;
      }
    }

    function buildHLSF() {
      const pri = RELATIONSHIP_PRIORITIES || {};
      const nodes = [];
      const edges = [];
      let maxAttention = 0;

      for (const rec of iterTokenRecords()) {
        if (!rec || !rec.token || !rec.relationships) continue;
        let attention = 0;

        for (const rawKey of Object.keys(rec.relationships)) {
          const type = normRelKey(rawKey);
          const p = (pri[type] ?? pri.get?.(type)) ?? 1;
          for (const rel of rec.relationships[rawKey]) {
            const w = rel.weight ?? 0;
            attention += w * p;
            edges.push({ source: rec.token, target: rel.token, type, w });
          }
        }
        maxAttention = Math.max(maxAttention, attention);
        nodes.push({ id: rec.token, attention });
      }

      const norm = maxAttention || 1;
      for (const n of nodes) n.attention = +(n.attention / norm).toFixed(3);

      return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
    }

    async function cmd_hlsf() {
      await runHlsfSafely('');
    }

    registerCommand('/import', cmd_import);
    registerCommand('/loaddb', cmd_loaddb);
    window.COMMANDS = COMMANDS;
    // Router guard (prevents duplicate logs)
    if (!COMMANDS.__hlsf_bound) {
      COMMANDS['/hlsf'] = cmd_hlsf;
      COMMANDS.__hlsf_bound = true;
    }
    registerCommand('/visualize', cmd_hlsf);

    async function dispatchCommand(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return false;

      const parts = trimmed.split(/\s+/);
      const [raw, ...rest] = parts;
      const command = raw.startsWith('/') ? raw.toLowerCase() : `/${raw.toLowerCase()}`;
      const arg = rest.join(' ').trim();

      if (command === '/import') { await cmdImport(); return true; }
      if (command === '/loaddb') { await cmdLoadDb(arg); return true; }
      if (command === '/hlsf') { await runHlsfSafely(arg); return true; }
      if (command === '/scheme') { cmdScheme(arg || 'black'); return true; }
      if (command === '/spin') { cmdSpin(arg || 'on'); return true; }
      if (command === '/omega') { cmdOmega(arg); return true; }
      if (command === '/alpha') { cmdAlpha(arg); return true; }

      return false;
    }

    function isCommand(input) { return input.startsWith('/'); }

    async function handleCommand(cmd) {
      const trimmed = cmd.trim();
      const handled = await safeAsync(() => dispatchCommand(trimmed), `Command dispatch failed for ${trimmed}`);
      if (handled) return;

      const segments = trimmed.slice(1).split(/\s+/);
      const [command, ...args] = segments;

      if (!command) {
        logError('Unknown command');
        return;
      }

      const normalized = `/${command.toLowerCase()}`;
      const mapped = COMMANDS[normalized];
      if (mapped) {
        await mapped(args, trimmed);
        return;
      }

      switch (command.toLowerCase()) {
        case 'clear':
          elements.log.innerHTML = '';
          logOK('Log cleared');
          break;
        case 'reset':
          if (confirm('Clear all cached data?')) {
            const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
            keys.forEach(k => safeStorageRemove(k));
            safeStorageRemove(DB_INDEX_KEY);
            let hadDbSnapshot = false;
            try {
              hadDbSnapshot = localStorage.getItem(DB_RAW_KEY) != null;
            } catch (err) {
              console.warn('Unable to inspect DB snapshot state:', err);
            }
            safeStorageRemove(DB_RAW_KEY);
            state.hlsfReady = false;
            window.HLSF_GRAPH = null;
            if (window.HLSF) {
              window.HLSF.matrices = null;
              window.HLSF.layoutCache = null;
              window.HLSF.dbCache = null;
              window.HLSF.indexCache = null;
              window.HLSF.indexCacheSource = null;
              window.HLSF.currentGraph = null;
              window.HLSF.currentGlyphOnly = false;
              window.HLSF.__centerInit = false;
            }
            Session.tokens.clear();
            updateStats();
            const clearedMsg = hadDbSnapshot
              ? `Cleared ${keys.length} tokens and database snapshot`
              : `Cleared ${keys.length} tokens`;
            logOK(clearedMsg);
          }
          break;
        case 'stats':
          const { totalApiCalls, totalCacheHits, totalCostUsd } = state.sessionStats;
          const total = totalApiCalls + totalCacheHits;
          const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) : 0;
          addLog(`<strong>Session Stats:</strong><br>
            ‚Ä¢ Requests: ${total}<br>
            ‚Ä¢ Cache hits: ${totalCacheHits} (${hitRate}%)<br>
            ‚Ä¢ API calls: ${totalApiCalls}<br>
            ‚Ä¢ Cost: ${formatCurrency(totalCostUsd)}<br>
            ‚Ä¢ Cached tokens: ${getCachedTokenCount()}`);
          break;
        case 'database':
        case 'db':
          showDatabaseMetadata();
          break;
        case 'export':
          exportDatabaseMetadata();
          break;
        case 'glyph':
          cmdGlyph(args.join(' '));
          break;
        case 'ledger':
          cmdLedger(args.join(' '));
          break;
        case 'encrypt':
          cmdEncrypt(args.join(' '));
          break;
        case 'decrypt':
          cmdDecrypt(args.join(' '));
          break;
        case 'exportledger':
          cmdLedger('export');
          break;
        case 'help':
          addLog(`<strong>Commands:</strong><br>
            /clear - Clear log<br>
            /reset - Clear cache<br>
            /stats - Session statistics<br>
            /database or /db - View database metadata<br>
            /export - Export database metadata as JSON<br>
            /import - Import database from JSON file<br>
            /loaddb &lt;url&gt; - Load database JSON from URL<br>
            /glyph &lt;token1 token2 ...&gt; - Show weighted glyph assignments<br>
            /ledger [show|export|import] - Manage private glyph ledger<br>
            /encrypt &lt;text&gt; - Encrypt text into weighted glyphs<br>
            /decrypt &lt;glyph+float&gt; - Decrypt using private ledger<br>
            /exportledger - Shortcut for /ledger export<br>
            /hlsf or /visualize - Visualize database as Hierarchical-Level Semantic Framework ‚Äî builds from anchors<br>
            /help - Show commands`);
          break;
        default:
          logError(`Unknown: ${command}`);
      }
    }

    // ============================================
    // MAIN PROCESSING
    // ============================================
    async function processPrompt(prompt) {
      if (state.isProcessing) return;
      
      state.isProcessing = true;
      currentAbortController = new AbortController();
      elements.sendBtn.disabled = true;
      elements.cancelBtn.style.display = 'inline-block';
      elements.input.disabled = true;

      const startTime = performance.now();

      try {
        const tokens = tokenize(prompt);
        if (tokens.length === 0) {
          logError('Prompt cannot be empty');
          return;
        }
        addConversationTokens(tokens);
        if (tokens.length > CONFIG.MAX_TOKENS_PER_PROMPT) {
          logError(`Exceeds ${CONFIG.MAX_TOKENS_PER_PROMPT} token limit (${tokens.length})`);
          return;
        }

        const uniqueTokens = [...new Set(tokens)];
        const cachedTokens = uniqueTokens.filter(isTokenCached).length;
        const newTokenCount = Math.max(0, uniqueTokens.length - cachedTokens);

        const chatMessages = [
          { role: 'system', content: 'You are an expert assistant.' },
          { role: 'user', content: prompt },
        ];
        const chatPromptTokens = estimateTokensForMessages(chatMessages);
        const chatCompletionTokens = estimateCompletionTokens(chatPromptTokens);
        const chatCallCount = state.apiKey ? 3 : 0;
        const chatCostEstimate = chatCallCount * estimateCostUsd(chatPromptTokens, chatCompletionTokens);

        const adjacencyCallCount = state.apiKey ? newTokenCount : 0;
        const adjacencyCostEstimate = adjacencyCallCount > 0
          ? adjacencyCallCount * estimateCostUsd(
              CONFIG.ADJACENCY_TOKEN_ESTIMATES.prompt,
              CONFIG.ADJACENCY_TOKEN_ESTIMATES.completion
            )
          : 0;

        const estimatedCost = chatCostEstimate + adjacencyCostEstimate;
        const totalEstimatedCalls = chatCallCount + adjacencyCallCount;

        addLog(`<div class="cost-estimate">
          üìä <strong>Estimate:</strong> ${tokens.length} input tokens observed (${newTokenCount} new, ${cachedTokens} cached).<br>
          ‚Ä¢ Chat completions: ~${chatCallCount} call${chatCallCount === 1 ? '' : 's'} (${formatCurrency(chatCostEstimate)}).<br>
          ‚Ä¢ Adjacency builds: ~${adjacencyCallCount} new call${adjacencyCallCount === 1 ? '' : 's'} (${formatCurrency(adjacencyCostEstimate)}).<br>
          <strong>Total projected cost:</strong> ${formatCurrency(estimatedCost)} across ~${totalEstimatedCalls} API call${totalEstimatedCalls === 1 ? '' : 's'} (final depends on model output).
        </div>`);

        // Step 1: Initial response
        let initialResponse = '';
        if (state.apiKey) {
          const s1 = logStatus('‚è≥ Generating initial response...');
          initialResponse = await callOpenAI([
            { role: 'system', content: 'You are an expert assistant.' },
            { role: 'user', content: prompt },
          ]);
          s1.innerHTML = `‚úÖ Initial response generated`;
        } else {
          initialResponse = '‚ö†Ô∏è Offline mode';
          logWarning('Skipped (offline)');
        }

        // Step 2: Adjacency analysis
        const responseTokens = tokenize(initialResponse);
        addConversationTokens(responseTokens);
        const [inputMatrices, outputMatrices] = await Promise.all([
          batchFetchAdjacencies(tokens, prompt, 'input'),
          batchFetchAdjacencies(responseTokens, initialResponse, 'output'),
        ]);

        calculateAttention(inputMatrices);
        calculateAttention(outputMatrices);

        const allMatrices = new Map([...inputMatrices, ...outputMatrices]);
        const topTokens = summarizeAttention(allMatrices);
        const keyRels = extractKeyRelationships(allMatrices);

        addLog(`<div class="adjacency-insight">
          <strong>üéØ High Attention:</strong> ${formatTopTokens(topTokens)}
        </div>
        <div class="adjacency-insight">
          <strong>üîó Key Relationships:</strong><br>
          ${keyRels.map(r => `‚Ä¢ ${r}`).join('<br>')}
        </div>`);

        // Step 3: Thought stream
        let thoughtStream = '';
        if (state.apiKey) {
          const s2 = logStatus('‚è≥ Synthesizing thought stream...');
          thoughtStream = await callOpenAI([
            { role: 'system', content: 'You create reflective thought streams from analytical insights.' },
            { role: 'user', content: `Based on these adjacency insights, generate a stream-of-consciousness internal monologue:\n\nTop tokens: ${JSON.stringify(topTokens)}\nRelationships: ${keyRels.join('; ')}\n\nWrite as flowing natural thought connecting these elements.` },
          ]);
          s2.innerHTML = '‚úÖ Thought stream captured';
          
          addLog(`<div class="section-divider"></div>
            <div class="section-title">üí≠ Emergent Thought Stream</div>
            <div class="thought-stream">${sanitize(thoughtStream)}</div>`);
        }

        // Step 4: Refined response
        let refinedResponse = initialResponse;
        if (state.apiKey) {
          const s3 = logStatus('‚è≥ Refining response...');
          refinedResponse = await callOpenAI([
            { role: 'system', content: 'You refine responses based on adjacency insights.' },
            { role: 'user', content: `Original: "${initialResponse}"\n\nInsights: ${thoughtStream}\n\nRevise by: 1) Incorporating emergent insights 2) Restructuring based on token relationships 3) Enhancing coherence. Provide revised response only.` },
          ]);
          s3.innerHTML = '‚úÖ Response refined';
        }
        addConversationTokens(tokenize(refinedResponse));

        // Display final output
        const time = ((performance.now() - startTime) / 1000).toFixed(1);
        addLog(`<div class="section-divider"></div>
          <div class="final-output">
            <h3>‚ú® REFINED RESPONSE</h3>
            <pre>${sanitize(refinedResponse)}</pre>
            
            <details>
              <summary>Compare with original response</summary>
              <pre>${sanitize(initialResponse)}</pre>
            </details>
            
            <details>
              <summary>View adjacency data (${allMatrices.size} tokens)</summary>
              <pre>${JSON.stringify(Array.from(allMatrices.entries()).slice(0, 5), null, 2)}</pre>
            </details>
          </div>
        `);
        
        logOK(`Processing complete (${time}s)`);

      } catch (err) {
        if (err.name === 'AbortError' || err.message === 'AbortError') {
          logWarning('Processing cancelled');
        } else {
          logError(err.message || 'Processing failed');
          console.error(err);
        }
      } finally {
        state.isProcessing = false;
        currentAbortController = null;
        elements.sendBtn.disabled = false;
        elements.cancelBtn.style.display = 'none';
        elements.input.disabled = false;
        elements.input.value = '';
        elements.input.focus();
      }
    }

    // ============================================
    // EVENTS
    // ============================================
    function applyApiKeyFromModal() {
      const key = elements.apiKeyInput.value.trim();
      if (!isValidApiKey(key)) {
        logError('Invalid API key format');
        return;
      }
      state.apiKey = key.trim();
      const persisted = safeStorageSet(API_KEY_STORAGE_KEY, state.apiKey);
      elements.apiModal.classList.add('hidden');
      if (!persisted) {
        logWarning('API key configured but not saved to storage');
      }
      logOK('API key configured');
    }

    elements.apiConfirmBtn.addEventListener('click', applyApiKeyFromModal);

    elements.apiKeyInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        applyApiKeyFromModal();
      }
    });

    elements.apiCancelBtn.addEventListener('click', () => {
      elements.apiModal.classList.add('hidden');
      logWarning('Offline mode - limited functionality');
    });

    elements.sendBtn.addEventListener('click', () => {
      const input = elements.input.value.trim();
      if (!input) return;
      
      addLog(`> ${sanitize(input)}`);
      
      if (isCommand(input)) {
        handleCommand(input);
        elements.input.value = '';
      } else {
        onUserPromptSubmitted(input);
        processPrompt(input);
      }
    });

    elements.cancelBtn.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
        logWarning('Cancelling...');
      }
    });

    elements.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.sendBtn.click();
      }
    });

    // ============================================
    // INIT
    // ============================================
    window.addEventListener('beforeunload', () => {
      state.apiKey = '';
      stopHLSFAnimation();
    });

    async function initialize() {
      updateStats();

      const storedKey = safeStorageGet(API_KEY_STORAGE_KEY, '');
      if (isValidApiKey(storedKey)) {
        state.apiKey = storedKey.trim();
        elements.apiKeyInput.value = state.apiKey;
        elements.apiModal.classList.add('hidden');
        logOK('Loaded stored API key');
      } else if (storedKey) {
        safeStorageRemove(API_KEY_STORAGE_KEY);
      }

      await tryBootstrapDb();

      const cachedCount = getCachedTokenCount();
      
      addLog(`<strong>üß† HLSF Cognition Engine v2.0</strong><br><br>
        This engine performs:<br>
        1. Token adjacency mapping (50 relationship types)<br>
        2. Attention score calculation<br>
        3. Emergent thought stream synthesis<br>
        4. Response refinement based on insights<br>
        5. <strong>Symbolic glyph encryption</strong> (complex number encoding)<br>
        6. <strong>HLSF visualization</strong> (hierarchical semantic framework)<br><br>
        <strong>Commands:</strong> /help, /hlsf, /glyph, /encrypt, /decrypt<br>
        ${cachedCount > 0 ? `<br>‚úÖ Loaded with ${cachedCount} cached tokens` : ''}
        <br><small>‚ö†Ô∏è Note: Download HTML and run locally for API calls to work.</small>
      `);
      
      elements.input.focus();
    }

    window.addEventListener('load', () => {
      tryBootstrapDb();
    });

    initialize();
  </script>
</body>
</html>