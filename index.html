<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HLSF Cognition Engine v2.0</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0a0a;
      --panel: #111;
      --text: #e0e0e0;
      --accent: #00ff88;
      --error: #ff4444;
      --success: #44ff44;
      --warning: #ffd54f;
      --scrollbar: #1f1f1f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Fira Code', Consolas, Monaco, 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
      width: 100%;
    }

    #header {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      font-weight: normal;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .stat-value {
      font-weight: bold;
      color: var(--accent);
    }

    #log {
      flex: 1;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
      min-height: 400px;
    }

    #log::-webkit-scrollbar { width: 10px; }
    #log::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 10px; }

    #input-area {
      margin-top: 1rem;
      display: flex;
      gap: 0.75rem;
    }

    #command-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      transition: border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    #command-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn-primary { background: var(--accent); color: #022d15; }
    .btn-secondary { background: #333; color: var(--text); }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.25);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .log-entry {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      animation: fadeIn 0.3s ease;
    }

    .log-entry .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .log-entry.status { font-style: italic; }
    .log-entry.error { border-left-color: var(--error); color: var(--error); }
    .log-entry.success { border-left-color: var(--success); color: var(--success); }
    .log-entry.warning { border-left-color: var(--warning); color: var(--warning); }

    .cost-estimate {
      background: rgba(255, 213, 79, 0.1);
      border: 1px solid var(--warning);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
    }

    .section-divider {
      margin: 1.5rem 0 0.5rem 0;
      border-top: 2px solid #222;
      padding-top: 1rem;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .thought-stream {
      background: rgba(0, 255, 136, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 8px;
      padding: 1rem;
      font-style: italic;
      line-height: 1.6;
    }

    .adjacency-insight {
      background: rgba(255, 213, 79, 0.05);
      border: 1px solid rgba(255, 213, 79, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .token-highlight {
      background: rgba(0, 255, 136, 0.2);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: bold;
    }

    .final-output {
      border-left: 3px solid var(--success);
      padding: 1rem;
      background: rgba(68, 255, 68, 0.05);
      border-radius: 8px;
    }

    .final-output h3 {
      margin-top: 0;
      color: var(--success);
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #222;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin: 0.5rem 0;
      transition: border 0.2s ease;
    }

    details[open] {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.25);
    }

    summary {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      list-style: none;
      font-weight: 600;
      padding: 0.3rem 0;
    }

    summary::-webkit-details-marker { display: none; }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0.5rem 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: #111;
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2rem;
      width: min(420px, 90vw);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-content h2 { margin: 0; color: var(--accent); }

    .hlsf-canvas-container {
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
    }

    #hlsf-canvas {
      width: 100%;
      height: 600px;
      background: transparent;
      border-radius: 8px;
      cursor: grab;
    }

    #hlsf-canvas:active {
      cursor: grabbing;
    }

    .hlsf-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .hlsf-control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .hlsf-control-group label {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .hlsf-control-group input[type="range"],
    .hlsf-control-group select {
      width: 100%;
    }

    .hlsf-control-group input[type="number"],
    .hlsf-control-group select {
      padding: 0.5rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 6px;
      color: var(--text);
    }

    .hlsf-button-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hlsf-button-row button {
      flex: 1;
      min-width: 80px;
    }

    .hlsf-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      margin-top: 0.5rem;
    }

    .hlsf-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .hlsf-legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .hlsf-node-info {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      font-size: 0.85rem;
      display: none;
    }

    .hlsf-node-info.visible {
      display: block;
    }

    .modal-content input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #222;
      background: #0c0c0c;
      color: var(--text);
      font-size: 1rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .pill-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pill-button.primary { background: var(--accent); color: #022d15; }
    .pill-button.secondary { background: transparent; border: 1px solid #333; color: var(--text); }

    .pill-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.18);
    }

    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 136, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    .processing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      #app { padding: 1rem; }
      #header { flex-direction: column; align-items: flex-start; }
      .header-stats { flex-direction: column; gap: 0.5rem; }
      #input-area { flex-direction: column; }
      .button-group { flex-direction: column; }
      .btn { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="api-modal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true">
      <h2>Enter OpenAI API Key</h2>
      <p>Provide your OpenAI API key (sk-...) to begin using the HLSF Cognition Engine.</p>
      <input id="api-key-input" type="password" placeholder="sk-..." />
      <div class="modal-actions">
        <button id="api-cancel" class="pill-button secondary">Continue offline</button>
        <button id="api-confirm" class="pill-button primary">Save key</button>
      </div>
      <small style="opacity:0.65">⚠️ Note: Download this HTML file and run locally for API calls to work.</small>
    </div>
  </div>

  <div id="app">
    <div id="header">
      <div>HLSF Cognition Engine v2.0</div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">Cache Hit Rate</span>
          <span class="stat-value" id="cache-hit-rate">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Cached Tokens</span>
          <span class="stat-value" id="cached-tokens">—</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Session Cost</span>
          <span class="stat-value" id="session-cost">$0.00</span>
        </div>
      </div>
    </div>
    <div id="log"></div>
    <div id="input-area">
      <input id="command-input" type="text" placeholder="> Enter a prompt or /command" maxlength="600" autocomplete="off" />
      <div class="button-group">
        <button id="cancel-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
        <button id="send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
    <input id="db-file" type="file" accept=".json,application/json" style="display:none">
    <div class="hlsf-canvas-container" id="hlsf-canvas-container" style="display:none">
      <div class="section-title">🔭 HLSF Matrix Visualizer</div>
      <canvas id="hlsf-canvas"></canvas>
      <div class="hlsf-controls">
        <div class="hlsf-control-group">
          <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
          <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
          <input id="hlsf-alpha" type="range" min="0.01" max="0.99" step="0.01" value="0.70">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-width">Edge width <span id="hlsf-edge-width-val">1.2</span></label>
          <input id="hlsf-edge-width" type="range" min="0.2" max="5" step="0.1" value="1.2">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
          <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-color-mode">Edge coloring</label>
          <select id="hlsf-edge-color-mode">
            <option value="theme">Theme</option>
            <option value="weight">Weight</option>
            <option value="relation">Relation</option>
          </select>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">50</span></label>
          <input id="hlsf-relation-cap" type="number" min="1" max="50" step="1" value="50">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
          <input id="hlsf-edges-per-type" type="number" min="1" max="10" step="1" value="3">
        </div>
        <div class="hlsf-control-group">
          <label>Display options</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
            <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
            <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
            <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>Rotation modes</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
            <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergent</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>View</label>
          <div class="hlsf-button-row">
            <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
            <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
            <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      MAX_TOKENS_PER_PROMPT: 100,
      MAX_CONCURRENCY: 5,
      MAX_RETRY_ATTEMPTS: 3,
      RETRY_BASE_DELAY_MS: 500,
      DEFAULT_MODEL: 'gpt-4o-mini',
      ESTIMATED_COST_PER_API_CALL: 0.02,
    };

    // Canonical 50-type display names
    const REL_EN = {
      "≡":"Identity","⊃":"Contains","⊂":"Is Contained By","≈":"Variant","∈":"Is Instance Of","∋":"Has Instance",
      "⊤":"Is Type Of","⊥":"Has Type","⊏":"Part Of","⊐":"Composes","↔":"Mirrors","⇌":"Inverts","∥":"Parallel To",
      "∼":"Adjacent To","→":"Next","⇒":"Sequence Of","⇐":"Preceded By","↠":"Follows","↗":"Spatially Above","↘":"Spatially Below",
      "↝":"Symbolically Supports","↧":"Symbolically Depends","≠":"Contrasts","⊕":"Complements","⊛":"Associated With","∝":"Correlates With",
      "⇝":"Causes","↼":"Caused By","*":"Evokes","≜":"Represents","★":"Symbolizes","↦":"Refers To","⊢":"Defines","⊣":"Is Defined By",
      "↷":"Transforms To","↶":"Transformed From","∘":"Functions As","⊨":"Interpreted As","◁":"Used With","⇄":"Co-occurs With",
      "⊗":"Synthesizes","÷":"Divides Into","⊘":"Opposes","↳":"Leads To","↲":"Results In","⟂":"Orthogonal To","≉":"Diverges From",
      "≍":"Equivalent In Form","≓":"Approximately Equals","≔":"Defined As"
    };

    // Return "∼ Adjacent To"
    const relDisplay = k => `${k} ${REL_EN[k] ?? ''}`.trim();

    const RELKEY_ALIASES = (() => {
      const map = new Map();
      for (const [glyph, name] of Object.entries(REL_EN)) {
        map.set(`${glyph} ${name}`, glyph);
        map.set(name, glyph);
        map.set(name.toLowerCase(), glyph);
      }
      map.set('∗', '*');
      map.set('*', '*');
      map.set('⋆', '*');
      return map;
    })();

    function normRelKey(k) {
      const cleaned = (k || '').trim();
      if (!cleaned) return null;
      if (REL_EN[cleaned]) return cleaned;
      const normalized = cleaned.replace(/\s+/g, ' ');
      const alias = RELKEY_ALIASES.get(normalized)
        || RELKEY_ALIASES.get(normalized.toLowerCase())
        || RELKEY_ALIASES.get(normalized.split(' ')[0]);
      return REL_EN[alias] ? alias : null;
    }

    function normalizeRelKeyForStats(k){
      const g = normRelKey(k);
      return REL_EN[g] ? g : null;
    }

    function renderRelTypeRow(glyph, count){
      return `${relDisplay(glyph)}: ${count} instances`;
    }

    // ---------------- HLSF matrix builder ----------------
    function buildMatrixForRecord(rec) {
      const edges = [];
      const rels = rec?.relationships || {};
      const keys = Object.keys(rels);
      for (const rawKey of keys) {
        const key = normRelKey(rawKey);
        if (!key) continue;
        const arr = Array.isArray(rels[rawKey]) ? rels[rawKey] : [];
        const items = arr
          .filter(x => x && typeof x.weight === 'number')
          .sort((a, b) => b.weight - a.weight);
        if (!items.length) continue;
        const agg = {
          rtype: key,
          aggWeight: items[0].weight,
          sizeWeight: items.reduce((s, x) => s + x.weight, 0),
          count: items.length,
          items
        };
        edges.push(agg);
        if (edges.length === 10) break;
      }
      const freq = typeof rec?.f === 'number'
        ? rec.f
        : typeof rec?.frequency === 'number'
          ? rec.frequency
          : typeof rec?.freq === 'number'
            ? rec.freq
            : 1;
      return { token: rec?.token || '', edges, f: freq };
    }

    function buildHLSFMatrices(db) {
      const raw = db?.full_token_data || [];
      const matrices = new Map();
      const freqs = [];
      for (const rec of raw) {
        const matrix = buildMatrixForRecord(rec);
        matrices.set(matrix.token, matrix);
        if (typeof matrix.f === 'number') freqs.push(matrix.f);
      }

      freqs.sort((a, b) => a - b);
      const freqStats = freqs.length
        ? {
            min: freqs[0],
            max: freqs[freqs.length - 1],
            p90: freqs[Math.max(0, Math.floor(freqs.length * 0.9) - 1)]
          }
        : { min: 0, max: 1, p90: 1 };

      window.HLSF = window.HLSF || {};
      window.HLSF.matrices = matrices;
      window.HLSF.metrics = Object.assign({}, window.HLSF.metrics, { freqStats });

      return matrices;
    }

    function parseHlsfArgs(str) {
      const out = { mode: 'full', tokens: [], glyphs: [], depth: 3.0 };
      const s = (str || '').trim();
      if (!s) return out;
      if (/^--conversation$/i.test(s)) { out.mode = 'conversation'; return out; }
      const m = s.match(/^--\[(.*)\]$/s);
      if (!m) return out;
      const parts = m[1].split(/\s*,\s*/).filter(Boolean);
      for (const p of parts) {
        const kv = p.split(/\s*=\s*/);
        if (kv.length === 2 && /^recursionDepth$/i.test(kv[0])) {
          out.depth = Math.max(0, parseFloat(kv[1]) || 0);
          continue;
        }
        if (/^[\u2200-\u2BFF\u{1F300}-\u{1FAFF}]+$/u.test(p)) out.glyphs.push(p);
        else out.tokens.push(p);
      }
      out.mode = out.glyphs.length ? 'glyphs' : 'tokens';
      return out;
    }

    function buildIndex(db) {
      const idx = new Map();
      (db?.full_token_data || []).forEach(rec => {
        if (rec?.token) idx.set(rec.token, rec);
      });
      return idx;
    }

    function recordScore(rec) {
      let s = 0;
      let any = false;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          const m = Math.max(...arr.map(x => +x.weight || 0));
          s += m;
          any = true;
        }
      }
      return any ? s : Object.keys(rec?.relationships || {}).length;
    }

    function defaultSeeds(idx, k = 64) {
      const recs = Array.from(idx.values());
      recs.sort((a, b) => recordScore(b) - recordScore(a));
      return recs.slice(0, k).map(r => r.token);
    }

    function edgesFrom(rec) {
      if (!rec) return [];
      const matrix = buildMatrixForRecord(rec);
      const relationCap = clampRelationTypeCap(window.HLSF.config?.relationTypeCap);
      const perType = clampEdgesPerType(window.HLSF.config?.edgesPerType);
      const relations = (matrix?.edges || []).slice(0, relationCap);
      const out = [];
      for (const relation of relations) {
        const items = Array.isArray(relation?.items) ? relation.items.slice(0, perType) : [];
        for (const item of items) {
          const target = item?.token;
          if (!target) continue;
          const weight = Number.isFinite(item?.weight)
            ? item.weight
            : Number.isFinite(item?.w)
              ? item.w
              : relation?.aggWeight;
          out.push({ rtype: relation?.rtype, to: target, w: Number(weight) || 0 });
        }
      }
      return out;
    }

    function assembleGraphFromSeeds(seeds, depthFloat, idx) {
      const graph = { nodes: new Map(), edges: [], seeds: [...seeds] };
      const seen = new Set();
      const q = [];

      for (const seed of seeds) {
        const rec = idx.get(seed);
        if (!rec) continue;
        graph.nodes.set(seed, { token: seed, f: rec.f || rec.frequency || 1 });
        edgesFrom(rec).forEach(e => {
          q.push({ from: seed, to: e.to, w: e.w, rtype: e.rtype, depth: 1 });
        });
      }

      const full = Math.floor(depthFloat);
      for (let d = 1; d <= full; d++) {
        const layer = q
          .filter(e => e.depth === d)
          .sort((a, b) => b.w - a.w);
        const next = [];
        for (const edge of layer) {
          if (!graph.nodes.has(edge.to)) {
            const rec = idx.get(edge.to);
            graph.nodes.set(edge.to, { token: edge.to, f: rec?.f || rec?.frequency || 1 });
          }
          graph.edges.push(edge);
          if (d < full) {
            const rec = idx.get(edge.to);
            if (!rec) continue;
            edgesFrom(rec).forEach(ne => {
              const key = `${edge.to}→${ne.to}·${ne.rtype}`;
              if (seen.has(key)) return;
              seen.add(key);
              next.push({ from: edge.to, to: ne.to, w: ne.w, rtype: ne.rtype, depth: d + 1 });
            });
          }
        }
        q.push(...next);
      }

      const frac = depthFloat - full;
      if (frac > 0) {
        const tail = q
          .filter(e => e.depth === full + 1)
          .sort((a, b) => b.w - a.w);
        const k = Math.max(0, Math.floor(frac * tail.length));
        for (let i = 0; i < k; i++) {
          const edge = tail[i];
          if (!graph.nodes.has(edge.to)) {
            const rec = idx.get(edge.to);
            graph.nodes.set(edge.to, { token: edge.to, f: rec?.f || rec?.frequency || 1 });
          }
          graph.edges.push(edge);
        }
      }

      return graph;
    }

    function recordScore(rec){
      let s = 0, any = false;
      for (const arr of Object.values(rec.relationships || {})){
        if (Array.isArray(arr) && arr.length){
          const m = Math.max(...arr.map(x => +x.weight || 0));
          s += m; any = true;
        }
      }
      return any ? s : Object.keys(rec.relationships || {}).length;
    }

    function defaultSeeds(idx, k = 64){
      const recs = Array.from(idx.values());
      recs.sort((a,b) => recordScore(b) - recordScore(a));
      return recs.slice(0, k).map(r => r.token);
    }

    function seedsForMode(args){
      const db = getDb();
      if (!db) throw new Error('No DB loaded');
      loadGlyphMaps(db);
      const idx = buildIndex(db);

      if (args.mode === 'conversation') {
        const conv = [...(Session?.tokens || [])].filter(t => idx.has(t));
        const seeds = conv.length ? conv : defaultSeeds(idx, 32);
        return { seeds, idx };
      }

      if (args.mode === 'tokens') {
        let seeds = args.tokens.filter(t => idx.has(t));
        if (!seeds.length) seeds = defaultSeeds(idx, 32);
        return { seeds, idx };
      }

      if (args.mode === 'glyphs') {
        const glyphTokens = [];
        for (const glyph of args.glyphs) {
          const val = GlyphToToken.get(glyph);
          if (!val) continue;
          if (val instanceof Set) glyphTokens.push(...val);
          else if (Array.isArray(val)) glyphTokens.push(...val);
          else glyphTokens.push(val);
        }
        const toks = glyphTokens.filter(t => idx.has(t));
        const seeds = toks.length ? toks : defaultSeeds(idx, 32);
        return { seeds, idx, glyphOnly: true };
      }

      const configuredCap = Number(window.HLSF.config.fullSeedCap);
      const cap = Number.isFinite(configuredCap) && configuredCap > 0
        ? Math.min(configuredCap, idx.size)
        : idx.size;
      return { seeds: defaultSeeds(idx, cap), idx };
    }

    function nodeLabel(token, glyphOnly = false) {
      const glyph = TokenToGlyph.get(token);
      if (glyphOnly && glyph) return glyph;
      return glyph || token;
    }

    function edgeLabel(rtype) {
      return window.HLSF.config.showEnglish
        ? `${rtype} ${REL_EN[rtype] || ''}`.trim()
        : rtype;
    }

    function drawComposite(graph, opts = {}) {
      const cfg = window.HLSF.config;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found');
        return;
      }
      const ctx = window.HLSF.ctx || (window.HLSF.ctx = canvas.getContext('2d'));
      const width = canvas.width = canvas.clientWidth;
      const height = canvas.height = canvas.clientHeight;
      const theme = cfg.whiteBg
        ? { bg: '#fff', fg: '#000', hint: '#444' }
        : { bg: '#000', fg: '#fff', hint: '#bbb' };
      const edgeColorMode = normalizeEdgeColorMode(cfg.edgeColorMode);
      const edgeWidth = clampEdgeWidth(cfg.edgeWidth);
      const nodeScale = clampNodeSize(cfg.nodeSize);
      const showGlow = cfg.showNodeGlow === true;
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = theme.fg;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const seeds = graph.seeds && graph.seeds.length ? graph.seeds : [...graph.nodes.keys()].slice(0, 1);
      const pos = new Map();
      const cx = width / 2;
      const cy = height / 2;
      if (!window.HLSF.__centerInit) {
        window.HLSF.config.tx = cx;
        window.HLSF.config.ty = cy;
        window.HLSF.__centerInit = true;
      }
      const centerX = Number.isFinite(window.HLSF.config.tx) ? window.HLSF.config.tx : cx;
      const centerY = Number.isFinite(window.HLSF.config.ty) ? window.HLSF.config.ty : cy;
      const scale = typeof cfg.scale === 'number' && cfg.scale > 0 ? cfg.scale : 1;
      const fontScale = Math.max(0.6, Math.min(2.5, Math.sqrt(scale)));
      ctx.font = `${Math.max(9, Math.round(12 * fontScale))}px 'Fira Code', monospace`;
      const effectiveEdgeWidth = edgeWidth * Math.max(0.6, Math.min(2.5, scale));
      ctx.lineWidth = effectiveEdgeWidth;
      const Rc = Math.min(width, height) * 0.35 * scale;
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;

      seeds.forEach((token, idx) => {
        const angle = (idx / Math.max(1, seeds.length)) * Math.PI * 2 + rotation;
        const x = centerX + Rc * Math.cos(angle);
        const y = centerY + Rc * Math.sin(angle);
        pos.set(token, { x, y });
      });

      const groupByRoot = new Map();
      graph.edges.forEach(edge => {
        if (!groupByRoot.has(edge.from)) groupByRoot.set(edge.from, []);
        groupByRoot.get(edge.from).push(edge);
      });

      for (const [root, edges] of groupByRoot.entries()) {
        const base = pos.get(root) || { x: centerX, y: centerY };
        const R = Math.min(width, height) * 0.18 * scale;
        edges
          .slice(0, 10)
          .sort((a, b) => b.w - a.w)
          .forEach((edge, i) => {
            const theta = Math.PI * (i / Math.max(1, edges.length - 1));
            const x = base.x + R * Math.cos(theta);
            const y = base.y - R * Math.sin(theta);
            if (!pos.has(edge.to)) pos.set(edge.to, { x, y });
          });
      }

      const glyphOnly = opts.glyphOnly === true;
      if (cfg.showEdges !== false) {
        graph.edges.forEach(edge => {
          const from = pos.get(edge.from) || pos.get(edge.to);
          const to = pos.get(edge.to);
          if (!from || !to) return;
          ctx.globalAlpha = edgeAlphaFromWeight(edge.w);
          const strokeColor = compositeEdgeStrokeColor(edge, edgeColorMode) || theme.fg;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = theme.fg;
          if (cfg.showLabels !== false) {
            const mx = (from.x + to.x) / 2;
            const my = (from.y + to.y) / 2;
            ctx.fillStyle = theme.hint;
            ctx.fillText(edgeLabel(edge.rtype), mx, my - 10 * scale);
            ctx.fillStyle = theme.fg;
          }
        });
      }

      for (const [token, data] of graph.nodes.entries()) {
        const position = pos.get(token) || { x: centerX, y: centerY };
        const freq = typeof data.f === 'number' ? data.f : 1;
        const radius = Math.max(2, (4 + 2 * Math.log2(1 + Math.max(0, freq))) * scale * nodeScale);
        ctx.globalAlpha = baseAlpha();
        ctx.save();
        if (showGlow) {
          ctx.shadowColor = 'rgba(0, 255, 136, 0.35)';
          ctx.shadowBlur = 14 * Math.max(1, scale);
        }
        ctx.beginPath();
        ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        ctx.globalAlpha = 1.0;
        if (cfg.showLabels !== false) {
          ctx.globalAlpha = baseAlpha();
          ctx.fillStyle = theme.fg;
          ctx.fillText(nodeLabel(token, glyphOnly), position.x, position.y - (radius + 12 * scale));
          ctx.globalAlpha = 1.0;
        }
      }

      ctx.restore();
    }

    // ---------------- O20 layout ----------------
    function buildO20Layout(width, height, margin = 32) {
      const cx = width / 2;
      const cy = height / 2;
      const R = Math.min(cx, cy) - margin;
      const slots = [];
      for (let i = 0; i < 20; i++) {
        const theta = Math.PI * (i / 19);
        slots.push({
          x: cx + R * Math.cos(theta),
          y: cy - R * Math.sin(theta),
          theta
        });
      }
      return { cx, cy, R, slots };
    }

    function getCachedO20Layout(width, height, margin = 32) {
      window.HLSF = window.HLSF || {};
      const cache = window.HLSF.layoutCache;
      if (cache && cache.width === width && cache.height === height && cache.margin === margin) {
        return cache.layout;
      }
      const layout = buildO20Layout(width, height, margin);
      window.HLSF.layoutCache = { width, height, margin, layout };
      return layout;
    }

    function applyFrequencyVisuals(f) {
      const value = typeof f === 'number' ? f : 0;
      const stats = window.HLSF?.metrics?.freqStats;
      if (!stats || typeof stats.min !== 'number' || typeof stats.max !== 'number') {
        const clamped = Math.min(1, Math.max(0, value));
        return { norm: clamped, isHigh: value >= 1 };
      }
      const range = stats.max - stats.min;
      const norm = range === 0 ? 0 : (value - stats.min) / range;
      const clamped = Math.min(1, Math.max(0, norm));
      const threshold = typeof stats.p90 === 'number' ? stats.p90 : stats.max;
      return { norm: clamped, isHigh: value >= threshold };
    }

    // ---------------- Canvas renderer ----------------
    function drawHLSFMatrix(graph, opts = {}) {
      drawComposite(graph, opts);
    }

    let _anim = null;
    function animateComposite(graph, glyphOnly = false) {
      if (!graph) return;
      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawComposite(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function animateHLSF(graph, glyphOnly = false) {
      if (!graph) return;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found for animation');
        return;
      }

      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawHLSFMatrix(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function stopHLSFAnimation() {
      if (_anim) {
        cancelAnimationFrame(_anim);
        _anim = null;
      }
      if (window.HLSF) {
        window.HLSF.currentGraph = null;
        window.HLSF.currentGlyphOnly = false;
        window.HLSF.__centerInit = false;
      }
      if (typeof stopLegacyHLSFAnimation === 'function') {
        try {
          stopLegacyHLSFAnimation();
        } catch (err) {
          console.warn('Legacy HLSF animation stop failed:', err);
        }
      }
    }

    const MAX_REL_TYPES = 50;
    const MAX_EDGES_PER_TYPE = 10;

    function clampRelationTypeCap(value) {
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return MAX_REL_TYPES;
      return Math.min(MAX_REL_TYPES, Math.max(1, numeric));
    }

    function clampEdgesPerType(value) {
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return 3;
      return Math.min(MAX_EDGES_PER_TYPE, Math.max(1, numeric));
    }

    function clampEdgeWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1.2;
      return Math.min(5, Math.max(0.2, numeric));
    }

    function clampNodeSize(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1;
      return Math.min(2.5, Math.max(0.5, numeric));
    }

    function normalizeEdgeColorMode(value) {
      switch (value) {
        case 'weight':
        case 'relation':
          return value;
        default:
          return 'theme';
      }
    }

    function ensureHLSFCanvas() {
      let wrapper = document.getElementById('hlsf-canvas-container');
      if (wrapper) {
        wrapper.style.display = '';
      } else {
        if (!elements?.log) {
          console.warn('Log element not ready for HLSF canvas');
          return null;
        }

        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;

        wrapper = document.createElement('div');
        wrapper.id = 'hlsf-canvas-container';
        wrapper.className = 'hlsf-canvas-container';
        wrapper.innerHTML = `
          <div class="section-title">🔭 HLSF Matrix Visualizer</div>
          <canvas id="hlsf-canvas"></canvas>
          <div class="hlsf-controls">
            <div class="hlsf-control-group">
              <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
              <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
              <input id="hlsf-alpha" type="range" min="0.01" max="0.99" step="0.01" value="0.70">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-width">Edge width <span id="hlsf-edge-width-val">1.2</span></label>
              <input id="hlsf-edge-width" type="range" min="0.2" max="5" step="0.1" value="1.2">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
              <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-color-mode">Edge coloring</label>
              <select id="hlsf-edge-color-mode">
                <option value="theme">Theme</option>
                <option value="weight">Weight</option>
                <option value="relation">Relation</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">${MAX_REL_TYPES}</span></label>
              <input id="hlsf-relation-cap" type="number" min="1" max="${MAX_REL_TYPES}" step="1" value="${MAX_REL_TYPES}">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
              <input id="hlsf-edges-per-type" type="number" min="1" max="${MAX_EDGES_PER_TYPE}" step="1" value="3">
            </div>
            <div class="hlsf-control-group">
              <label>Display options</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
                <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
                <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
                <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>Rotation modes</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
                <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergent</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>View</label>
              <div class="hlsf-button-row">
                <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
                <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
                <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
              </div>
            </div>
          </div>
        `;

        entry.appendChild(wrapper);
        elements.log.appendChild(entry);
        elements.log.scrollTop = elements.log.scrollHeight;
      }

      const canvas = /** @type {HTMLCanvasElement|null} */ (wrapper.querySelector('#hlsf-canvas'));
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      bindHlsfControls(wrapper);
      syncHlsfControls(wrapper);

      return canvas;
    }

    function bindHlsfControls(wrapper) {
      if (!wrapper || wrapper.dataset.controlsBound === 'true') return;

      const canvas = wrapper.querySelector('#hlsf-canvas');
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      if (speedSlider && speedVal) {
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }

      const edgeWidthSlider = wrapper.querySelector('#hlsf-edge-width');
      const edgeWidthVal = wrapper.querySelector('#hlsf-edge-width-val');
      if (edgeWidthSlider && edgeWidthVal) {
        edgeWidthSlider.addEventListener('input', (e) => {
          const next = clampEdgeWidth(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.edgeWidth = next;
          edgeWidthVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(edgeWidthSlider.value)) > 1e-6) {
            edgeWidthSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      if (nodeSizeSlider && nodeSizeVal) {
        nodeSizeSlider.addEventListener('input', (e) => {
          const next = clampNodeSize(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.nodeSize = next;
          nodeSizeVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(nodeSizeSlider.value)) > 1e-6) {
            nodeSizeSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      if (relationInput) {
        relationInput.addEventListener('input', () => {
          const next = clampRelationTypeCap(relationInput.value);
          window.HLSF.config.relationTypeCap = next;
          relationInput.value = String(next);
          if (relationVal) relationVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      if (edgesInput) {
        edgesInput.addEventListener('input', () => {
          const next = clampEdgesPerType(edgesInput.value);
          window.HLSF.config.edgesPerType = next;
          edgesInput.value = String(next);
          if (edgesVal) edgesVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      if (edgeColorSelect) {
        edgeColorSelect.addEventListener('change', (e) => {
          const value = normalizeEdgeColorMode(e.target.value);
          window.HLSF.config.edgeColorMode = value;
          edgeColorSelect.value = value;
          debouncedLegacyRender();
        });
      }

      const zoomIn = wrapper.querySelector('#hlsf-zoom-in');
      if (zoomIn) {
        zoomIn.addEventListener('click', () => {
          window.HLSF.config.scale *= 1.2;
          debouncedLegacyRender();
        });
      }

      const zoomOut = wrapper.querySelector('#hlsf-zoom-out');
      if (zoomOut) {
        zoomOut.addEventListener('click', () => {
          window.HLSF.config.scale *= 0.8;
          debouncedLegacyRender();
        });
      }

      const reset = wrapper.querySelector('#hlsf-reset-view');
      if (reset) {
        reset.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          window.HLSF.config.scale = 1;
          if (canvasEl) {
            window.HLSF.config.tx = canvasEl.width / 2;
            window.HLSF.config.ty = canvasEl.height / 2;
          } else {
            window.HLSF.config.tx = 0;
            window.HLSF.config.ty = 0;
          }
          debouncedLegacyRender();
        });
      }

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) {
        rotationBtn.addEventListener('click', () => {
          window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
          if (window.HLSF.config.rotationActive) {
            window.HLSF.config.emergentActive = false;
          }
          syncHlsfControls(wrapper);
        });
      }

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) {
        emergentBtn.addEventListener('click', () => {
          window.HLSF.config.emergentActive = !window.HLSF.config.emergentActive;
          if (window.HLSF.config.emergentActive) {
            window.HLSF.config.rotationActive = false;
          }
          syncHlsfControls(wrapper);
        });
      }

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) {
        edgesBtn.addEventListener('click', () => {
          window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
          edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
          debouncedLegacyRender();
        });
      }

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) {
        labelsBtn.addEventListener('click', () => {
          window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
          labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
          debouncedLegacyRender();
        });
      }

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) {
        glowBtn.addEventListener('click', () => {
          window.HLSF.config.showNodeGlow = !window.HLSF.config.showNodeGlow;
          glowBtn.textContent = window.HLSF.config.showNodeGlow ? 'Glow: On' : 'Glow: Off';
          debouncedLegacyRender();
        });
      }

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) {
        bgBtn.addEventListener('click', () => {
          window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
          bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
          debouncedLegacyRender();
        });
      }

      const canvasEl = wrapper.querySelector('#hlsf-canvas');
      if (canvasEl) {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvasEl.addEventListener('mousedown', (e) => {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvasEl.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.config.tx += dx;
          window.HLSF.config.ty += dy;
          lastX = e.clientX;
          lastY = e.clientY;
          debouncedLegacyRender();
        });

        canvasEl.addEventListener('mouseleave', () => {
          isDragging = false;
        });
      }

      wrapper.dataset.controlsBound = 'true';
    }

    function syncHlsfControls(wrapper) {
      if (!wrapper) return;

      const config = window.HLSF.config || {};
      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      const omega = Number.isFinite(config.rotationOmega) ? config.rotationOmega : 0;
      window.HLSF.config.rotationOmega = omega;
      if (speedSlider) speedSlider.value = omega.toFixed(2);
      if (speedVal) speedVal.textContent = omega.toFixed(2);

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      const alpha = clampAlpha(config.alpha);
      window.HLSF.config.alpha = alpha;
      if (alphaSlider) alphaSlider.value = alpha.toFixed(2);
      if (alphaVal) alphaVal.textContent = alpha.toFixed(2);

      const edgeWidthSlider = wrapper.querySelector('#hlsf-edge-width');
      const edgeWidthVal = wrapper.querySelector('#hlsf-edge-width-val');
      const edgeWidth = clampEdgeWidth(config.edgeWidth);
      window.HLSF.config.edgeWidth = edgeWidth;
      if (edgeWidthSlider) edgeWidthSlider.value = edgeWidth.toFixed(1);
      if (edgeWidthVal) edgeWidthVal.textContent = edgeWidth.toFixed(1);

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      const nodeSize = clampNodeSize(config.nodeSize);
      window.HLSF.config.nodeSize = nodeSize;
      if (nodeSizeSlider) nodeSizeSlider.value = nodeSize.toFixed(1);
      if (nodeSizeVal) nodeSizeVal.textContent = nodeSize.toFixed(1);

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      const relationCap = clampRelationTypeCap(config.relationTypeCap);
      window.HLSF.config.relationTypeCap = relationCap;
      if (relationInput) relationInput.value = String(relationCap);
      if (relationVal) relationVal.textContent = String(relationCap);

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      const edgesPerType = clampEdgesPerType(config.edgesPerType);
      window.HLSF.config.edgesPerType = edgesPerType;
      if (edgesInput) edgesInput.value = String(edgesPerType);
      if (edgesVal) edgesVal.textContent = String(edgesPerType);

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      const colorMode = normalizeEdgeColorMode(config.edgeColorMode);
      window.HLSF.config.edgeColorMode = colorMode;
      if (edgeColorSelect) edgeColorSelect.value = colorMode;

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) rotationBtn.textContent = config.rotationActive ? 'Stop Global' : 'Start Global';

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) emergentBtn.textContent = config.emergentActive ? 'Stop Emergent' : 'Start Emergent';

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) edgesBtn.textContent = config.showEdges ? 'Edges: On' : 'Edges: Off';

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) labelsBtn.textContent = config.showLabels ? 'Labels: On' : 'Labels: Off';

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) glowBtn.textContent = config.showNodeGlow ? 'Glow: On' : 'Glow: Off';

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) bgBtn.textContent = config.whiteBg ? 'BG: Light' : 'BG: Dark';
    }

    window.HLSF = window.HLSF || {};
    const existingConfig = window.HLSF.config || {};
    const DEFAULT_BOOTSTRAP_DB = "HLSF_Database_2025-10-15.json";
    window.HLSF.config = Object.assign({
      bootstrapDbUrl: existingConfig.bootstrapDbUrl || DEFAULT_BOOTSTRAP_DB,
      rotationActive: true,
      rotationOmega: 0.30,
      alpha: 0.10,
      scale: 1,
      tx: 0,
      ty: 0,
      emergentActive: false,
      showEdges: true,
      showLabels: true,
      fillFaces: false,
      whiteBg: false,
      showEnglish: true,
      fullSeedCap: 0,
      relationTypeCap: MAX_REL_TYPES,
      edgesPerType: 3,
      edgeWidth: 1.2,
      nodeSize: 1,
      edgeColorMode: 'theme',
      showNodeGlow: false,
    }, existingConfig);
    window.HLSF.config.relationTypeCap = clampRelationTypeCap(window.HLSF.config.relationTypeCap);
    window.HLSF.config.edgesPerType = clampEdgesPerType(window.HLSF.config.edgesPerType);
    window.HLSF.config.edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
    window.HLSF.config.nodeSize = clampNodeSize(window.HLSF.config.nodeSize);
    window.HLSF.config.edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
    window.HLSF.config.showNodeGlow = window.HLSF.config.showNodeGlow === true;
    window.HLSF.state = Object.assign({
      globalRot: 0,
      emergentRot: 0,
    }, window.HLSF.state || {});
    window.HLSF.canvas = window.HLSF.canvas || null;
    window.HLSF.ctx = window.HLSF.ctx || null;
    window.HLSF.nodes = window.HLSF.nodes || [];
    window.HLSF.animationFrame = window.HLSF.animationFrame || null;
    window.HLSF.geometry = window.HLSF.geometry || {};
    window.HLSF.rendering = window.HLSF.rendering || {};
    window.HLSF.__centerInit = window.HLSF.__centerInit || false;

    const clampAlpha = (value) => {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return NaN;
      return Math.min(0.99, Math.max(0.01, numeric));
    };
    window.HLSF.config.alpha = (() => {
      const initial = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(initial) ? initial : 0.1;
    })();
    const baseAlpha = () => {
      const resolved = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(resolved) ? resolved : 0.1;
    };
    const edgeAlphaFromWeight = (w) => {
      const preferred = Number.isFinite(w) ? clampAlpha(w) : NaN;
      if (Number.isFinite(preferred)) return preferred;
      return baseAlpha();
    };

    const EDGE_COLOR_PALETTE = [
      '#00ff88', '#ffd54f', '#ff6f91', '#64b5f6', '#ce93d8',
      '#ff8a65', '#4dd0e1', '#9ccc65', '#f06292', '#ba68c8'
    ];

    function paletteColor(key) {
      if (!key) return EDGE_COLOR_PALETTE[0];
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = (hash * 33 + key.charCodeAt(i)) | 0;
      }
      const index = Math.abs(hash) % EDGE_COLOR_PALETTE.length;
      return EDGE_COLOR_PALETTE[index];
    }

    function normalizedIntensity(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(1, numeric));
    }

    function weightToColor(value) {
      const t = normalizedIntensity(value);
      const r = Math.round(255 - 90 * t);
      const g = Math.round(160 + 80 * t);
      const b = Math.round(120 + 16 * (1 - t));
      const alpha = 0.45 + 0.45 * t;
      return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2)})`;
    }

    function nodeEdgeStrokeColor(node, index, mode) {
      if (mode === 'relation') {
        return paletteColor(`${node.token}-${index}`);
      }
      if (mode === 'weight') {
        return weightToColor(node.attention ?? 0);
      }
      return null;
    }

    function compositeEdgeStrokeColor(edge, mode) {
      if (mode === 'relation') {
        return paletteColor(edge.rtype || `${edge.from}->${edge.to}`);
      }
      if (mode === 'weight') {
        return weightToColor(edge.w ?? 0);
      }
      return null;
    }

    function stepRotation(dt) {
      const w = window.HLSF.config.rotationOmega || 0;
      if ((!window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive) || !w) return;
      const tau = 2 * Math.PI;
      window.HLSF.state.globalRot = (window.HLSF.state.globalRot + dt * w) % tau;
      window.HLSF.state.emergentRot = (window.HLSF.state.emergentRot + dt * w) % tau;
    }

    let TokenToGlyph = new Map();
    let GlyphToToken = new Map();

    function loadGlyphMaps(db) {
      if (!db) return;
      if (!(TokenToGlyph instanceof Map)) TokenToGlyph = new Map();
      if (!(GlyphToToken instanceof Map)) GlyphToToken = new Map();
      TokenToGlyph.clear();
      GlyphToToken.clear();
      (db.token_glyph_map || []).forEach(({ token, glyph }) => {
        if (token && glyph) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
      (db.glyph_token_map || []).forEach(({ glyph, token }) => {
        if (glyph && token) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
    }

    window.CognitionEngine = window.CognitionEngine || {
      state: {},
      cache: {},
      api: {},
      processing: {},
    };

    window.GlyphSystem = window.GlyphSystem || {
      ledger: null,
      encode: () => '',
      decode: () => '',
      export: () => ({}),
    };

    // ---- Glyph crypto core ----
    const LEDGER_KEY = "HLSF_GLYPH_LEDGER_V1";
    const GLYPH_SET = Array.from("⬣⬧⬩⬡⬪⬨⬤⬟⬢⬥⬠⬙⬘⬗⬖⬕⬔⬓⬒⬑"); // limited symbols
    const GLYPH_SEP = " "; // delimiter between glyph-weight pairs
    const NUM_FMT = n => Number(n).toString(); // unlimited precision as given

    function hydrateLedgerMaps(ledger) {
      TokenToGlyph.clear();
      GlyphToToken.clear();
      const map = ledger?.glyph_map || {};
      for (const glyph of Object.keys(map)) {
        const entries = Array.isArray(map[glyph]) ? map[glyph] : [];
        for (const entry of entries) {
          if (!entry || !entry.token) continue;
          TokenToGlyph.set(entry.token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(entry.token);
        }
      }
    }

    // Load/save ledger
    function loadLedger() {
      let ledger;
      try {
        const raw = localStorage.getItem(LEDGER_KEY);
        ledger = raw ? JSON.parse(raw) : null;
      } catch {
        ledger = null;
      }
      if (!ledger || typeof ledger !== 'object') {
        ledger = { version: "1.0", created_at: new Date().toISOString(), glyph_map: {} };
      } else {
        ledger.version = ledger.version || "1.0";
        ledger.created_at = ledger.created_at || new Date().toISOString();
        ledger.glyph_map = ledger.glyph_map || {};
      }
      hydrateLedgerMaps(ledger);
      return ledger;
    }
    function saveLedger(ledger) {
      try {
        localStorage.setItem(LEDGER_KEY, JSON.stringify(ledger));
      } catch (err) {
        console.warn('Failed to persist glyph ledger:', err);
      }
    }

    // ---- HLSF constants
    const TOKEN_CACHE_PREFIX = 'hlsf_token_';
    const DB_RAW_KEY = 'HLSF_DB_RAW';        // stores JSON export text
    const API_KEY_STORAGE_KEY = 'HLSF_API_KEY';
    const DB_INDEX_KEY = 'HLSF_DB_INDEX';    // array of token strings

    function parseMaybeNdjson(text) {
      try { return JSON.parse(text); } catch {}
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const rows = [];
      for (const ln of lines) {
        try { rows.push(JSON.parse(ln)); } catch {}
      }
      return rows.length ? rows : null;
    }

    function coerceDb(input) {
      const data = (typeof input === 'string') ? parseMaybeNdjson(input.replace(/^\uFEFF/, '')) : input;
      if (!data) throw new Error('Unparseable JSON/NDJSON');
      if (data && !Array.isArray(data) && Array.isArray(data.full_token_data)) {
        return Object.assign({}, data, { full_token_data: data.full_token_data });
      }
      if (Array.isArray(data)) return { full_token_data: data };
      throw new Error('Invalid database format. Expected full_token_data array.');
    }

    function normalizeRecord(rec) {
      if (!rec || typeof rec.token !== 'string') return null;
      const rels = rec.relationships && typeof rec.relationships === 'object' ? rec.relationships : {};
      const out = { token: rec.token, relationships: rels, cached_at: rec.cached_at || null };
      for (const [key, value] of Object.entries(rec)) {
        if (key === 'token' || key === 'relationships' || key === 'cached_at') continue;
        out[key] = value;
      }
      return out;
    }

    function loadDbObject(dbLike) {
      const db = coerceDb(dbLike);
      const raw = Array.from(db.full_token_data || []);
      const clean = raw.map(normalizeRecord).filter(Boolean);
      if (!clean.length) throw new Error('No valid token records');
      const out = Object.assign({}, db, { full_token_data: clean });
      localStorage.setItem(DB_RAW_KEY, JSON.stringify(out));
      const index = clean.map(r => r.token);
      localStorage.setItem(DB_INDEX_KEY, JSON.stringify(index));
      window.HLSF.dbCache = out;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      state.hlsfReady = false;
      if (typeof buildHLSFMatrices === 'function') {
        try {
          buildHLSFMatrices(out);
        } catch (err) {
          console.warn('Failed to rebuild HLSF matrices:', err);
        }
      }
      updateHeaderCounts();
      return clean.length;
    }

    function getDb() {
      if (window.HLSF.dbCache) return window.HLSF.dbCache;
      let raw = null;
      try {
        raw = localStorage.getItem(DB_RAW_KEY);
        if (!raw) {
          const legacy = localStorage.getItem('hlsf_db_raw');
          if (legacy) {
            localStorage.setItem(DB_RAW_KEY, legacy);
            localStorage.removeItem('hlsf_db_raw');
            raw = legacy;
          }
        }
      } catch (err) {
        console.warn('Failed to read DB from storage:', err);
        raw = null;
      }
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        window.HLSF.dbCache = parsed;
        return parsed;
      } catch (err) {
        console.warn('Stored DB is not valid JSON:', err);
        return null;
      }
    }

    // Symbolic glyphs for complex number representation
    const GLYPH_LIBRARY = [
      '◉', '◈', '◇', '◆', '◊', '○', '●', '◐', '◑', '◒',
      '◓', '☉', '⊙', '⊚', '⊛', '⊜', '⊝', '◎', '◍', '◌',
      '△', '▲', '▽', '▼', '◁', '▷', '◀', '▶', '⬟', '⬠',
      '⬡', '⬢', '⬣', '⬤', '⬥', '⬦', '⬧', '⬨', '⬩', '⬪',
      '⬫', '⬬', '⬭', '⬮', '⬯', '⭐', '★', '☆', '✦', '✧',
      '✶', '✷', '✸', '✹', '✺', '✻', '✼', '✽', '✾', '✿',
      '❀', '❁', '❂', '❃', '❄', '❅', '❆', '❇', '❈', '❉',
      '⚙', '⚛', '⚝', '⚞', '⚟', '⚬', '⚭', '⚮', '⚯', '⚰'
    ];

    const RELATIONSHIP_PRIORITIES = new Map([
      ['≡', 1.0], ['⊃', 1.0], ['⊂', 0.8], ['≈', 0.7], ['∈', 0.9], ['∋', 0.9],
      ['⊤', 0.9], ['⊥', 0.9], ['⊏', 0.8], ['⊐', 0.8], ['↔', 0.7], ['⇌', 0.7],
      ['∥', 0.6], ['∼', 0.5], ['→', 0.5], ['⇒', 0.5], ['⇐', 0.5], ['↠', 0.5],
      ['↗', 0.4], ['↘', 0.4], ['⇝', 1.0], ['⇂', 0.7], ['≠', 0.8], ['⊕', 0.8],
      ['⊛', 0.7], ['∝', 0.7], ['⇝ Causes', 1.0], ['⇐ Caused By', 0.9],
      ['∗', 0.7], ['≜', 0.9], ['⋆', 0.8], ['7→', 0.7], ['⊢', 0.9], ['⊣', 0.9],
      ['↷', 0.8], ['↶', 0.8], ['◦', 0.9], ['|=', 0.9], ['◁', 0.6], ['⇄', 0.6],
      ['⊗', 0.9], ['÷', 0.7], ['⊘', 0.8], ['×', 0.8], ['¬', 0.8], ['†', 0.8],
      ['⊠', 0.8], ['/∈', 0.8], ['⊬', 0.8], ['⊩', 0.9], ['⊨', 0.9], ['?', 0.5],
      ['⚡', 0.7], ['⇒ Attention', 0.7], ['↶ Self-Reference', 0.7], ['∧', 0.6],
      ['↭', 0.6], ['▷◁', 0.6]
    ]);

    // ============================================
    // STATE
    // ============================================
    const state = {
      apiKey: '',
      isProcessing: false,
      sessionStats: {
        totalApiCalls: 0,
        totalCacheHits: 0,
        totalCostCents: 0,
      },
      hlsfReady: false,
    };

    state.hlsfReady = false;
    window.CognitionEngine.state = state;

    let currentAbortController = null;

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      log: document.getElementById('log'),
      input: document.getElementById('command-input'),
      sendBtn: document.getElementById('send-btn'),
      cancelBtn: document.getElementById('cancel-btn'),
      apiModal: document.getElementById('api-modal'),
      apiKeyInput: document.getElementById('api-key-input'),
      apiConfirmBtn: document.getElementById('api-confirm'),
      apiCancelBtn: document.getElementById('api-cancel'),
      cacheHitRate: document.getElementById('cache-hit-rate'),
      cachedTokens: document.getElementById('cached-tokens'),
      sessionCost: document.getElementById('session-cost'),
      dbFileInput: document.getElementById('db-file'),
    };

    // ============================================
    // UTILITIES
    // ============================================
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validatePrompt(prompt) {
      if (!prompt || typeof prompt !== 'string') {
        throw new Error('Invalid prompt: must be non-empty string');
      }
      if (prompt.length > 10000) {
        throw new Error('Prompt too long: max 10000 characters');
      }
      return prompt.trim();
    }

    function safeStorageGet(key, defaultValue = null) {
      try {
        const item = localStorage.getItem(key);
        if (item == null) return defaultValue;
        try {
          return JSON.parse(item);
        } catch {
          return item;
        }
      } catch (err) {
        console.warn(`Storage read failed for ${key}:`, err);
        return defaultValue;
      }
    }

    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        console.warn(`Storage write failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.warn(`Storage remove failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageKeys(prefix = '') {
      try {
        return Object.keys(localStorage).filter(k => k.startsWith(prefix));
      } catch (err) {
        console.warn('Storage keys enumeration failed:', err);
        return [];
      }
    }

    function isValidApiKey(key) {
      if (typeof key !== 'string') return false;
      const trimmed = key.trim();
      if (!trimmed) return false;
      if (!trimmed.startsWith('sk-')) return false;
      return trimmed.length >= 20;
    }

    function tokenize(text) {
      if (!text) return [];
      return text.trim()
        .split(/[^\p{L}\p{N}\-']+/u)
        .filter(Boolean)
        .map(t => t.toLowerCase());
    }

    const Session = (() => {
      const existing = window.Session && typeof window.Session === 'object'
        ? window.Session
        : {};
      const session = Object.assign({ tokens: new Set() }, existing);
      window.Session = session;
      return session;
    })();

    function addConversationTokens(arr) {
      for (const token of arr || []) {
        if (token) Session.tokens.add(token);
      }
    }

    function onUserPromptSubmitted(text) {
      const toks = text.trim().split(/\s+/).filter(Boolean);
      addConversationTokens(toks);
    }

    function formatCurrency(cents) {
      return `$${(cents / 100).toFixed(2)}`;
    }

    function getCachedTokenCount() {
      return safeStorageKeys(TOKEN_CACHE_PREFIX).length;
    }

    // ============================================
    // COMPLEX NUMBER ENCODING & GLYPH SYSTEM
    // ============================================
    
    // Convert token to complex number representation
    // Magnitude = attention score, Phase = semantic hash
    function tokenToComplexNumber(token, tokenData) {
      const attentionScore = tokenData?.attention_score || 0.5;
      const magnitude = attentionScore; // 0.0 to 1.0
      
      // Generate phase from token's semantic properties
      let phaseHash = 0;
      for (let i = 0; i < token.length; i++) {
        phaseHash = ((phaseHash << 5) - phaseHash) + token.charCodeAt(i);
        phaseHash = phaseHash & phaseHash;
      }
      
      // Normalize phase to 0-2π
      const phase = (Math.abs(phaseHash) % 360) * (Math.PI / 180);
      
      // Calculate real and imaginary parts
      const real = magnitude * Math.cos(phase);
      const imaginary = magnitude * Math.sin(phase);
      
      return { real, imaginary, magnitude, phase };
    }

    const memoizedComplexNumber = (() => {
      const cache = new Map();
      return (token, tokenData) => {
        const score = tokenData?.attention_score ?? 0;
        const key = `${token}_${score}`;
        if (cache.has(key)) return cache.get(key);
        const result = tokenToComplexNumber(token, tokenData);
        cache.set(key, result);
        return result;
      };
    })();

    // Map complex number to glyph from library
    function complexToGlyph(complex) {
      // Use magnitude and phase to select glyph
      const magnitudeIndex = Math.floor(complex.magnitude * 7); // 0-7 range
      const phaseIndex = Math.floor((complex.phase / (2 * Math.PI)) * 10); // 0-9 range
      const glyphIndex = (magnitudeIndex * 10 + phaseIndex) % GLYPH_LIBRARY.length;
      return GLYPH_LIBRARY[glyphIndex];
    }

    // Generate glyph ledger for all cached tokens
    function generateGlyphLedger() {
      const ledger = new Map();
      const reverseMap = new Map(); // glyph -> tokens
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);

      for (const key of keys) {
        try {
          const tokenData = safeStorageGet(key);
          if (!tokenData?.token) continue;
          const token = tokenData.token;
          const complex = memoizedComplexNumber(token, tokenData);
          const glyph = complexToGlyph(complex);

          ledger.set(token, {
            glyph,
            complex: {
              real: complex.real.toFixed(4),
              imaginary: complex.imaginary.toFixed(4),
              magnitude: complex.magnitude.toFixed(4),
              phase: complex.phase.toFixed(4)
            },
            attention_score: tokenData.attention_score || 0
          });
          
          // Track consolidation - multiple tokens per glyph
          if (!reverseMap.has(glyph)) {
            reverseMap.set(glyph, []);
          }
          reverseMap.get(glyph).push(token);
        } catch (err) {
          console.error('Failed to process token:', key, err);
        }
      }
      
      return { ledger, reverseMap };
    }

    // Consolidate similar tokens to same glyph
    function findConsolidatedTokens(reverseMap) {
      const consolidated = [];
      for (const [glyph, tokens] of reverseMap.entries()) {
        if (tokens.length > 1) {
          consolidated.push({ glyph, tokens, count: tokens.length });
        }
      }
      return consolidated.sort((a, b) => b.count - a.count);
    }

    // Encode message using glyph ledger
    function encodeMessage(message, ledger) {
      const tokens = tokenize(message);
      const encoded = [];
      const unknown = [];
      
      for (const token of tokens) {
        const entry = ledger.get(token);
        if (entry) {
          encoded.push(entry.glyph);
        } else {
          encoded.push('◌'); // Unknown token marker
          unknown.push(token);
        }
      }
      
      return {
        encoded: encoded.join(''),
        coverage: ((tokens.length - unknown.length) / tokens.length * 100).toFixed(1),
        unknown
      };
    }

    // Decode message using reverse glyph map
    function decodeMessage(encoded, reverseMap) {
      const glyphs = Array.from(encoded);
      const decoded = [];
      
      for (const glyph of glyphs) {
        const tokens = reverseMap.get(glyph);
        if (tokens && tokens.length > 0) {
          // Use first token (could use most common or context-aware selection)
          decoded.push(tokens[0]);
        } else {
          decoded.push('[?]');
        }
      }
      
      return decoded.join(' ');
    }

    // Export glyph ledger for inter-system transmission
    function exportGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        ledger_version: "1.0",
        description: "HLSF Symbolic Glyph Encryption Ledger - Complex Number Token Encoding",
        specification: {
          encoding: "Complex numbers (magnitude=attention, phase=semantic_hash)",
          glyph_library_size: GLYPH_LIBRARY.length,
          representation: "Unicode symbolic glyphs",
          consolidation: "Similar tokens map to same glyph based on complex number proximity"
        },
        statistics: {
          total_tokens: ledger.size,
          unique_glyphs: reverseMap.size,
          consolidation_ratio: (ledger.size / reverseMap.size).toFixed(2),
          consolidated_groups: consolidated.length
        },
        glyph_ledger: Object.fromEntries(ledger),
        reverse_mapping: Object.fromEntries(
          Array.from(reverseMap.entries()).map(([glyph, tokens]) => [glyph, tokens])
        ),
        consolidated_tokens: consolidated,
        encryption_examples: generateEncryptionExamples(ledger, reverseMap)
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Glyph_Ledger_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return exportData;
    }

    window.GlyphSystem.ledger = null;
    window.GlyphSystem.encode = function encode(message) {
      const result = encryptTextToGlyphs(message || '');
      window.GlyphSystem.ledger = loadLedger();
      return { encoded: result.encrypted, coverage: result.coverage, unknown: result.unknown };
    };
    window.GlyphSystem.decode = function decode(encoded) {
      return decryptGlyphsToText(encoded || '');
    };
    window.GlyphSystem.export = function exportLedgerSnapshot() {
      return loadLedger();
    };

    function generateEncryptionExamples(ledger, reverseMap) {
      const examples = [
        "hello world",
        "consciousness",
        "quantum entanglement"
      ];
      
      return examples.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          plaintext: msg,
          encoded: result.encoded,
          coverage: result.coverage + '%',
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
    }

    function showGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      // Show sample encoded messages
      const sampleMessages = [
        "What is consciousness?",
        "Explain quantum mechanics",
        "The nature of reality"
      ];
      
      const encodedSamples = sampleMessages.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          original: msg,
          encoded: result.encoded,
          coverage: result.coverage,
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">🔐 Symbolic Glyph Encryption Ledger</div>
        
        <div class="adjacency-insight">
          <strong>📐 Complex Number Encoding:</strong><br>
          • Each token → Complex number (magnitude + phase)<br>
          • Magnitude = Attention score (0.0-1.0)<br>
          • Phase = Semantic hash (0-2π radians)<br>
          • Glyph = Visual representation of complex coordinates
        </div>

        <div class="adjacency-insight">
          <strong>📊 Ledger Statistics:</strong><br>
          • Total tokens: <strong>${ledger.size}</strong><br>
          • Unique glyphs: <strong>${reverseMap.size}</strong><br>
          • Consolidation ratio: <strong>${(ledger.size / reverseMap.size).toFixed(2)}:1</strong><br>
          • Efficiency gain: <strong>${(100 - (reverseMap.size / ledger.size * 100)).toFixed(1)}%</strong>
        </div>

        <div class="adjacency-insight">
          <strong>🔄 Token Consolidation (Similar tokens → Same glyph):</strong><br>
          ${consolidated.slice(0, 5).map(c => 
            `• <span style="font-size: 1.5em;">${c.glyph}</span> → ${c.tokens.slice(0, 3).join(', ')}${c.tokens.length > 3 ? '...' : ''} (${c.count} tokens)`
          ).join('<br>')}
          ${consolidated.length === 0 ? '<em>No consolidation yet - need more diverse tokens</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔐 Encrypted Message Examples:</strong><br>
          ${encodedSamples.map(s => `
            <div style="margin: 0.75rem 0; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <div style="opacity: 0.7; font-size: 0.85em;">Original:</div>
              <div style="margin: 0.25rem 0;">${s.original}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Encrypted (${s.coverage}% coverage):</div>
              <div style="font-size: 1.3em; letter-spacing: 0.1em; color: var(--accent); margin: 0.25rem 0;">${s.encoded}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Decoded:</div>
              <div style="margin: 0.25rem 0;">${s.decoded}</div>
            </div>
          `).join('')}
        </div>

        <details>
          <summary>📖 View full glyph mapping (first 20 tokens)</summary>
          <pre>${JSON.stringify(
            Object.fromEntries(Array.from(ledger.entries()).slice(0, 20)),
            null, 2
          )}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Usage:</strong> This ledger enables secure inter-system communication. 
          Messages encoded with glyphs can be transmitted efficiently and decoded by any system 
          with the same ledger. The consolidation reduces message size while maintaining semantic meaning.
        </div>
      `);
    }

    // ============================================
    // LOGGING
    // ============================================
    function batchLogUpdates(entries) {
      const fragment = document.createDocumentFragment();
      entries.forEach(entry => fragment.appendChild(entry));
      elements.log.appendChild(fragment);
      elements.log.scrollTop = elements.log.scrollHeight;
    }

    function addLog(content, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>${content}`;
      batchLogUpdates([entry]);
      return entry;
    }

    function appendLog(msg, type = 'info') {
      if (typeof msg === 'string') return addLog(msg, type);
      return addLog(sanitize(String(msg)), type);
    }

    function logStatus(msg) {
      return appendLog(`<div class="processing-indicator"><span class="spinner"></span>${sanitize(msg)}</div>`, 'status');
    }
    function logError(msg) { return appendLog(`🔴 ${sanitize(msg)}`, 'error'); }
    function logSuccess(msg) { return appendLog(`✅ ${sanitize(msg)}`, 'success'); }
    function logWarning(msg) { return appendLog(`⚠️ ${sanitize(msg)}`, 'warning'); }
    function logFinal(msg) { return appendLog(`✅ ${sanitize(msg)}`, 'success'); }

    function debounce(fn, delay) {
      let timeout;
      return function debounced(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    async function safeAsync(fn, errorMsg) {
      try {
        return await fn();
      } catch (err) {
        logError(`${errorMsg}: ${err.message}`);
        console.error(errorMsg, err);
        return null;
      }
    }

    // ============================================
    // STATS
    // ============================================
    function updateStats() {
      const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
      const total = totalApiCalls + totalCacheHits;
      const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) + '%' : '—';

      const cachedCount = getCachedTokenCount();

      elements.cacheHitRate.textContent = hitRate;
      elements.cachedTokens.textContent = cachedCount;
      elements.sessionCost.textContent = formatCurrency(totalCostCents);

      // Visual feedback for database growth
      if (cachedCount > 0) {
        elements.cachedTokens.style.color = cachedCount > 50 ? '#00ff88' : '#ffd54f';
      }
    }

    function updateHeaderCounts() {
      updateStats();
    }

    // ============================================
    // CACHE
    // ============================================
    function getCacheKey(token) {
      const normalized = token == null ? '' : String(token);
      return `${TOKEN_CACHE_PREFIX}${normalized.toLowerCase()}`;
    }

    function updateTokenIndex(token) {
      if (!token) return;

      let index = safeStorageGet(DB_INDEX_KEY, []);
      if (!Array.isArray(index)) index = [];
      if (!index.includes(token)) {
        index.push(token);
        safeStorageSet(DB_INDEX_KEY, JSON.stringify(index));
      }
    }

    function getFromCache(token) {
      try {
        const raw = safeStorageGet(getCacheKey(token));
        if (!raw) return null;
        state.sessionStats.totalCacheHits++;
        updateStats();
        return raw;
      } catch { return null; }
    }

    function saveToCache(token, data) {
      try {
        const payloadData = {
          ...data,
          cached_at: new Date().toISOString(),
        };
        const payload = JSON.stringify(payloadData);
        const ok = safeStorageSet(getCacheKey(token), payload);
        if (!ok) return;
        updateTokenIndex(token);
      } catch (err) {
        if (err.name === 'QuotaExceededError') {
          logWarning('Cache full. Use /reset to clear old data.');
        }
      }
    }

    window.CognitionEngine.cache = {
      get: getFromCache,
      set: saveToCache,
      key: getCacheKey,
    };

    // ============================================
    // OPENAI API
    // ============================================
    async function callOpenAI(messages, options = {}) {
      if (!state.apiKey) throw new Error('No API key configured');

      const body = {
        model: options.model || CONFIG.DEFAULT_MODEL,
        messages,
        max_tokens: options.max_tokens || 1000,
        temperature: options.temperature || 0.7,
      };

      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
        if (currentAbortController?.signal.aborted) {
          const error = new Error('Cancelled');
          error.name = 'AbortError';
          throw error;
        }

        attempt++;
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.apiKey}`,
            },
            body: JSON.stringify(body),
          });

          if (response.status === 429 && attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
            await new Promise(r => setTimeout(r, CONFIG.RETRY_BASE_DELAY_MS * Math.pow(2, attempt - 1)));
            continue;
          }

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `API error (${response.status})`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error?.message) errorMessage = errorData.error.message;
            } catch (e) {
              if (errorText) errorMessage = errorText;
            }
            
            if (response.status === 401) errorMessage = 'Invalid API key';
            else if (response.status === 403) errorMessage = 'Access forbidden - check billing setup';
            else if (response.status === 429) errorMessage = 'Rate limit exceeded';
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          state.sessionStats.totalApiCalls++;
          state.sessionStats.totalCostCents += Math.ceil(CONFIG.ESTIMATED_COST_PER_API_CALL * 100);
          updateStats();

          return data.choices?.[0]?.message?.content?.trim() || '';
        } catch (err) {
          if (err.name === 'AbortError') throw err;
          if (err.message === 'Failed to fetch') {
            throw new Error('Network error - check connection or download HTML to run locally');
          }
          if (attempt === CONFIG.MAX_RETRY_ATTEMPTS) throw err;
        }
      }
    }

    window.CognitionEngine.api = {
      callOpenAI,
    };

    // ============================================
    // ADJACENCY
    // ============================================
    class ProgressTracker {
      constructor(total, label) {
        this.total = total;
        this.current = 0;
        this.label = label;
        this.element = logStatus(`⏳ ${label} (0/${total})`);
      }

      increment(count = 1) {
        this.current += count;
        const percent = this.total === 0 ? 100 : Math.round((this.current / this.total) * 100);
        if (this.element) {
          this.element.innerHTML = `⏳ ${this.label} (${this.current}/${this.total}) - ${percent}%`;
        }
      }

      complete(message) {
        if (this.element) {
          this.element.innerHTML = `✅ ${message || `${this.label} complete`}`;
        }
      }
    }

    async function fetchAdjacency(token, context) {
      if (currentAbortController?.signal.aborted) {
        throw new Error('AbortError');
      }

      const cached = getFromCache(token);
      if (cached) {
        return { ...cached, cache_hit: true };
      }

      if (!state.apiKey) return { token, relationships: {}, offline: true };

      const prompt = `Token: "${token}"
Context: "${context}"

For this token, identify the most relevant adjacent tokens across relationship types. For each that applies, provide related tokens with weights 0.01-1.00.

Relationship types: ≡ Identity, ⊃ Contains, ⊂ Is Contained By, ≈ Variant, ∈ Is Instance Of, ∋ Has Instance, ⊤ Is Type Of, ⊥ Has Type, ⊏ Part Of, ⊐ Composes, ↔ Mirrors, ⇌ Inverts, ∥ Parallel To, ∼ Adjacent To, → Next, ⇒ Sequence Of, ⇐ Preceded By, ↠ Follows, ↗ Spatially Above, ↘ Spatially Below, ⇝ Symbolically Supports, ⇂ Symbolically Depends, ≠ Contrasts, ⊕ Complements, ⊛ Associated With, ∝ Correlates With, ⇝ Causes, ⇐ Caused By, ∗ Evokes, ≜ Represents, ⋆ Symbolizes, 7→ Refers To, ⊢ Defines, ⊣ Is Defined By, ↷ Transforms To, ↶ Transformed From, ◦ Functions As, |= Interpreted As, ◁ Used With, ⇄ Co-occurs With, ⊗ Synthesizes, ÷ Divides Into, ⊘ Opposes, × Rejects, ¬ Negates, † Destroys, ⊠ Blocks, /∈ Invalidates, ⊬ Contradicts, ⊩ Asserts, ⊨ Provides Evidence, ? Uncertainty, ⚡ Memory, ⇒ Attention, ↶ Self-Reference, ∧ Perspective, ↭ Continuity, ▷◁ Relationality

Return JSON: {"token": "${token}", "relationships": {"≡": [{"token": "...", "weight": 0.95}], ...}}`;

      let safePrompt;
      try {
        safePrompt = validatePrompt(prompt);
      } catch (err) {
        logError(`Prompt validation failed for ${token}: ${err.message}`);
        return { token, relationships: {}, error: 'invalid_prompt' };
      }

      const content = await safeAsync(
        () => callOpenAI([
          { role: 'system', content: 'You are an HLSF token adjacency analyzer.' },
          { role: 'user', content: safePrompt },
        ]),
        `Adjacency fetch failed for ${token}`
      );

      if (!content) {
        return { token, relationships: {}, error: 'request_failed' };
      }

      try {
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const parsed = JSON.parse(content.slice(jsonStart, jsonEnd + 1));
        saveToCache(token, parsed);
        return { ...parsed, cache_hit: false };
      } catch {
        return { token, relationships: {}, error: 'Parse failed' };
      }
    }

    async function batchFetchAdjacencies(tokens, context, label) {
      const results = new Map();
      const unique = [...new Set(tokens)];

      const progress = new ProgressTracker(unique.length, label);

      let processed = 0;
      for (let i = 0; i < unique.length; i += CONFIG.MAX_CONCURRENCY) {
        if (currentAbortController?.signal.aborted) {
          progress.complete(`${label} cancelled (${processed}/${unique.length})`);
          break;
        }

        const batch = unique.slice(i, i + CONFIG.MAX_CONCURRENCY);
        const settled = await Promise.allSettled(batch.map(t => fetchAdjacency(t, context)));
        
        settled.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            results.set(batch[idx], result.value);
          }
        });

        processed += batch.length;
        progress.increment(batch.length);
      }

      const hits = Array.from(results.values()).filter(r => r.cache_hit).length;
      progress.complete(`${label}: ${hits} cached, ${results.size - hits} new`);
      return results;
    }

    window.CognitionEngine.processing = {
      fetchAdjacency,
      batchFetchAdjacencies,
    };

    function calculateAttention(matrices) {
      for (const entry of matrices.values()) {
        let weightSum = 0, totalEdges = 0;
        const rels = entry?.relationships || {};
        
        for (const [rel, edges] of Object.entries(rels)) {
          const priority = RELATIONSHIP_PRIORITIES.get(rel) || 0.3;
          if (Array.isArray(edges)) {
            edges.forEach(edge => {
              weightSum += (edge.weight || 0) * priority;
              totalEdges++;
            });
          }
        }
        
        entry.attention_score = totalEdges > 0 ? Number((weightSum / totalEdges).toFixed(3)) : 0;
        entry.total_relationships = totalEdges;
      }
      return matrices;
    }

    function summarizeAttention(matrices) {
      const summary = [];
      for (const [token, data] of matrices.entries()) {
        summary.push({ 
          token, 
          attention: data.attention_score || 0, 
          total: data.total_relationships || 0 
        });
      }
      return summary.sort((a, b) => b.attention - a.attention).slice(0, 10);
    }

    function formatTopTokens(topTokens) {
      const { ledger } = generateGlyphLedger();
      return topTokens.map(t => {
        const glyphEntry = ledger.get(t.token);
        const glyph = glyphEntry ? glyphEntry.glyph : '◌';
        return `<span class="token-highlight">${glyph} ${t.token}</span> (${t.attention.toFixed(2)})`;
      }).join(', ');
    }

    function extractKeyRelationships(matrices) {
      const relationships = [];
      let count = 0;
      for (const [token, data] of matrices.entries()) {
        if (count >= 5) break;
        const rels = data?.relationships || {};
        for (const [rel, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges) || edges.length === 0) continue;
          const topEdge = edges.sort((a, b) => b.weight - a.weight)[0];
          relationships.push(`${token} ${rel} ${topEdge.token} (${topEdge.weight.toFixed(2)})`);
          count++;
          if (count >= 5) break;
        }
      }
      return relationships;
    }

    // ============================================
    // HLSF VISUALIZATION
    // ============================================

    function polygonVertices(center, radius, sides) {
      const vertices = [];
      const angleStep = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep - Math.PI / 2;
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return vertices;
    }

    function deriveAdjacencyPolygon(center, baseRadius, relationships) {
      const entries = Object.entries(relationships || {})
        .filter(([, edges]) => Array.isArray(edges) && edges.length > 0)
        .map(([relType, edges]) => {
          const weightSum = edges.reduce((sum, edge) => {
            const weight = typeof edge.weight === 'number' ? edge.weight : 0;
            return sum + weight;
          }, 0);
          const avgWeight = edges.length > 0 ? weightSum / edges.length : 0;
          return {
            relType,
            count: edges.length,
            avgWeight
          };
        })
        .sort((a, b) => a.relType.localeCompare(b.relType));

      if (entries.length === 0) {
        return {
          vertices: polygonVertices(center, baseRadius * 0.8, 3),
          anchorIndex: 0,
          adjacencyTypes: 0
        };
      }

      const vertexCount = Math.max(entries.length + 1, 3);
      const baseAngle = -Math.PI / 2;
      const angleStep = (2 * Math.PI) / vertexCount;
      const maxCount = Math.max(...entries.map(entry => entry.count));

      const vertices = [];
      const anchor = [center[0], center[1] - baseRadius];
      vertices.push(anchor);

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const normalizedWeight = Math.min(1, Math.max(0, entry.avgWeight));
        const countFactor = maxCount > 0 ? entry.count / maxCount : 0;
        const radialFactor = 0.85 + normalizedWeight * 0.35 + countFactor * 0.25;
        const radius = baseRadius * radialFactor;
        const angle = baseAngle + angleStep * (i + 1);
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }

      let fillerIndex = entries.length;
      while (vertices.length < 3) {
        const angle = baseAngle + angleStep * (fillerIndex + 1);
        vertices.push([
          center[0] + baseRadius * 0.75 * Math.cos(angle),
          center[1] + baseRadius * 0.75 * Math.sin(angle)
        ]);
        fillerIndex++;
      }

      return {
        vertices,
        anchorIndex: 0,
        adjacencyTypes: entries.length
      };
    }

    function buildBaseTriangles(vertices, sides) {
      if (sides < 3) return [];
      const triangles = [];
      const center = vertices.reduce((acc, v) =>
        [acc[0] + v[0] / sides, acc[1] + v[1] / sides], [0, 0]);

      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        triangles.push([center, vertices[i], vertices[next]]);
      }
      return triangles;
    }

    function rotateTrianglesAround(triangles, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return triangles.map(tri => tri.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      }));
    }

    function rotatePointsAround(points, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      });
    }

    function scalePointsAround(points, center, scale) {
      if (!Array.isArray(points)) return [];
      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * scale,
          center[1] + dy * scale
        ];
      });
    }

    function scaleTrianglesAround(triangles, center, scale) {
      if (!Array.isArray(triangles)) return [];
      return triangles.map(tri => scalePointsAround(tri, center, scale));
    }

    window.HLSF.geometry = {
      polygonVertices,
      buildBaseTriangles,
      rotateTrianglesAround,
      rotatePointsAround,
      scalePointsAround,
      scaleTrianglesAround,
      deriveAdjacencyPolygon,
    };

    let hlsfNodes = [];

    function buildHLSFNodes() {
      const graph = window.HLSF_GRAPH;
      let tokenRecords = [];

      if (graph?.tokens instanceof Map) {
        tokenRecords = Array.from(graph.tokens.values());
      } else if (graph?.tokens && typeof graph.tokens === 'object') {
        tokenRecords = Object.values(graph.tokens);
      }

      let sourceLabel = '';

      if (tokenRecords.length === 0) {
        const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
        console.log(`Scanning ${keys.length} cached tokens from storage for HLSF build`);

        for (const key of keys) {
          try {
            const tokenData = safeStorageGet(key);
            if (!tokenData?.token) {
              console.warn('Token missing from data:', key);
              continue;
            }
            tokenRecords.push(tokenData);
          } catch (err) {
            console.error('Failed to process token:', key, err);
          }
        }

        if (graph) {
          graph.tokens = new Map(tokenRecords.map(record => [record.token, record]));
        }

        sourceLabel = '(storage scan)';
      } else {
        sourceLabel = '(graph cache)';
      }

      console.log(`Building HLSF nodes from ${tokenRecords.length} cached tokens ${sourceLabel}`.trim());

      const nodes = [];

      for (const tokenData of tokenRecords) {
        try {
          const token = tokenData.token;

          if (!token) {
            console.warn('Token missing from data:', tokenData);
            continue;
          }

          const rels = tokenData.relationships || {};

          // Count adjacencies
          let adjacencyCount = 0;
          for (const edges of Object.values(rels)) {
            if (Array.isArray(edges)) adjacencyCount += edges.length;
          }
          const adjacencyTypes = Object.values(rels)
            .filter(edges => Array.isArray(edges) && edges.length > 0)
            .length;

          const attention = typeof tokenData.attention_score === 'number'
            ? tokenData.attention_score
            : 0.5;
          const complex = memoizedComplexNumber(token, { ...tokenData, attention_score: attention });
          const glyph = complexToGlyph(complex);

          // Position based on complex number
          const x = complex.real * 2;
          const y = complex.imaginary * 2;

          // Radius based on attention
          const radius = 0.3 + attention * 0.4;

          // Build polygon derived from adjacency structure
          const shape = deriveAdjacencyPolygon([x, y], radius, rels);
          const sides = shape.vertices.length;

          // Color based on attention
          let color;
          if (attention >= 0.8) color = [0, 255, 136];
          else if (attention >= 0.5) color = [255, 213, 79];
          else color = [255, 119, 119];

          nodes.push({
            token,
            glyph,
            center: [x, y],
            radius,
            sides,
            attention,
            adjacencyCount,
            adjacencyTypes,
            anchorIndex: shape.anchorIndex,
            color,
            vertices: shape.vertices,
            triangles: null // Will be computed
          });
        } catch (err) {
          console.error('Failed to process token for HLSF:', tokenData, err);
        }
      }

      console.log(`Built ${nodes.length} HLSF nodes`);
      
      // Generate triangles for each node
      for (const node of nodes) {
        try {
          node.triangles = buildBaseTriangles(node.vertices, node.sides);
        } catch (err) {
          console.error(`Failed to build triangles for ${node.token}:`, err);
          node.triangles = [];
        }
      }
      
      return nodes;
    }

    function initHLSFCanvas() {
      console.log('Initializing HLSF Canvas...');
      
      try {
        // Build nodes first to check if we have data
        hlsfNodes = buildHLSFNodes();
        
        if (hlsfNodes.length === 0) {
          logWarning('No cached tokens found for HLSF. Process some queries first to populate the database.');
          return;
        }
        
        console.log(`Creating canvas UI for ${hlsfNodes.length} nodes`);
        
        const container = document.createElement('div');
        container.className = 'hlsf-canvas-container';
      container.innerHTML = `
        <div style="margin-bottom: 1rem;">
          <div class="section-title">🌌 HLSF: Hierarchical-Level Semantic Framework</div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">
            Geometric token visualization. Each polygon fans outward from a primary corner based on
            adjacency types, forming unique base-level shapes per matrix. Triangular subdivisions show
            hierarchical structure.
          </div>
        </div>
        <canvas id="hlsf-canvas" width="1200" height="600"></canvas>
        <div class="hlsf-controls">
          <div class="hlsf-control-group">
            <label>Rotation Speed</label>
            <input type="range" id="hlsf-rotation-speed" min="0" max="5" step="0.01" value="0.30">
            <span id="hlsf-speed-val">0.30</span>
          </div>

          <div class="hlsf-control-group">
            <label>Alpha Transparency</label>
            <input type="range" id="hlsf-alpha" min="0.01" max="0.99" step="0.01" value="0.10">
            <span id="hlsf-alpha-val">0.10</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>View Controls</label>
            <div class="hlsf-button-row">
              <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
              <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom −</button>
              <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Rotation Modes</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-rotation" class="btn btn-primary">Start Global</button>
              <button id="hlsf-toggle-emergent" class="btn btn-success">Start Emergent</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Display Options</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-edges" class="btn btn-neutral">Edges: On</button>
              <button id="hlsf-toggle-labels" class="btn btn-neutral">Labels: On</button>
              <button id="hlsf-toggle-bg" class="btn btn-neutral">BG: Dark</button>
            </div>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.85rem;">
          <strong>Controls:</strong> Drag to pan • Scroll to zoom • Each polygon = token matrix •
          Fan vertices = adjacency types • Color = attention score<br>
          <strong>Modes:</strong> Global rotation = all polygons rotate around center • 
          Emergent rotation = each polygon rotates around its own center
        </div>
      `;
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
      entry.appendChild(container);
      elements.log.appendChild(entry);
      elements.log.scrollTop = elements.log.scrollHeight;
      
      // Initialize canvas
      window.HLSF.canvas = document.getElementById('hlsf-canvas');
      window.HLSF.ctx = window.HLSF.canvas.getContext('2d');
      
      console.log('Canvas initialized:', window.HLSF.canvas ? 'success' : 'failed');
      
      // Setup controls
      const speedSlider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (speedSlider && speedVal) {
        const omega = Number.isFinite(window.HLSF.config.rotationOmega)
          ? window.HLSF.config.rotationOmega
          : 0;
        speedSlider.value = omega.toFixed(2);
        speedVal.textContent = omega.toFixed(2);
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        const alpha = baseAlpha();
        alphaSlider.value = alpha.toFixed(2);
        alphaVal.textContent = alpha.toFixed(2);
        window.HLSF.config.alpha = alpha;
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }
      
      document.getElementById('hlsf-zoom-in').addEventListener('click', () => {
        window.HLSF.config.scale *= 1.2;
        debouncedLegacyRender();
      });

      document.getElementById('hlsf-zoom-out').addEventListener('click', () => {
        window.HLSF.config.scale *= 0.8;
        debouncedLegacyRender();
      });

      document.getElementById('hlsf-reset-view').addEventListener('click', () => {
        window.HLSF.config.scale = 1;
        window.HLSF.config.tx = window.HLSF.canvas.width / 2;
        window.HLSF.config.ty = window.HLSF.canvas.height / 2;
        debouncedLegacyRender();
      });
      
      const rotationBtn = document.getElementById('hlsf-toggle-rotation');
      rotationBtn.addEventListener('click', () => {
        window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
        window.HLSF.config.emergentActive = false;
        rotationBtn.textContent = window.HLSF.config.rotationActive ? 'Stop Global' : 'Start Global';
        document.getElementById('hlsf-toggle-emergent').textContent = 'Start Emergent';
      });
      
      const emergentBtn = document.getElementById('hlsf-toggle-emergent');
      emergentBtn.addEventListener('click', () => {
        window.HLSF.config.emergentActive = !window.HLSF.config.emergentActive;
        window.HLSF.config.rotationActive = false;
        emergentBtn.textContent = window.HLSF.config.emergentActive ? 'Stop Emergent' : 'Start Emergent';
        document.getElementById('hlsf-toggle-rotation').textContent = 'Start Global';
      });
      
      const edgesBtn = document.getElementById('hlsf-toggle-edges');
      edgesBtn.addEventListener('click', () => {
        window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
        edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
        debouncedLegacyRender();
      });

      const labelsBtn = document.getElementById('hlsf-toggle-labels');
      labelsBtn.addEventListener('click', () => {
        window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
        labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
        debouncedLegacyRender();
      });

      const bgBtn = document.getElementById('hlsf-toggle-bg');
      bgBtn.addEventListener('click', () => {
        window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
        bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
        debouncedLegacyRender();
      });
      
      // Mouse interaction
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      
      window.HLSF.canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      window.HLSF.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.config.tx += dx;
          window.HLSF.config.ty += dy;
          lastX = e.clientX;
          lastY = e.clientY;
          debouncedLegacyRender();
        }
      });
      
      window.HLSF.canvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        window.HLSF.config.scale *= factor;
        debouncedLegacyRender();
      }, { passive: false });
      
      // Center view
      window.HLSF.config.tx = window.HLSF.canvas.width / 2;
      window.HLSF.config.ty = window.HLSF.canvas.height / 2;
      
      // Build nodes
      window.HLSF.nodes = hlsfNodes;
      
      // Initial render
      renderLegacyHLSF();

      // Start animation
      animateLegacyHLSF();
      
      logSuccess(`HLSF visualization initialized with ${hlsfNodes.length} token matrices`);
      
      } catch (err) {
        logError(`Failed to initialize HLSF canvas: ${err.message}`);
        console.error('HLSF canvas error:', err);
        throw err;
      }
    }

    function strokePolygon(ctx, verts) {
      if (!verts || verts.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(verts[0][0], verts[0][1]);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i][0], verts[i][1]);
      ctx.closePath();
      ctx.stroke();
    }

    function strokeTriangles(ctx, tris) {
      if (!tris) return;
      for (const t of tris) strokePolygon(ctx, t);
    }

    function worldToScreen(x, y) {
      const sx = x * (200 * window.HLSF.config.scale) + window.HLSF.config.tx;
      const sy = -y * (200 * window.HLSF.config.scale) + window.HLSF.config.ty;
      return [sx, sy];
    }

    function renderLegacyHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not initialized for renderHLSF');
        return;
      }

      try {
        const ctx = window.HLSF.ctx;
        const width = window.HLSF.canvas.width;
        const height = window.HLSF.canvas.height;
        const theme = window.HLSF.config.whiteBg
          ? { bg: '#ffffff', fg: '#000000', grid: 'rgba(0, 0, 0, 0.05)' }
          : { bg: '#0a0a0a', fg: '#ffffff', grid: 'rgba(0, 255, 136, 0.05)' };
        const nodeScale = clampNodeSize(window.HLSF.config.nodeSize);
        const edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
        const edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
        const effectiveEdgeWidth = edgeWidth * Math.max(0.6, window.HLSF.config.scale || 1);

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = theme.bg;
        ctx.strokeStyle = theme.fg;
        ctx.lineWidth = 1;

        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = theme.grid;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        ctx.strokeStyle = theme.fg;
        if (window.HLSF.config.fillFaces === true) {
          /* intentionally unused now */
        }

        for (const node of window.HLSF.nodes) {
          let triangles = Array.isArray(node.triangles) ? node.triangles : [];
          let vertices = Array.isArray(node.vertices) ? node.vertices : [];
          let centerPoint = Array.isArray(node.center) ? node.center : [0, 0];
          const nodeColor = Array.isArray(node.color) ? node.color : [0, 255, 136];
          const [r, g, b] = nodeColor;

          if (window.HLSF.config.emergentActive) {
            const angle = window.HLSF.state?.emergentRot ?? 0;
            triangles = rotateTrianglesAround(triangles, node.center, angle);
            vertices = rotatePointsAround(vertices, node.center, angle);
          } else if (window.HLSF.config.rotationActive) {
            const angle = window.HLSF.state?.globalRot ?? 0;
            triangles = rotateTrianglesAround(triangles, [0, 0], angle);
            vertices = rotatePointsAround(vertices, [0, 0], angle);
            centerPoint = rotatePointsAround([node.center], [0, 0], angle)[0];
          }

          const scalePivot = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
            ? centerPoint
            : node.center;
          if (Math.abs(nodeScale - 1) > 1e-3) {
            triangles = scaleTrianglesAround(triangles, scalePivot, nodeScale);
            vertices = scalePointsAround(vertices, scalePivot, nodeScale);
          }

          triangles = Array.isArray(triangles) ? triangles : [];
          vertices = Array.isArray(vertices) ? vertices : [];

          const screenTriangles = triangles.map(tri => tri.map(([x, y]) => worldToScreen(x, y)));
          const screenVertices = vertices.map(([x, y]) => worldToScreen(x, y));

          ctx.globalAlpha = baseAlpha();
          ctx.strokeStyle = theme.fg;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.save();
          if (window.HLSF.config.showNodeGlow) {
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.35)`;
            ctx.shadowBlur = 16 * Math.max(1, window.HLSF.config.scale || 1);
          }

          strokePolygon(ctx, screenVertices);
          strokeTriangles(ctx, screenTriangles);
          ctx.restore();

          if (window.HLSF.config.showEdges && screenVertices.length > 1) {
            const anchorIndex = typeof node.anchorIndex === 'number' ? node.anchorIndex : 0;
            const anchor = screenVertices[anchorIndex];
            for (let i = 0; i < screenVertices.length; i++) {
              if (i === anchorIndex) continue;
              const [vx, vy] = screenVertices[i];
              const strokeColor = nodeEdgeStrokeColor(node, i, edgeColorMode) || theme.fg;
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = effectiveEdgeWidth;
              ctx.beginPath();
              ctx.moveTo(anchor[0], anchor[1]);
              ctx.lineTo(vx, vy);
              ctx.stroke();
            }
            ctx.strokeStyle = theme.fg;
          }

          ctx.globalAlpha = 1.0;

          if (window.HLSF.config.showLabels) {
            const centerForLabel = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
              ? centerPoint
              : node.center;
            const [sx, sy] = worldToScreen(centerForLabel[0], centerForLabel[1]);
            ctx.save();
            if (window.HLSF.config.showNodeGlow) {
              ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
              ctx.shadowBlur = 18 * Math.max(1, window.HLSF.config.scale || 1);
            }
            ctx.globalAlpha = baseAlpha();
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
            ctx.font = `${Math.max(12, 20 * window.HLSF.config.scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.glyph, sx, sy);
            ctx.restore();

            ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${Math.max(9, 11 * window.HLSF.config.scale)}px Fira Code, monospace`;
            ctx.fillText(node.token, sx, sy + 25 * window.HLSF.config.scale);
            ctx.globalAlpha = 1.0;
          }
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
        ctx.font = '12px Fira Code, monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Nodes: ${window.HLSF.nodes.length} | Zoom: ${window.HLSF.config.scale.toFixed(2)}x`, 10, 20);

      } catch (err) {
        console.error('Error rendering HLSF:', err);
      }
    }

    const debouncedLegacyRender = debounce(() => {
      if (window.HLSF?.currentGraph) {
        drawComposite(window.HLSF.currentGraph, { glyphOnly: window.HLSF.currentGlyphOnly === true });
      } else {
        renderLegacyHLSF();
      }
    }, 16);

    let _legacyLast = null;
    function animateLegacyHLSF(now) {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not ready for animation');
        return;
      }

      try {
        const timestamp = typeof now === 'number' ? now : performance.now();
        const last = _legacyLast ?? timestamp;
        const dt = (timestamp - last) / 1000;
        _legacyLast = timestamp;
        stepRotation(dt);

        if (window.HLSF.config.rotationActive || window.HLSF.config.emergentActive) {
          renderLegacyHLSF();
        }
      } catch (err) {
        console.error('Error in HLSF animation:', err);
      }

      window.HLSF.animationFrame = requestAnimationFrame(animateLegacyHLSF);
    }

    function stopLegacyHLSFAnimation() {
      try {
        if (window.HLSF && window.HLSF.animationFrame) {
          cancelAnimationFrame(window.HLSF.animationFrame);
          window.HLSF.animationFrame = null;
        }
        if (window.HLSF && window.HLSF.config) {
          window.HLSF.config.rotationActive = false;
          window.HLSF.config.emergentActive = false;
        }
        _legacyLast = null;
      } catch (err) {
        console.warn('Error stopping HLSF animation:', err);
      }
    }

    window.HLSF.rendering = {
      render: renderLegacyHLSF,
      animate: animateLegacyHLSF,
      stop: stopLegacyHLSFAnimation,
    };
    function computeRelHistogramEntries(db) {
      const hist = new Map();
      for (const rec of db.full_token_data || []) {
        const rels = rec?.relationships || {};
        for (const key of Object.keys(rels)) {
          const glyph = normalizeRelKeyForStats(key);
          if (!glyph) continue;
          const edges = Array.isArray(rels[key]) ? rels[key] : [];
          if (!edges.length) continue;
          hist.set(glyph, (hist.get(glyph) || 0) + edges.length);
        }
      }
      return [...hist.entries()].sort((a, b) => b[1] - a[1]);
    }

    function computeRelHistogram(db, entries){
      const base = Array.isArray(entries) ? entries : computeRelHistogramEntries(db);
      return base.map(([glyph, count]) => renderRelTypeRow(glyph, count));
    }

    function analyzeDatabaseMetadata() {
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      const tokens = [];
      const tokenFrequency = new Map();
      let totalAttentionScore = 0;
      let oldestToken = null;
      let newestToken = null;

      for (const key of keys) {
        try {
          const data = safeStorageGet(key);
          tokens.push(data);

          // Track oldest and newest
          if (data.cached_at) {
            const timestamp = new Date(data.cached_at);
            if (!oldestToken || timestamp < new Date(oldestToken.cached_at)) {
              oldestToken = data;
            }
            if (!newestToken || timestamp > new Date(newestToken.cached_at)) {
              newestToken = data;
            }
          }

          // Count relationships
          const rels = data.relationships || {};
          for (const [relType, edges] of Object.entries(rels)) {
            if (!Array.isArray(edges)) continue;
            const glyph = normalizeRelKeyForStats(relType);
            if (!glyph) continue;

            // Track token frequency across relationships
            for (const edge of edges) {
              const token = edge.token?.toLowerCase();
              if (token) {
                tokenFrequency.set(token, (tokenFrequency.get(token) || 0) + 1);
              }
            }
          }

          if (data.attention_score) {
            totalAttentionScore += data.attention_score;
          }
        } catch (err) {
          console.error('Failed to parse token:', key, err);
        }
      }

      const relHistogramEntries = computeRelHistogramEntries({ full_token_data: tokens });
      const relHistogramRows = computeRelHistogram(null, relHistogramEntries);
      const totalRelationships = relHistogramEntries.reduce((sum, [, count]) => sum + count, 0);
      const topRelationships = relHistogramEntries.slice(0, 10);
      const topRelationshipRows = relHistogramRows.slice(0, 10);

      const topTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);

      const highAttentionTokens = tokens
        .filter(t => t.attention_score)
        .sort((a, b) => b.attention_score - a.attention_score)
        .slice(0, 10);

      return {
        totalTokens: tokens.length,
        totalRelationships,
        avgAttentionScore: tokens.length > 0 ? (totalAttentionScore / tokens.length).toFixed(3) : 0,
        topRelationships,
        topRelationshipRows,
        relHistogramRows,
        topTokens,
        highAttentionTokens,
        oldestToken,
        newestToken,
        estimatedValue: tokens.length * CONFIG.ESTIMATED_COST_PER_API_CALL,
        rawData: tokens
      };
    }

    function showDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const maturityLevel = metadata.totalTokens > 100 ? 'Mature' : metadata.totalTokens > 20 ? 'Growing' : 'Early';
      const maturityColor = metadata.totalTokens > 100 ? 'var(--success)' : metadata.totalTokens > 20 ? 'var(--warning)' : 'var(--accent)';
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">📊 Collective Database Metadata</div>
        
        <div class="adjacency-insight">
          <strong>🌐 Knowledge Base Status:</strong> <span style="color: ${maturityColor}; font-weight: bold;">${maturityLevel}</span><br>
          <small style="opacity: 0.8;">
            ${metadata.totalTokens < 20 ? 
              'Building foundational knowledge. Each query adds to the collective intelligence.' :
              metadata.totalTokens < 100 ?
              'Database is maturing. Cache hit rate improving with each session.' :
              'Mature knowledge base. Most queries benefit from cached insights.'}
          </small>
        </div>

        <div class="adjacency-insight">
          <strong>💾 Database Size:</strong><br>
          • Total cached tokens: <strong>${metadata.totalTokens}</strong><br>
          • Total relationships: <strong>${metadata.totalRelationships}</strong><br>
          • Average attention score: <strong>${metadata.avgAttentionScore}</strong><br>
          • Network density: <strong>${(metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)}</strong> edges/token<br>
          • Estimated saved cost: <strong>${formatCurrency(Math.ceil(metadata.estimatedValue * 100))}</strong>
        </div>

        <div class="adjacency-insight">
          <strong>📈 Most Common Relationship Types:</strong><br>
          ${metadata.topRelationshipRows.map(row =>
            `• <span class="token-highlight">${row}</span>`
          ).join('<br>')}
          ${metadata.topRelationshipRows.length === 0 ? '<em>No relationships cached yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>🔥 Most Referenced Tokens (Hub Concepts):</strong><br>
          <small style="opacity: 0.8;">These tokens appear most frequently across relationships - they represent core concepts in the knowledge graph.</small><br><br>
          ${metadata.topTokens.slice(0, 10).map(([token, count]) => 
            `• <span class="token-highlight">${token}</span>: ${count} references`
          ).join('<br>')}
          ${metadata.topTokens.length === 0 ? '<em>No hub concepts identified yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>⭐ Highest Attention Tokens:</strong><br>
          <small style="opacity: 0.8;">Tokens with the strongest weighted relationships - highly salient concepts.</small><br><br>
          ${metadata.highAttentionTokens.map(t => 
            `• <span class="token-highlight">${t.token}</span>: ${t.attention_score} (${t.total_relationships || 0} edges)`
          ).join('<br>')}
          ${metadata.highAttentionTokens.length === 0 ? '<em>No high-attention tokens yet</em>' : ''}
        </div>

        ${metadata.oldestToken ? `
        <div class="adjacency-insight">
          <strong>📅 Database Timeline:</strong><br>
          • Oldest entry: <strong>${metadata.oldestToken.token}</strong> (${new Date(metadata.oldestToken.cached_at).toLocaleString()})<br>
          • Newest entry: <strong>${metadata.newestToken.token}</strong> (${new Date(metadata.newestToken.cached_at).toLocaleString()})
        </div>
        ` : ''}

        <details>
          <summary>📊 View knowledge graph analytics</summary>
          <pre>${JSON.stringify({
            database_maturity: maturityLevel,
            network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
            top_5_relationship_types: metadata.topRelationships.slice(0, 5).map(([rel]) => relDisplay(rel)),
            relationship_histogram_named: metadata.relHistogramRows,
            top_5_hub_concepts: metadata.topTokens.slice(0, 5).map(([token]) => token),
            growth_metrics: {
              tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
              avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)
            }
          }, null, 2)}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          💡 <strong>Insight:</strong> This metadata represents the collective intelligence being built. 
          In a server deployment, this would be shared across all users, with each query contributing 
          to a growing knowledge base that makes future queries faster and cheaper. The database also 
          powers the symbolic glyph encryption system for secure inter-system communication.
        </div>
      `);
    }

    function exportDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        readme: {
          description: "HLSF Cognition Engine - Collective Database Metadata Export",
          purpose: "This export contains the complete adjacency token database and analytics. It represents the collective intelligence built through token relationship analysis.",
          usage: "This data can be imported into a server-side database to bootstrap a new deployment or shared for analysis.",
          version: "2.0"
        },
        database_stats: {
          total_tokens: metadata.totalTokens,
          total_relationships: metadata.totalRelationships,
          avg_attention_score: metadata.avgAttentionScore,
          estimated_value_usd: metadata.estimatedValue.toFixed(2),
          maturity_level: metadata.totalTokens > 100 ? 'mature' : metadata.totalTokens > 20 ? 'growing' : 'early'
        },
        relationship_distribution: Object.fromEntries(metadata.topRelationships),
        relationship_distribution_named: Object.fromEntries(metadata.topRelationships.map(([glyph, count]) => [relDisplay(glyph), count])),
        hub_concepts: Object.fromEntries(metadata.topTokens),
        high_attention_tokens: metadata.highAttentionTokens.map(t => ({
          token: t.token,
          attention_score: t.attention_score,
          total_relationships: t.total_relationships
        })),
        knowledge_graph_metrics: {
          network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(3),
          avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
          tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
          oldest_entry: metadata.oldestToken?.cached_at,
          newest_entry: metadata.newestToken?.cached_at,
          date_range_days: metadata.oldestToken && metadata.newestToken ? 
            Math.ceil((new Date(metadata.newestToken.cached_at) - new Date(metadata.oldestToken.cached_at)) / (1000 * 60 * 60 * 24)) : 0
        },
        full_token_data: metadata.rawData
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      logSuccess(`Database metadata exported: ${metadata.totalTokens} tokens, ${metadata.totalRelationships} relationships, ${(new Blob([JSON.stringify(exportData)]).size / 1024).toFixed(1)}KB`);
    }

    async function importHLSFDBFromFile(file) {
      const txt = await file.text();
      const count = loadDbObject(txt);
      const db = getDb();
      if (!db) return;
      const seen = [];
      for (const rec of db.full_token_data || []) {
        safeStorageSet(TOKEN_CACHE_PREFIX + rec.token, JSON.stringify(rec));
        seen.push(rec.token);
      }
      safeStorageSet(DB_INDEX_KEY, JSON.stringify(seen));
      state.hlsfReady = false;
      window.HLSF_GRAPH = null;
      updateStats();
      addLog(`📊 Import: ${seen.length} tokens (${count} normalized).`);
      updateHeaderCounts();
    }

    function importDatabaseData(data, source = 'file') {
      try {
        const normalizedCount = loadDbObject(data);
        const db = getDb();
        if (!db) throw new Error('Failed to hydrate database');

        state.hlsfReady = false;
        let totalTokens = 0;
        try {
          totalTokens = loadDbObject(data);
        } catch (err) {
          console.warn('Failed to persist raw DB snapshot:', err);
        }

        const tokenData = data.full_token_data;
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        const seen = new Set();

        for (const token of tokenData) {
          if (!token?.token) continue;

          const key = getCacheKey(token.token);
          const existing = safeStorageGet(key);
          seen.add(token.token);

          if (existing) {
            const existingData = typeof existing === 'string' ? JSON.parse(existing) : existing;
            const importedDate = new Date(token.cached_at || 0);
            const existingDate = new Date(existingData?.cached_at || 0);

            if (importedDate > existingDate) {
              safeStorageSet(key, JSON.stringify(token));
              updated++;
            } else {
              skipped++;
            }
          } else {
            safeStorageSet(key, JSON.stringify(token));
            imported++;
          }
        }

        if (!totalTokens) {
          safeStorageSet(DB_INDEX_KEY, JSON.stringify(Array.from(seen)));
        }
        updateStats();

        const summary = [];
        if (imported > 0) summary.push(`${imported} new tokens imported`);
        if (updated > 0) summary.push(`${updated} tokens updated`);
        if (skipped > 0) summary.push(`${skipped} existing tokens kept`);
        if (!summary.length) summary.push('no cache changes');

        logSuccess(`Database imported from ${source}: ${summary.join(', ')}, normalized ${normalizedCount} tokens`);

        if (data?.database_stats) {
          addLog(`<div class="adjacency-insight">
            📊 <strong>Import Summary:</strong><br>
            • Source maturity: ${data.database_stats.maturity_level}<br>
            • Total tokens in source: ${data.database_stats.total_tokens}<br>
            • Total relationships: ${data.database_stats.total_relationships}<br>
            • Estimated value: ${data.database_stats.estimated_value_usd}
          </div>`);
        }

        return { imported, skipped, updated, seen: Array.from(seen), normalizedCount };
      } catch (err) {
        logError(`Import failed: ${err.message || err}`);
        return null;
      }
    }

    // ============================================
    // COMMANDS
    // ============================================
    const COMMANDS = window.COMMANDS = window.COMMANDS || Object.create(null);

    function registerCommand(name, handler) {
      if (!name || typeof handler !== 'function') return;
      const key = name.startsWith('/') ? name.toLowerCase() : `/${name.toLowerCase()}`;
      COMMANDS[key] = handler;
    }

    async function tryBootstrapDb() {
      if (getDb()) return true;

      let href = null;
      try {
        const url = new URL(location.href);
        href = url.searchParams.get('db') || window.HLSF.config.bootstrapDbUrl;
      } catch (err) {
        console.warn('Failed to parse bootstrap URL:', err);
      }

      if (!href) return false;

      try {
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
        return true;
      } catch (e) {
        logStatus(`Bootstrap DB fetch failed: ${String(e.message || e)}`);
        return false;
      }
    }

    function dbIndex() {
      const db = getDb();
      const idx = new Map();
      (db?.full_token_data || []).forEach(record => {
        if (record?.token) idx.set(record.token, record);
      });
      return idx;
    }

    function tokenWeight(token, idx) {
      const rec = idx.get(token);
      if (!rec) return 0.5;
      const relationships = Object.values(rec.relationships || {});
      const weights = [];
      for (const arr of relationships) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const w = rel?.weight;
          if (typeof w === 'number' && Number.isFinite(w)) weights.push(w);
        }
      }
      if (!weights.length) return 0.5;
      const maxW = Math.max(...weights);
      const meanW = weights.reduce((sum, value) => sum + value, 0) / weights.length;
      return Math.max(0.01, Math.min(1.0, 0.6 * maxW + 0.4 * meanW));
    }

    function hashGlyphForToken(token) {
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i = 0; i < token.length; i++) {
        h ^= token.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return GLYPH_SET[h % GLYPH_SET.length];
    }

    function glyphForToken(token) {
      if (!TokenToGlyph.has(token)) {
        // Ensure existing ledger mappings are available before hashing
        if (!TokenToGlyph.size) loadLedger();
      }
      return TokenToGlyph.get(token) || hashGlyphForToken(token);
    }

    function ledgerAdd(ledger, glyph, token, weight) {
      if (!ledger.glyph_map[glyph]) ledger.glyph_map[glyph] = [];
      const arr = ledger.glyph_map[glyph];
      const numericWeight = Number(weight);
      const now = Date.now();
      const found = arr.find(entry => entry.token === token);
      if (found) {
        found.w = numericWeight;
        found.t = now;
      } else {
        arr.push({ token, w: numericWeight, t: now });
      }
      TokenToGlyph.set(token, glyph);
      if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
      GlyphToToken.get(glyph).add(token);
      return ledger;
    }

    function ledgerBestToken(ledger, glyph, weight) {
      const arr = Array.isArray(ledger.glyph_map[glyph]) ? ledger.glyph_map[glyph] : [];
      if (!arr.length) return null;
      let best = arr[0];
      let bestDistance = Math.abs((best?.w ?? 0) - weight);
      for (let i = 1; i < arr.length; i++) {
        const candidate = arr[i];
        const distance = Math.abs((candidate?.w ?? 0) - weight);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      }
      return best?.token || null;
    }

    function parseGlyphFloatSequence(input) {
      const tokens = [];
      if (!input) return tokens;
      const segments = input.trim().split(/\s+/);
      for (const segment of segments) {
        if (!segment) continue;
        let cursor = 0;
        while (cursor < segment.length) {
          let glyph = null;
          for (const candidate of GLYPH_SET) {
            if (segment.startsWith(candidate, cursor)) {
              if (!glyph || candidate.length > glyph.length) glyph = candidate;
            }
          }
          if (!glyph) break;
          cursor += glyph.length;
          let nextGlyphIndex = segment.length;
          for (const candidate of GLYPH_SET) {
            const idx = segment.indexOf(candidate, cursor);
            if (idx !== -1 && idx < nextGlyphIndex) nextGlyphIndex = idx;
          }
          const numberPortion = segment.slice(cursor, nextGlyphIndex);
          cursor = nextGlyphIndex;
          let weight = parseFloat(numberPortion);
          if (!Number.isFinite(weight)) weight = 0.5;
          tokens.push({ glyph, weightStr: numberPortion, weight });
        }
      }
      return tokens;
    }

    function encryptTextToGlyphs(plain, options = {}) {
      const { persistUnknown = true } = options || {};
      const idx = dbIndex();
      const ledger = loadLedger();
      const words = (plain || '').trim().split(/\s+/).filter(Boolean);
      const out = [];
      const unknown = [];
      let covered = 0;
      let mutated = false;

      for (const word of words) {
        const glyph = glyphForToken(word);
        const weight = tokenWeight(word, idx);
        if (persistUnknown || idx.has(word)) {
          ledgerAdd(ledger, glyph, word, weight);
          mutated = true;
        }
        out.push(glyph + NUM_FMT(weight));
        if (idx.has(word)) covered++;
        else unknown.push(word);
      }

      if (mutated) saveLedger(ledger);
      const encrypted = out.join(GLYPH_SEP);
      const coverage = words.length ? (100 * covered / words.length).toFixed(1) : '0.0';
      return { encrypted, coverage, unknown };
    }

    function decryptGlyphsToText(cipher) {
      const ledger = loadLedger();
      const pairs = parseGlyphFloatSequence(cipher || '');
      const out = [];
      const unresolved = [];
      let resolved = 0;

      for (const pair of pairs) {
        const token = ledgerBestToken(ledger, pair.glyph, pair.weight);
        if (token) {
          out.push(token);
          resolved++;
        } else {
          out.push('<?>');
          unresolved.push({ glyph: pair.glyph, weight: pair.weight });
        }
      }

      const coverage = pairs.length ? (100 * resolved / pairs.length).toFixed(1) : '0.0';
      return { decrypted: out.join(' '), coverage, unresolved };
    }

    function cmdLedger(arg) {
      const ledger = loadLedger();
      const [sub] = (arg || '').trim().split(/\s+/);
      if (sub === 'export') {
        const blob = new Blob([JSON.stringify(ledger, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `glyph_ledger_${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);
        return logFinal('Ledger exported.');
      }
      if (sub === 'import') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = async e => {
          try {
            const file = e.target.files?.[0];
            if (!file) return;
            const text = await file.text();
            const imported = JSON.parse(text);
            hydrateLedgerMaps(imported);
            saveLedger(imported);
            logFinal('Ledger imported.');
          } catch (err) {
            logError(`Ledger import failed: ${err.message}`);
          }
        };
        input.click();
        return;
      }

      const lines = [];
      const map = ledger.glyph_map || {};
      const glyphs = Object.keys(map).sort();
      for (const glyph of glyphs) {
        const arr = Array.isArray(map[glyph]) ? map[glyph] : [];
        if (!arr.length) continue;
        const latest = [...arr].sort((a, b) => (b?.t ?? 0) - (a?.t ?? 0))[0];
        const weightStr = NUM_FMT(latest?.w ?? 0);
        lines.push(`${glyph} ${weightStr} → ${latest?.token || ''}`.trim());
      }
      return logFinal(lines.length ? lines.join('\n') : 'Ledger empty.');
    }

    function cmdGlyph(argsStr) {
      const idx = dbIndex();
      const tokens = (argsStr || '').trim().split(/\s+/).filter(Boolean);
      if (!tokens.length) {
        logError('Usage: /glyph <token1 token2 ...>');
        return;
      }
      const ledger = loadLedger();
      const outputs = [];
      for (const token of tokens) {
        const glyph = glyphForToken(token);
        const weight = tokenWeight(token, idx);
        ledgerAdd(ledger, glyph, token, weight);
        outputs.push(glyph + NUM_FMT(weight));
      }
      saveLedger(ledger);
      logFinal(outputs.join(GLYPH_SEP));
    }

    function cmdEncrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /encrypt <text>');
        return;
      }
      const { encrypted, coverage } = encryptTextToGlyphs(text, { persistUnknown: true });
      logFinal(`🔐 ${encrypted}\nCoverage: ${coverage}%`);
    }

    function cmdDecrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /decrypt <glyph+float sequence>');
        return;
      }
      const { decrypted, coverage } = decryptGlyphsToText(text);
      logFinal(`🔓 ${decrypted}\nCoverage: ${coverage}%`);
    }


    async function cmdImport() {
      const input = document.getElementById('db-file');
      if (!input) {
        logError('File input unavailable');
        return;
      }
      input.value = '';
      input.onchange = async e => {
        try {
          const f = e.target.files?.[0];
          if (!f) return;
          const text = await f.text();
          const n = loadDbObject(text);
          logFinal(`DB loaded. Tokens: ${n}`);
        } catch (err) {
          logError(String(err.message || err));
        } finally {
          e.target.value = '';
          input.onchange = null;
        }
      };
      input.click();
    }

    async function cmdLoadDb(arg) {
      try {
        const href = (arg || '').trim() || window.HLSF.config.bootstrapDbUrl;
        if (!href) throw new Error('Usage: /loaddb <url-or-path>');
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
      } catch (e) {
        logError(`load failed: ${String(e.message || e)}`);
      }
    }

    async function cmdHlsf(rawArgs) {
      if (!getDb()) {
        const ok = await tryBootstrapDb();
        if (!ok) {
          logError('No DB loaded. Use /loaddb or /import.');
          return;
        }
      }

      const args = parseHlsfArgs(rawArgs);
      const { seeds, idx, glyphOnly } = seedsForMode(args);
      if (!seeds?.length) {
        logError('DB is empty. Use /loaddb or /import.');
        return;
      }
      if (!ensureHLSFCanvas()) {
        logError('Unable to initialize canvas for HLSF rendering.');
        return;
      }
      const depth = Number.isFinite(args.depth) ? args.depth : 3;
      const graph = assembleGraphFromSeeds(seeds, depth, idx);
      window.HLSF.lastCommand = {
        rawArgs,
        args,
        seeds: [...seeds],
        idx,
        glyphOnly: glyphOnly === true,
        depth,
      };
      animateComposite(graph, glyphOnly === true);
      syncHlsfControls(document.getElementById('hlsf-canvas-container'));
      const suffix = rawArgs ? ` ${rawArgs}` : '';
      logFinal(`/hlsf${suffix} → nodes ${graph.nodes.size}, edges ${graph.edges.length}, seeds ${seeds.length}`);
    }

    function rebuildHlsfFromLastCommand(logUpdate = false) {
      const last = window.HLSF?.lastCommand;
      if (!last || !last.idx || !Array.isArray(last.seeds) || !last.seeds.length) return null;
      const depth = Number.isFinite(last.depth) ? last.depth : 3;
      const graph = assembleGraphFromSeeds(last.seeds, depth, last.idx);
      animateComposite(graph, last.glyphOnly === true);
      syncHlsfControls(document.getElementById('hlsf-canvas-container'));
      if (logUpdate) {
        const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
        logStatus(`↻ /hlsf${suffix} → nodes ${graph.nodes.size}, edges ${graph.edges.length}, seeds ${last.seeds.length}`);
      }
      return graph;
    }

    function cmdScheme(arg) {
      const mode = (arg || '').toLowerCase();
      window.HLSF.config.whiteBg = mode === 'white';
      if (window.HLSF.currentGraph) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Scheme: ${window.HLSF.config.whiteBg ? 'Black lines on white' : 'White lines on black'}`);
    }

    function cmdSpin(arg) {
      const value = (arg || '').toLowerCase();
      window.HLSF.config.rotationActive = /^(on|true|1)$/i.test(value) || (!value && true);
      if (window.HLSF.currentGraph && !_anim) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Rotation: ${window.HLSF.config.rotationActive ? 'on' : 'off'}`);
    }

    function cmdOmega(arg) {
      const w = parseFloat(arg);
      if (!Number.isFinite(w)) {
        logError('Usage: /omega <rad/s>');
        return;
      }
      window.HLSF.config.rotationOmega = w;
      const slider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (slider) slider.value = w.toFixed(2);
      if (speedVal) speedVal.textContent = w.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Rotation omega = ${w.toFixed(2)} rad/s`);
    }

    function cmdAlpha(arg) {
      const parsed = parseFloat(arg);
      if (!Number.isFinite(parsed)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      const a = clampAlpha(parsed);
      if (!Number.isFinite(a)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      window.HLSF.config.alpha = a;
      const slider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (slider) slider.value = a.toFixed(2);
      if (alphaVal) alphaVal.textContent = a.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Alpha = ${a.toFixed(2)}`);
    }

    async function cmd_import() {
      await cmdImport();
    }

    async function cmd_loaddb(args) {
      const joined = Array.isArray(args) ? args.join(' ') : args;
      await cmdLoadDb(joined);
    }

    function getRelationshipPriority(relType) {
      if (RELATIONSHIP_PRIORITIES instanceof Map) {
        return RELATIONSHIP_PRIORITIES.get(relType) ?? 1;
      }
      if (typeof RELATIONSHIP_PRIORITIES === 'object' && RELATIONSHIP_PRIORITIES !== null) {
        return RELATIONSHIP_PRIORITIES[relType] ?? 1;
      }
      return 1;
    }

    function* iterTokenRecords() {
      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) yield rec;
        return;
      }
      const idxRaw = safeStorageGet(DB_INDEX_KEY, []);
      const idx = Array.isArray(idxRaw) ? idxRaw : [];
      const keys = idx.length ? idx.map(t => TOKEN_CACHE_PREFIX + t)
                              : safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const k of keys) {
        const rec = safeStorageGet(k);
        if (rec) yield rec;
      }
    }

    function buildHLSF() {
      const pri = RELATIONSHIP_PRIORITIES || {};
      const nodes = [];
      const edges = [];
      let maxAttention = 0;

      for (const rec of iterTokenRecords()) {
        if (!rec || !rec.token || !rec.relationships) continue;
        let attention = 0;

        for (const rawKey of Object.keys(rec.relationships)) {
          const type = normRelKey(rawKey);
          const p = (pri[type] ?? pri.get?.(type)) ?? 1;
          for (const rel of rec.relationships[rawKey]) {
            const w = rel.weight ?? 0;
            attention += w * p;
            edges.push({ source: rec.token, target: rel.token, type, w });
          }
        }
        maxAttention = Math.max(maxAttention, attention);
        nodes.push({ id: rec.token, attention });
      }

      const norm = maxAttention || 1;
      for (const n of nodes) n.attention = +(n.attention / norm).toFixed(3);

      return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
    }

    async function cmd_hlsf() {
      await cmdHlsf('');
    }

    registerCommand('/import', cmd_import);
    registerCommand('/loaddb', cmd_loaddb);
    window.COMMANDS = COMMANDS;
    // Router guard (prevents duplicate logs)
    if (!COMMANDS.__hlsf_bound) {
      COMMANDS['/hlsf'] = cmd_hlsf;
      COMMANDS.__hlsf_bound = true;
    }
    registerCommand('/visualize', cmd_hlsf);

    async function dispatchCommand(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return false;

      const parts = trimmed.split(/\s+/);
      const [raw, ...rest] = parts;
      const command = raw.startsWith('/') ? raw.toLowerCase() : `/${raw.toLowerCase()}`;
      const arg = rest.join(' ').trim();

      if (command === '/import') { await cmdImport(); return true; }
      if (command === '/loaddb') { await cmdLoadDb(arg); return true; }
      if (command === '/hlsf') { await cmdHlsf(arg); return true; }
      if (command === '/scheme') { cmdScheme(arg || 'black'); return true; }
      if (command === '/spin') { cmdSpin(arg || 'on'); return true; }
      if (command === '/omega') { cmdOmega(arg); return true; }
      if (command === '/alpha') { cmdAlpha(arg); return true; }

      return false;
    }

    function isCommand(input) { return input.startsWith('/'); }

    async function handleCommand(cmd) {
      const trimmed = cmd.trim();
      const handled = await safeAsync(() => dispatchCommand(trimmed), `Command dispatch failed for ${trimmed}`);
      if (handled) return;

      const segments = trimmed.slice(1).split(/\s+/);
      const [command, ...args] = segments;

      if (!command) {
        logError('Unknown command');
        return;
      }

      const normalized = `/${command.toLowerCase()}`;
      const mapped = COMMANDS[normalized];
      if (mapped) {
        await mapped(args, trimmed);
        return;
      }

      switch (command.toLowerCase()) {
        case 'clear':
          elements.log.innerHTML = '';
          logSuccess('Log cleared');
          break;
        case 'reset':
          if (confirm('Clear all cached data?')) {
            const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
            keys.forEach(k => safeStorageRemove(k));
            safeStorageRemove(DB_INDEX_KEY);
            state.hlsfReady = false;
            window.HLSF_GRAPH = null;
            if (window.HLSF) {
              window.HLSF.matrices = null;
              window.HLSF.layoutCache = null;
              window.HLSF.dbCache = null;
              window.HLSF.currentGraph = null;
              window.HLSF.currentGlyphOnly = false;
              window.HLSF.__centerInit = false;
            }
            Session.tokens.clear();
            updateStats();
            logSuccess(`Cleared ${keys.length} tokens`);
          }
          break;
        case 'stats':
          const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
          const total = totalApiCalls + totalCacheHits;
          const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) : 0;
          addLog(`<strong>Session Stats:</strong><br>
            • Requests: ${total}<br>
            • Cache hits: ${totalCacheHits} (${hitRate}%)<br>
            • API calls: ${totalApiCalls}<br>
            • Cost: ${formatCurrency(totalCostCents)}<br>
            • Cached tokens: ${getCachedTokenCount()}`);
          break;
        case 'database':
        case 'db':
          showDatabaseMetadata();
          break;
        case 'export':
          exportDatabaseMetadata();
          break;
        case 'glyph':
          cmdGlyph(args.join(' '));
          break;
        case 'ledger':
          cmdLedger(args.join(' '));
          break;
        case 'encrypt':
          cmdEncrypt(args.join(' '));
          break;
        case 'decrypt':
          cmdDecrypt(args.join(' '));
          break;
        case 'exportledger':
          cmdLedger('export');
          break;
        case 'help':
          addLog(`<strong>Commands:</strong><br>
            /clear - Clear log<br>
            /reset - Clear cache<br>
            /stats - Session statistics<br>
            /database or /db - View database metadata<br>
            /export - Export database metadata as JSON<br>
            /import - Import database from JSON file<br>
            /loaddb &lt;url&gt; - Load database JSON from URL<br>
            /glyph &lt;token1 token2 ...&gt; - Show weighted glyph assignments<br>
            /ledger [show|export|import] - Manage private glyph ledger<br>
            /encrypt &lt;text&gt; - Encrypt text into weighted glyphs<br>
            /decrypt &lt;glyph+float&gt; - Decrypt using private ledger<br>
            /exportledger - Shortcut for /ledger export<br>
            /hlsf or /visualize - Visualize database as Hierarchical-Level Semantic Framework<br>
            /help - Show commands`);
          break;
        default:
          logError(`Unknown: ${command}`);
      }
    }

    // ============================================
    // MAIN PROCESSING
    // ============================================
    async function processPrompt(prompt) {
      if (state.isProcessing) return;
      
      state.isProcessing = true;
      currentAbortController = new AbortController();
      elements.sendBtn.disabled = true;
      elements.cancelBtn.style.display = 'inline-block';
      elements.input.disabled = true;

      const startTime = performance.now();

      try {
        const tokens = tokenize(prompt);
        if (tokens.length === 0) {
          logError('Prompt cannot be empty');
          return;
        }
        addConversationTokens(tokens);
        if (tokens.length > CONFIG.MAX_TOKENS_PER_PROMPT) {
          logError(`Exceeds ${CONFIG.MAX_TOKENS_PER_PROMPT} token limit (${tokens.length})`);
          return;
        }

        const estimatedCalls = tokens.length * 2 + 3;
        const estimatedCost = estimatedCalls * CONFIG.ESTIMATED_COST_PER_API_CALL;
        addLog(`<div class="cost-estimate">
          📊 <strong>Estimate:</strong> ${tokens.length} tokens, ~${estimatedCalls} API calls, ~${formatCurrency(Math.ceil(estimatedCost * 100))}
        </div>`);

        // Step 1: Initial response
        let initialResponse = '';
        if (state.apiKey) {
          const s1 = logStatus('⏳ Generating initial response...');
          initialResponse = await callOpenAI([
            { role: 'system', content: 'You are an expert assistant.' },
            { role: 'user', content: prompt },
          ]);
          s1.innerHTML = `✅ Initial response generated`;
        } else {
          initialResponse = '⚠️ Offline mode';
          logWarning('Skipped (offline)');
        }

        // Step 2: Adjacency analysis
        const responseTokens = tokenize(initialResponse);
        addConversationTokens(responseTokens);
        const [inputMatrices, outputMatrices] = await Promise.all([
          batchFetchAdjacencies(tokens, prompt, 'input'),
          batchFetchAdjacencies(responseTokens, initialResponse, 'output'),
        ]);

        calculateAttention(inputMatrices);
        calculateAttention(outputMatrices);

        const allMatrices = new Map([...inputMatrices, ...outputMatrices]);
        const topTokens = summarizeAttention(allMatrices);
        const keyRels = extractKeyRelationships(allMatrices);

        addLog(`<div class="adjacency-insight">
          <strong>🎯 High Attention:</strong> ${formatTopTokens(topTokens)}
        </div>
        <div class="adjacency-insight">
          <strong>🔗 Key Relationships:</strong><br>
          ${keyRels.map(r => `• ${r}`).join('<br>')}
        </div>`);

        // Step 3: Thought stream
        let thoughtStream = '';
        if (state.apiKey) {
          const s2 = logStatus('⏳ Synthesizing thought stream...');
          thoughtStream = await callOpenAI([
            { role: 'system', content: 'You create reflective thought streams from analytical insights.' },
            { role: 'user', content: `Based on these adjacency insights, generate a stream-of-consciousness internal monologue:\n\nTop tokens: ${JSON.stringify(topTokens)}\nRelationships: ${keyRels.join('; ')}\n\nWrite as flowing natural thought connecting these elements.` },
          ]);
          s2.innerHTML = '✅ Thought stream captured';
          
          addLog(`<div class="section-divider"></div>
            <div class="section-title">💭 Emergent Thought Stream</div>
            <div class="thought-stream">${sanitize(thoughtStream)}</div>`);
        }

        // Step 4: Refined response
        let refinedResponse = initialResponse;
        if (state.apiKey) {
          const s3 = logStatus('⏳ Refining response...');
          refinedResponse = await callOpenAI([
            { role: 'system', content: 'You refine responses based on adjacency insights.' },
            { role: 'user', content: `Original: "${initialResponse}"\n\nInsights: ${thoughtStream}\n\nRevise by: 1) Incorporating emergent insights 2) Restructuring based on token relationships 3) Enhancing coherence. Provide revised response only.` },
          ]);
          s3.innerHTML = '✅ Response refined';
        }
        addConversationTokens(tokenize(refinedResponse));

        // Display final output
        const time = ((performance.now() - startTime) / 1000).toFixed(1);
        addLog(`<div class="section-divider"></div>
          <div class="final-output">
            <h3>✨ REFINED RESPONSE</h3>
            <pre>${sanitize(refinedResponse)}</pre>
            
            <details>
              <summary>Compare with original response</summary>
              <pre>${sanitize(initialResponse)}</pre>
            </details>
            
            <details>
              <summary>View adjacency data (${allMatrices.size} tokens)</summary>
              <pre>${JSON.stringify(Array.from(allMatrices.entries()).slice(0, 5), null, 2)}</pre>
            </details>
          </div>
        `);
        
        logSuccess(`Processing complete (${time}s)`);

      } catch (err) {
        if (err.name === 'AbortError' || err.message === 'AbortError') {
          logWarning('Processing cancelled');
        } else {
          logError(err.message || 'Processing failed');
          console.error(err);
        }
      } finally {
        state.isProcessing = false;
        currentAbortController = null;
        elements.sendBtn.disabled = false;
        elements.cancelBtn.style.display = 'none';
        elements.input.disabled = false;
        elements.input.value = '';
        elements.input.focus();
      }
    }

    // ============================================
    // EVENTS
    // ============================================
    function applyApiKeyFromModal() {
      const key = elements.apiKeyInput.value.trim();
      if (!isValidApiKey(key)) {
        logError('Invalid API key format');
        return;
      }
      state.apiKey = key.trim();
      const persisted = safeStorageSet(API_KEY_STORAGE_KEY, state.apiKey);
      elements.apiModal.classList.add('hidden');
      if (!persisted) {
        logWarning('API key configured but not saved to storage');
      }
      logSuccess('API key configured');
    }

    elements.apiConfirmBtn.addEventListener('click', applyApiKeyFromModal);

    elements.apiKeyInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        applyApiKeyFromModal();
      }
    });

    elements.apiCancelBtn.addEventListener('click', () => {
      elements.apiModal.classList.add('hidden');
      logWarning('Offline mode - limited functionality');
    });

    elements.sendBtn.addEventListener('click', () => {
      const input = elements.input.value.trim();
      if (!input) return;
      
      addLog(`> ${sanitize(input)}`);
      
      if (isCommand(input)) {
        handleCommand(input);
        elements.input.value = '';
      } else {
        onUserPromptSubmitted(input);
        processPrompt(input);
      }
    });

    elements.cancelBtn.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
        logWarning('Cancelling...');
      }
    });

    elements.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.sendBtn.click();
      }
    });

    // ============================================
    // INIT
    // ============================================
    window.addEventListener('beforeunload', () => {
      state.apiKey = '';
      stopHLSFAnimation();
    });

    async function initialize() {
      updateStats();

      const storedKey = safeStorageGet(API_KEY_STORAGE_KEY, '');
      if (isValidApiKey(storedKey)) {
        state.apiKey = storedKey.trim();
        elements.apiKeyInput.value = state.apiKey;
        elements.apiModal.classList.add('hidden');
        logSuccess('Loaded stored API key');
      } else if (storedKey) {
        safeStorageRemove(API_KEY_STORAGE_KEY);
      }

      await tryBootstrapDb();

      const cachedCount = getCachedTokenCount();
      
      addLog(`<strong>🧠 HLSF Cognition Engine v2.0</strong><br><br>
        This engine performs:<br>
        1. Token adjacency mapping (50 relationship types)<br>
        2. Attention score calculation<br>
        3. Emergent thought stream synthesis<br>
        4. Response refinement based on insights<br>
        5. <strong>Symbolic glyph encryption</strong> (complex number encoding)<br>
        6. <strong>HLSF visualization</strong> (hierarchical semantic framework)<br><br>
        <strong>Commands:</strong> /help, /hlsf, /glyph, /encrypt, /decrypt<br>
        ${cachedCount > 0 ? `<br>✅ Loaded with ${cachedCount} cached tokens` : ''}
        <br><small>⚠️ Note: Download HTML and run locally for API calls to work.</small>
      `);
      
      elements.input.focus();
    }

    window.addEventListener('load', () => {
      tryBootstrapDb();
    });

    initialize();
  </script>
</body>
</html>