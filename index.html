<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HLSF Cognition Engine v2.0</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0a0a;
      --panel: #111;
      --text: #e0e0e0;
      --accent: #00ff88;
      --error: #ff4444;
      --success: #44ff44;
      --warning: #ffd54f;
      --scrollbar: #1f1f1f;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Fira Code', Consolas, Monaco, 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
      width: 100%;
    }

    #header {
      font-size: 1.3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.9rem;
      font-weight: normal;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .stat-value {
      font-weight: bold;
      color: var(--accent);
    }

    #log {
      flex: 1;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
      min-height: 400px;
    }

    #log::-webkit-scrollbar { width: 10px; }
    #log::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 10px; }

    #input-area {
      margin-top: 1rem;
      display: flex;
      gap: 0.75rem;
    }

    #command-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      transition: border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    #command-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn-primary { background: var(--accent); color: #022d15; }
    .btn-secondary { background: #333; color: var(--text); }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.25);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .log-entry {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      animation: fadeIn 0.3s ease;
    }

    .log-entry .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .log-entry.status { font-style: italic; }
    .log-entry.error { border-left-color: var(--error); color: var(--error); }
    .log-entry.success { border-left-color: var(--success); color: var(--success); }
    .log-entry.warning { border-left-color: var(--warning); color: var(--warning); }

    .cost-estimate {
      background: rgba(255, 213, 79, 0.1);
      border: 1px solid var(--warning);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
    }

    .section-divider {
      margin: 1.5rem 0 0.5rem 0;
      border-top: 2px solid #222;
      padding-top: 1rem;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .thought-stream {
      background: rgba(0, 255, 136, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.2);
      border-radius: 8px;
      padding: 1rem;
      font-style: italic;
      line-height: 1.6;
    }

    .adjacency-insight {
      background: rgba(255, 213, 79, 0.05);
      border: 1px solid rgba(255, 213, 79, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .token-highlight {
      background: rgba(0, 255, 136, 0.2);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: bold;
    }

    .final-output {
      border-left: 3px solid var(--success);
      padding: 1rem;
      background: rgba(68, 255, 68, 0.05);
      border-radius: 8px;
    }

    .final-output h3 {
      margin-top: 0;
      color: var(--success);
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid #222;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      margin: 0.5rem 0;
      transition: border 0.2s ease;
    }

    details[open] {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.25);
    }

    summary {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      list-style: none;
      font-weight: 600;
      padding: 0.3rem 0;
    }

    summary::-webkit-details-marker { display: none; }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0.5rem 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: #111;
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2rem;
      width: min(420px, 90vw);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-content h2 { margin: 0; color: var(--accent); }

    .hlsf-canvas-container {
      background: var(--panel);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
    }

    #hlsf-canvas {
      width: 100%;
      height: 600px;
      background: transparent;
      border-radius: 8px;
      cursor: grab;
    }

    #hlsf-canvas:active {
      cursor: grabbing;
    }

    .hlsf-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .hlsf-control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .hlsf-control-group label {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .hlsf-control-group input[type="range"],
    .hlsf-control-group select {
      width: 100%;
    }

    .hlsf-control-group input[type="number"],
    .hlsf-control-group select {
      padding: 0.5rem;
      background: var(--panel);
      border: 1px solid #222;
      border-radius: 6px;
      color: var(--text);
    }

    .hlsf-button-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hlsf-button-row button {
      flex: 1;
      min-width: 80px;
    }

    .hlsf-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      margin-top: 0.5rem;
    }

    .hlsf-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .hlsf-legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .hlsf-node-info {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      font-size: 0.85rem;
      display: none;
    }

    .hlsf-node-info.visible {
      display: block;
    }

    .modal-content input {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      border: 1px solid #222;
      background: #0c0c0c;
      color: var(--text);
      font-size: 1rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .pill-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .pill-button.primary { background: var(--accent); color: #022d15; }
    .pill-button.secondary { background: transparent; border: 1px solid #333; color: var(--text); }

    .pill-button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0, 255, 136, 0.18);
    }

    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 136, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    .processing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      #app { padding: 1rem; }
      #header { flex-direction: column; align-items: flex-start; }
      .header-stats { flex-direction: column; gap: 0.5rem; }
      #input-area { flex-direction: column; }
      .button-group { flex-direction: column; }
      .btn { width: 100%; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="api-modal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true">
      <h2>Enter OpenAI API Key</h2>
      <p>Provide your OpenAI API key (sk-...) to begin using the HLSF Cognition Engine.</p>
      <input id="api-key-input" type="password" placeholder="sk-..." />
      <div class="modal-actions">
        <button id="api-cancel" class="pill-button secondary">Continue offline</button>
        <button id="api-confirm" class="pill-button primary">Save key</button>
      </div>
      <small style="opacity:0.65">‚ö†Ô∏è Note: Download this HTML file and run locally for API calls to work.</small>
    </div>
  </div>

  <div id="app">
    <div id="header">
      <div>HLSF Cognition Engine v2.0</div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">Cache Hit Rate</span>
          <span class="stat-value" id="cache-hit-rate">‚Äî</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Cached Tokens</span>
          <span class="stat-value" id="cached-tokens">‚Äî</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Session Cost</span>
          <span class="stat-value" id="session-cost">$0.00</span>
        </div>
      </div>
    </div>
    <div id="log"></div>
    <div id="input-area">
      <input id="command-input" type="text" placeholder="> Enter a prompt or /command" maxlength="600" autocomplete="off" />
      <div class="button-group">
        <button id="cancel-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
        <button id="send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
    <input id="db-file" type="file" accept=".json,application/json" style="display:none">
    <div class="hlsf-canvas-container" id="hlsf-canvas-container" style="display:none">
      <div class="section-title">üî≠ HLSF Matrix Visualizer</div>
      <canvas id="hlsf-canvas"></canvas>
      <div class="hlsf-controls">
        <div class="hlsf-control-group">
          <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
          <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
          <input id="hlsf-alpha" type="range" min="0.01" max="0.99" step="0.01" value="0.70">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-width">Edge width <span id="hlsf-edge-width-val">1.2</span></label>
          <input id="hlsf-edge-width" type="range" min="0.2" max="5" step="0.1" value="1.2">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
          <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edge-color-mode">Edge coloring</label>
          <select id="hlsf-edge-color-mode">
            <option value="theme">Theme</option>
            <option value="weight">Weight</option>
            <option value="relation">Relation</option>
          </select>
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">50</span></label>
          <input id="hlsf-relation-cap" type="number" min="1" max="50" step="1" value="50">
        </div>
        <div class="hlsf-control-group">
          <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
          <input id="hlsf-edges-per-type" type="number" min="1" max="10" step="1" value="3">
        </div>
        <div class="hlsf-control-group">
          <label>Display options</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
            <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
            <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
            <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>Rotation modes</label>
          <div class="hlsf-button-row">
            <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
            <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergent</button>
          </div>
        </div>
        <div class="hlsf-control-group">
          <label>View</label>
          <div class="hlsf-button-row">
            <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
            <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
            <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      MAX_TOKENS_PER_PROMPT: 100,
      MAX_CONCURRENCY: 5,
      MAX_RETRY_ATTEMPTS: 3,
      RETRY_BASE_DELAY_MS: 500,
      DEFAULT_MODEL: 'gpt-4o-mini',
      ESTIMATED_COST_PER_API_CALL: 0.02,
    };

    // Canonical 50-type display names
    const REL_EN = {
      "‚â°":"Identity","‚äÉ":"Contains","‚äÇ":"Is Contained By","‚âà":"Variant","‚àà":"Is Instance Of","‚àã":"Has Instance",
      "‚ä§":"Is Type Of","‚ä•":"Has Type","‚äè":"Part Of","‚äê":"Composes","‚Üî":"Mirrors","‚áå":"Inverts","‚à•":"Parallel To",
      "‚àº":"Adjacent To","‚Üí":"Next","‚áí":"Sequence Of","‚áê":"Preceded By","‚Ü†":"Follows","‚Üó":"Spatially Above","‚Üò":"Spatially Below",
      "‚Üù":"Symbolically Supports","‚Üß":"Symbolically Depends","‚â†":"Contrasts","‚äï":"Complements","‚äõ":"Associated With","‚àù":"Correlates With",
      "‚áù":"Causes","‚Üº":"Caused By","*":"Evokes","‚âú":"Represents","‚òÖ":"Symbolizes","‚Ü¶":"Refers To","‚ä¢":"Defines","‚ä£":"Is Defined By",
      "‚Ü∑":"Transforms To","‚Ü∂":"Transformed From","‚àò":"Functions As","‚ä®":"Interpreted As","‚óÅ":"Used With","‚áÑ":"Co-occurs With",
      "‚äó":"Synthesizes","√∑":"Divides Into","‚äò":"Opposes","‚Ü≥":"Leads To","‚Ü≤":"Results In","‚üÇ":"Orthogonal To","‚âàÃ∏":"Diverges From",
      "‚âç":"Equivalent In Form","‚âì":"Approximately Equals","‚âî":"Defined As"
    };

    // Return "‚àº Adjacent To"
    const relDisplay = k => `${k} ${REL_EN[k] ?? ''}`.trim();

    const RELKEY_ALIASES = (() => {
      const map = new Map();
      for (const [glyph, name] of Object.entries(REL_EN)) {
        map.set(`${glyph} ${name}`, glyph);
        map.set(name, glyph);
        map.set(name.toLowerCase(), glyph);
      }
      map.set('‚àó', '*');
      map.set('*', '*');
      map.set('‚ãÜ', '*');
      return map;
    })();

    function normRelKey(k) {
      const cleaned = (k || '').trim();
      if (!cleaned) return null;
      if (REL_EN[cleaned]) return cleaned;
      const normalized = cleaned.replace(/\s+/g, ' ');
      const alias = RELKEY_ALIASES.get(normalized)
        || RELKEY_ALIASES.get(normalized.toLowerCase())
        || RELKEY_ALIASES.get(normalized.split(' ')[0]);
      return REL_EN[alias] ? alias : null;
    }

    function normalizeRelKeyForStats(k){
      const g = normRelKey(k);
      return REL_EN[g] ? g : null;
    }

    function renderRelTypeRow(glyph, count){
      return `${relDisplay(glyph)}: ${count} instances`;
    }

    // ---------------- HLSF matrix builder ----------------
    function buildMatrixForRecord(rec) {
      const edges = [];
      const rels = rec?.relationships || {};
      const keys = Object.keys(rels);
      for (const rawKey of keys) {
        const key = normRelKey(rawKey);
        if (!key) continue;
        const arr = Array.isArray(rels[rawKey]) ? rels[rawKey] : [];
        const items = arr
          .filter(x => x && typeof x.weight === 'number')
          .sort((a, b) => b.weight - a.weight);
        if (!items.length) continue;
        const agg = {
          rtype: key,
          aggWeight: items[0].weight,
          sizeWeight: items.reduce((s, x) => s + x.weight, 0),
          count: items.length,
          items
        };
        edges.push(agg);
        if (edges.length === 10) break;
      }
      const freq = typeof rec?.f === 'number'
        ? rec.f
        : typeof rec?.frequency === 'number'
          ? rec.frequency
          : typeof rec?.freq === 'number'
            ? rec.freq
            : 1;
      return { token: rec?.token || '', edges, f: freq };
    }

    function buildHLSFMatrices(db) {
      const raw = db?.full_token_data || [];
      const matrices = new Map();
      const freqs = [];
      for (const rec of raw) {
        const matrix = buildMatrixForRecord(rec);
        matrices.set(matrix.token, matrix);
        if (typeof matrix.f === 'number') freqs.push(matrix.f);
      }

      freqs.sort((a, b) => a - b);
      const freqStats = freqs.length
        ? {
            min: freqs[0],
            max: freqs[freqs.length - 1],
            p90: freqs[Math.max(0, Math.floor(freqs.length * 0.9) - 1)]
          }
        : { min: 0, max: 1, p90: 1 };

      window.HLSF = window.HLSF || {};
      window.HLSF.matrices = matrices;
      window.HLSF.metrics = Object.assign({}, window.HLSF.metrics, { freqStats });

      return matrices;
    }

    function parseHlsfArgs(str) {
      const out = { mode: 'full', tokens: [], glyphs: [], depth: 3.0 };
      const s = (str || '').trim();
      if (!s) return out;
      if (/^--conversation$/i.test(s)) { out.mode = 'conversation'; return out; }
      const m = s.match(/^--\[(.*)\]$/s);
      if (!m) return out;
      const parts = m[1].split(/\s*,\s*/).filter(Boolean);
      for (const p of parts) {
        const kv = p.split(/\s*=\s*/);
        if (kv.length === 2 && /^recursionDepth$/i.test(kv[0])) {
          out.depth = Math.max(0, parseFloat(kv[1]) || 0);
          continue;
        }
        if (/^[\u2200-\u2BFF\u{1F300}-\u{1FAFF}]+$/u.test(p)) out.glyphs.push(p);
        else out.tokens.push(p);
      }
      out.mode = out.glyphs.length ? 'glyphs' : 'tokens';
      return out;
    }

    function buildIndex(db) {
      const idx = new Map();
      (db?.full_token_data || []).forEach(rec => {
        if (rec?.token) idx.set(rec.token, rec);
      });
      return idx;
    }

    function recordScore(rec) {
      let s = 0;
      let any = false;
      for (const arr of Object.values(rec?.relationships || {})) {
        if (Array.isArray(arr) && arr.length) {
          const m = Math.max(...arr.map(x => +x.weight || 0));
          s += m;
          any = true;
        }
      }
      return any ? s : Object.keys(rec?.relationships || {}).length;
    }

    function defaultSeeds(idx, k = 64) {
      const recs = Array.from(idx.values());
      recs.sort((a, b) => recordScore(b) - recordScore(a));
      return recs.slice(0, k).map(r => r.token);
    }

    function edgesFrom(rec) {
      if (!rec) return [];
      const matrix = buildMatrixForRecord(rec);
      const relationCap = clampRelationTypeCap(window.HLSF.config?.relationTypeCap);
      const perType = clampEdgesPerType(window.HLSF.config?.edgesPerType);
      const relations = (matrix?.edges || []).slice(0, relationCap);
      const out = [];
      for (const relation of relations) {
        const items = Array.isArray(relation?.items) ? relation.items.slice(0, perType) : [];
        for (const item of items) {
          const target = item?.token;
          if (!target) continue;
          const weight = Number.isFinite(item?.weight)
            ? item.weight
            : Number.isFinite(item?.w)
              ? item.w
              : relation?.aggWeight;
          out.push({ rtype: relation?.rtype, to: target, w: Number(weight) || 0 });
        }
      }
      return out;
    }

    function assembleGraphFromSeeds(seeds, depthFloat, idx) {
      const graph = { nodes: new Map(), edges: [], seeds: [...seeds] };
      const seen = new Set();
      const q = [];

      for (const seed of seeds) {
        const rec = idx.get(seed);
        if (!rec) continue;
        graph.nodes.set(seed, { token: seed, f: rec.f || rec.frequency || 1 });
        edgesFrom(rec).forEach(e => {
          q.push({ from: seed, to: e.to, w: e.w, rtype: e.rtype, depth: 1 });
        });
      }

      const full = Math.floor(depthFloat);
      for (let d = 1; d <= full; d++) {
        const layer = q
          .filter(e => e.depth === d)
          .sort((a, b) => b.w - a.w);
        const next = [];
        for (const edge of layer) {
          if (!graph.nodes.has(edge.to)) {
            const rec = idx.get(edge.to);
            graph.nodes.set(edge.to, { token: edge.to, f: rec?.f || rec?.frequency || 1 });
          }
          graph.edges.push(edge);
          if (d < full) {
            const rec = idx.get(edge.to);
            if (!rec) continue;
            edgesFrom(rec).forEach(ne => {
              const key = `${edge.to}‚Üí${ne.to}¬∑${ne.rtype}`;
              if (seen.has(key)) return;
              seen.add(key);
              next.push({ from: edge.to, to: ne.to, w: ne.w, rtype: ne.rtype, depth: d + 1 });
            });
          }
        }
        q.push(...next);
      }

      const frac = depthFloat - full;
      if (frac > 0) {
        const tail = q
          .filter(e => e.depth === full + 1)
          .sort((a, b) => b.w - a.w);
        const k = Math.max(0, Math.floor(frac * tail.length));
        for (let i = 0; i < k; i++) {
          const edge = tail[i];
          if (!graph.nodes.has(edge.to)) {
            const rec = idx.get(edge.to);
            graph.nodes.set(edge.to, { token: edge.to, f: rec?.f || rec?.frequency || 1 });
          }
          graph.edges.push(edge);
        }
      }

      return graph;
    }

    function recordScore(rec){
      let s = 0, any = false;
      for (const arr of Object.values(rec.relationships || {})){
        if (Array.isArray(arr) && arr.length){
          const m = Math.max(...arr.map(x => +x.weight || 0));
          s += m; any = true;
        }
      }
      return any ? s : Object.keys(rec.relationships || {}).length;
    }

    function defaultSeeds(idx, k = 64){
      const recs = Array.from(idx.values());
      recs.sort((a,b) => recordScore(b) - recordScore(a));
      return recs.slice(0, k).map(r => r.token);
    }

    function seedsForMode(args){
      const db = getDb();
      if (!db) throw new Error('No DB loaded');
      loadGlyphMaps(db);
      const idx = buildIndex(db);

      if (args.mode === 'conversation') {
        const conv = [...(Session?.tokens || [])].filter(t => idx.has(t));
        const seeds = conv.length ? conv : defaultSeeds(idx, 32);
        return { seeds, idx };
      }

      if (args.mode === 'tokens') {
        let seeds = args.tokens.filter(t => idx.has(t));
        if (!seeds.length) seeds = defaultSeeds(idx, 32);
        return { seeds, idx };
      }

      if (args.mode === 'glyphs') {
        const glyphTokens = [];
        for (const glyph of args.glyphs) {
          const val = GlyphToToken.get(glyph);
          if (!val) continue;
          if (val instanceof Set) glyphTokens.push(...val);
          else if (Array.isArray(val)) glyphTokens.push(...val);
          else glyphTokens.push(val);
        }
        const toks = glyphTokens.filter(t => idx.has(t));
        const seeds = toks.length ? toks : defaultSeeds(idx, 32);
        return { seeds, idx, glyphOnly: true };
      }

      const configuredCap = Number(window.HLSF.config.fullSeedCap);
      const cap = Number.isFinite(configuredCap) && configuredCap > 0
        ? Math.min(configuredCap, idx.size)
        : idx.size;
      return { seeds: defaultSeeds(idx, cap), idx };
    }

    function nodeLabel(token, glyphOnly = false) {
      const glyph = TokenToGlyph.get(token);
      if (glyphOnly && glyph) return glyph;
      return glyph || token;
    }

    function edgeLabel(rtype) {
      return window.HLSF.config.showEnglish
        ? `${rtype} ${REL_EN[rtype] || ''}`.trim()
        : rtype;
    }

    function drawComposite(graph, opts = {}) {
      const cfg = window.HLSF.config;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found');
        return;
      }
      const ctx = window.HLSF.ctx || (window.HLSF.ctx = canvas.getContext('2d'));
      const width = canvas.width = canvas.clientWidth;
      const height = canvas.height = canvas.clientHeight;
      const theme = cfg.whiteBg
        ? { bg: '#fff', fg: '#000', hint: '#444' }
        : { bg: '#000', fg: '#fff', hint: '#bbb' };
      const edgeColorMode = normalizeEdgeColorMode(cfg.edgeColorMode);
      const edgeWidth = clampEdgeWidth(cfg.edgeWidth);
      const nodeScale = clampNodeSize(cfg.nodeSize);
      const showGlow = cfg.showNodeGlow === true;
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = theme.fg;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const seeds = graph.seeds && graph.seeds.length ? graph.seeds : [...graph.nodes.keys()].slice(0, 1);
      const pos = new Map();
      const cx = width / 2;
      const cy = height / 2;
      if (!window.HLSF.__centerInit) {
        window.HLSF.config.tx = cx;
        window.HLSF.config.ty = cy;
        window.HLSF.__centerInit = true;
      }
      const centerX = Number.isFinite(window.HLSF.config.tx) ? window.HLSF.config.tx : cx;
      const centerY = Number.isFinite(window.HLSF.config.ty) ? window.HLSF.config.ty : cy;
      const scale = typeof cfg.scale === 'number' && cfg.scale > 0 ? cfg.scale : 1;
      const fontScale = Math.max(0.6, Math.min(2.5, Math.sqrt(scale)));
      ctx.font = `${Math.max(9, Math.round(12 * fontScale))}px 'Fira Code', monospace`;
      const effectiveEdgeWidth = edgeWidth * Math.max(0.6, Math.min(2.5, scale));
      ctx.lineWidth = effectiveEdgeWidth;
      const Rc = Math.min(width, height) * 0.35 * scale;
      const rotation = (window.HLSF.state && Number.isFinite(window.HLSF.state.globalRot))
        ? window.HLSF.state.globalRot
        : 0;

      seeds.forEach((token, idx) => {
        const angle = (idx / Math.max(1, seeds.length)) * Math.PI * 2 + rotation;
        const x = centerX + Rc * Math.cos(angle);
        const y = centerY + Rc * Math.sin(angle);
        pos.set(token, { x, y });
      });

      const groupByRoot = new Map();
      graph.edges.forEach(edge => {
        if (!groupByRoot.has(edge.from)) groupByRoot.set(edge.from, []);
        groupByRoot.get(edge.from).push(edge);
      });

      for (const [root, edges] of groupByRoot.entries()) {
        const base = pos.get(root) || { x: centerX, y: centerY };
        const R = Math.min(width, height) * 0.18 * scale;
        edges
          .slice(0, 10)
          .sort((a, b) => b.w - a.w)
          .forEach((edge, i) => {
            const theta = Math.PI * (i / Math.max(1, edges.length - 1));
            const x = base.x + R * Math.cos(theta);
            const y = base.y - R * Math.sin(theta);
            if (!pos.has(edge.to)) pos.set(edge.to, { x, y });
          });
      }

      const glyphOnly = opts.glyphOnly === true;
      if (cfg.showEdges !== false) {
        graph.edges.forEach(edge => {
          const from = pos.get(edge.from) || pos.get(edge.to);
          const to = pos.get(edge.to);
          if (!from || !to) return;
          ctx.globalAlpha = edgeAlphaFromWeight(edge.w);
          const strokeColor = compositeEdgeStrokeColor(edge, edgeColorMode) || theme.fg;
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = theme.fg;
          if (cfg.showLabels !== false) {
            const mx = (from.x + to.x) / 2;
            const my = (from.y + to.y) / 2;
            ctx.fillStyle = theme.hint;
            ctx.fillText(edgeLabel(edge.rtype), mx, my - 10 * scale);
            ctx.fillStyle = theme.fg;
          }
        });
      }

      for (const [token, data] of graph.nodes.entries()) {
        const position = pos.get(token) || { x: centerX, y: centerY };
        const freq = typeof data.f === 'number' ? data.f : 1;
        const radius = Math.max(2, (4 + 2 * Math.log2(1 + Math.max(0, freq))) * scale * nodeScale);
        ctx.globalAlpha = baseAlpha();
        ctx.save();
        if (showGlow) {
          ctx.shadowColor = 'rgba(0, 255, 136, 0.35)';
          ctx.shadowBlur = 14 * Math.max(1, scale);
        }
        ctx.beginPath();
        ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        ctx.globalAlpha = 1.0;
        if (cfg.showLabels !== false) {
          ctx.globalAlpha = baseAlpha();
          ctx.fillStyle = theme.fg;
          ctx.fillText(nodeLabel(token, glyphOnly), position.x, position.y - (radius + 12 * scale));
          ctx.globalAlpha = 1.0;
        }
      }

      ctx.restore();
    }

    // ---------------- O20 layout ----------------
    function buildO20Layout(width, height, margin = 32) {
      const cx = width / 2;
      const cy = height / 2;
      const R = Math.min(cx, cy) - margin;
      const slots = [];
      for (let i = 0; i < 20; i++) {
        const theta = Math.PI * (i / 19);
        slots.push({
          x: cx + R * Math.cos(theta),
          y: cy - R * Math.sin(theta),
          theta
        });
      }
      return { cx, cy, R, slots };
    }

    function getCachedO20Layout(width, height, margin = 32) {
      window.HLSF = window.HLSF || {};
      const cache = window.HLSF.layoutCache;
      if (cache && cache.width === width && cache.height === height && cache.margin === margin) {
        return cache.layout;
      }
      const layout = buildO20Layout(width, height, margin);
      window.HLSF.layoutCache = { width, height, margin, layout };
      return layout;
    }

    function applyFrequencyVisuals(f) {
      const value = typeof f === 'number' ? f : 0;
      const stats = window.HLSF?.metrics?.freqStats;
      if (!stats || typeof stats.min !== 'number' || typeof stats.max !== 'number') {
        const clamped = Math.min(1, Math.max(0, value));
        return { norm: clamped, isHigh: value >= 1 };
      }
      const range = stats.max - stats.min;
      const norm = range === 0 ? 0 : (value - stats.min) / range;
      const clamped = Math.min(1, Math.max(0, norm));
      const threshold = typeof stats.p90 === 'number' ? stats.p90 : stats.max;
      return { norm: clamped, isHigh: value >= threshold };
    }

    // ---------------- Canvas renderer ----------------
    function drawHLSFMatrix(graph, opts = {}) {
      drawComposite(graph, opts);
    }

    let _anim = null;
    function animateComposite(graph, glyphOnly = false) {
      if (!graph) return;
      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawComposite(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function animateHLSF(graph, glyphOnly = false) {
      if (!graph) return;
      const canvas = window.HLSF.canvas || (window.HLSF.canvas = document.getElementById('hlsf-canvas'));
      if (!canvas) {
        console.warn('HLSF canvas element not found for animation');
        return;
      }

      cancelAnimationFrame(_anim);
      window.HLSF.currentGraph = graph;
      window.HLSF.currentGlyphOnly = glyphOnly === true;
      let last = performance.now();
      (function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        stepRotation(dt);
        drawHLSFMatrix(graph, { glyphOnly });
        _anim = requestAnimationFrame(loop);
      })(last);
    }

    function stopHLSFAnimation() {
      if (_anim) {
        cancelAnimationFrame(_anim);
        _anim = null;
      }
      if (window.HLSF) {
        window.HLSF.currentGraph = null;
        window.HLSF.currentGlyphOnly = false;
        window.HLSF.__centerInit = false;
      }
      if (typeof stopLegacyHLSFAnimation === 'function') {
        try {
          stopLegacyHLSFAnimation();
        } catch (err) {
          console.warn('Legacy HLSF animation stop failed:', err);
        }
      }
    }

    const MAX_REL_TYPES = 50;
    const MAX_EDGES_PER_TYPE = 10;

    function clampRelationTypeCap(value) {
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return MAX_REL_TYPES;
      return Math.min(MAX_REL_TYPES, Math.max(1, numeric));
    }

    function clampEdgesPerType(value) {
      const numeric = Math.floor(Number(value));
      if (!Number.isFinite(numeric)) return 3;
      return Math.min(MAX_EDGES_PER_TYPE, Math.max(1, numeric));
    }

    function clampEdgeWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1.2;
      return Math.min(5, Math.max(0.2, numeric));
    }

    function clampNodeSize(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 1;
      return Math.min(2.5, Math.max(0.5, numeric));
    }

    function normalizeEdgeColorMode(value) {
      switch (value) {
        case 'weight':
        case 'relation':
          return value;
        default:
          return 'theme';
      }
    }

    function ensureHLSFCanvas() {
      let wrapper = document.getElementById('hlsf-canvas-container');
      if (wrapper) {
        wrapper.style.display = '';
      } else {
        if (!elements?.log) {
          console.warn('Log element not ready for HLSF canvas');
          return null;
        }

        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;

        wrapper = document.createElement('div');
        wrapper.id = 'hlsf-canvas-container';
        wrapper.className = 'hlsf-canvas-container';
        wrapper.innerHTML = `
          <div class="section-title">üî≠ HLSF Matrix Visualizer</div>
          <canvas id="hlsf-canvas"></canvas>
          <div class="hlsf-controls">
            <div class="hlsf-control-group">
              <label for="hlsf-rotation-speed">Rotation speed <span id="hlsf-speed-val">0.00</span></label>
              <input id="hlsf-rotation-speed" type="range" min="-2" max="2" step="0.01" value="0.30">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-alpha">Alpha <span id="hlsf-alpha-val">0.70</span></label>
              <input id="hlsf-alpha" type="range" min="0.01" max="0.99" step="0.01" value="0.70">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-width">Edge width <span id="hlsf-edge-width-val">1.2</span></label>
              <input id="hlsf-edge-width" type="range" min="0.2" max="5" step="0.1" value="1.2">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-node-size">Node size <span id="hlsf-node-size-val">1.0</span></label>
              <input id="hlsf-node-size" type="range" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edge-color-mode">Edge coloring</label>
              <select id="hlsf-edge-color-mode">
                <option value="theme">Theme</option>
                <option value="weight">Weight</option>
                <option value="relation">Relation</option>
              </select>
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-relation-cap">Relation types <span id="hlsf-relation-cap-val">${MAX_REL_TYPES}</span></label>
              <input id="hlsf-relation-cap" type="number" min="1" max="${MAX_REL_TYPES}" step="1" value="${MAX_REL_TYPES}">
            </div>
            <div class="hlsf-control-group">
              <label for="hlsf-edges-per-type">Edges per type <span id="hlsf-edges-per-type-val">3</span></label>
              <input id="hlsf-edges-per-type" type="number" min="1" max="${MAX_EDGES_PER_TYPE}" step="1" value="3">
            </div>
            <div class="hlsf-control-group">
              <label>Display options</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-edges" class="btn btn-secondary">Edges: On</button>
                <button id="hlsf-toggle-labels" class="btn btn-secondary">Labels: On</button>
                <button id="hlsf-toggle-glow" class="btn btn-secondary">Glow: Off</button>
                <button id="hlsf-toggle-bg" class="btn btn-secondary">BG: Dark</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>Rotation modes</label>
              <div class="hlsf-button-row">
                <button id="hlsf-toggle-rotation" class="btn btn-secondary">Start Global</button>
                <button id="hlsf-toggle-emergent" class="btn btn-secondary">Start Emergent</button>
              </div>
            </div>
            <div class="hlsf-control-group">
              <label>View</label>
              <div class="hlsf-button-row">
                <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
                <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
                <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
              </div>
            </div>
          </div>
        `;

        entry.appendChild(wrapper);
        elements.log.appendChild(entry);
        elements.log.scrollTop = elements.log.scrollHeight;
      }

      const canvas = /** @type {HTMLCanvasElement|null} */ (wrapper.querySelector('#hlsf-canvas'));
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      bindHlsfControls(wrapper);
      syncHlsfControls(wrapper);

      return canvas;
    }

    function bindHlsfControls(wrapper) {
      if (!wrapper || wrapper.dataset.controlsBound === 'true') return;

      const canvas = wrapper.querySelector('#hlsf-canvas');
      if (canvas) {
        window.HLSF.canvas = canvas;
        window.HLSF.ctx = canvas.getContext('2d');
      }

      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      if (speedSlider && speedVal) {
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }

      const edgeWidthSlider = wrapper.querySelector('#hlsf-edge-width');
      const edgeWidthVal = wrapper.querySelector('#hlsf-edge-width-val');
      if (edgeWidthSlider && edgeWidthVal) {
        edgeWidthSlider.addEventListener('input', (e) => {
          const next = clampEdgeWidth(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.edgeWidth = next;
          edgeWidthVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(edgeWidthSlider.value)) > 1e-6) {
            edgeWidthSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      if (nodeSizeSlider && nodeSizeVal) {
        nodeSizeSlider.addEventListener('input', (e) => {
          const next = clampNodeSize(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.nodeSize = next;
          nodeSizeVal.textContent = next.toFixed(1);
          if (Math.abs(next - parseFloat(nodeSizeSlider.value)) > 1e-6) {
            nodeSizeSlider.value = next.toFixed(1);
          }
          debouncedLegacyRender();
        });
      }

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      if (relationInput) {
        relationInput.addEventListener('input', () => {
          const next = clampRelationTypeCap(relationInput.value);
          window.HLSF.config.relationTypeCap = next;
          relationInput.value = String(next);
          if (relationVal) relationVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      if (edgesInput) {
        edgesInput.addEventListener('input', () => {
          const next = clampEdgesPerType(edgesInput.value);
          window.HLSF.config.edgesPerType = next;
          edgesInput.value = String(next);
          if (edgesVal) edgesVal.textContent = String(next);
          rebuildHlsfFromLastCommand(true);
        });
      }

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      if (edgeColorSelect) {
        edgeColorSelect.addEventListener('change', (e) => {
          const value = normalizeEdgeColorMode(e.target.value);
          window.HLSF.config.edgeColorMode = value;
          edgeColorSelect.value = value;
          debouncedLegacyRender();
        });
      }

      const zoomIn = wrapper.querySelector('#hlsf-zoom-in');
      if (zoomIn) {
        zoomIn.addEventListener('click', () => {
          window.HLSF.config.scale *= 1.2;
          debouncedLegacyRender();
        });
      }

      const zoomOut = wrapper.querySelector('#hlsf-zoom-out');
      if (zoomOut) {
        zoomOut.addEventListener('click', () => {
          window.HLSF.config.scale *= 0.8;
          debouncedLegacyRender();
        });
      }

      const reset = wrapper.querySelector('#hlsf-reset-view');
      if (reset) {
        reset.addEventListener('click', () => {
          const canvasEl = window.HLSF.canvas;
          window.HLSF.config.scale = 1;
          if (canvasEl) {
            window.HLSF.config.tx = canvasEl.width / 2;
            window.HLSF.config.ty = canvasEl.height / 2;
          } else {
            window.HLSF.config.tx = 0;
            window.HLSF.config.ty = 0;
          }
          debouncedLegacyRender();
        });
      }

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) {
        rotationBtn.addEventListener('click', () => {
          window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
          if (window.HLSF.config.rotationActive) {
            window.HLSF.config.emergentActive = false;
          }
          syncHlsfControls(wrapper);
        });
      }

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) {
        emergentBtn.addEventListener('click', () => {
          window.HLSF.config.emergentActive = !window.HLSF.config.emergentActive;
          if (window.HLSF.config.emergentActive) {
            window.HLSF.config.rotationActive = false;
          }
          syncHlsfControls(wrapper);
        });
      }

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) {
        edgesBtn.addEventListener('click', () => {
          window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
          edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
          debouncedLegacyRender();
        });
      }

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) {
        labelsBtn.addEventListener('click', () => {
          window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
          labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
          debouncedLegacyRender();
        });
      }

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) {
        glowBtn.addEventListener('click', () => {
          window.HLSF.config.showNodeGlow = !window.HLSF.config.showNodeGlow;
          glowBtn.textContent = window.HLSF.config.showNodeGlow ? 'Glow: On' : 'Glow: Off';
          debouncedLegacyRender();
        });
      }

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) {
        bgBtn.addEventListener('click', () => {
          window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
          bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
          debouncedLegacyRender();
        });
      }

      const canvasEl = wrapper.querySelector('#hlsf-canvas');
      if (canvasEl) {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvasEl.addEventListener('mousedown', (e) => {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvasEl.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.config.tx += dx;
          window.HLSF.config.ty += dy;
          lastX = e.clientX;
          lastY = e.clientY;
          debouncedLegacyRender();
        });

        canvasEl.addEventListener('mouseleave', () => {
          isDragging = false;
        });
      }

      wrapper.dataset.controlsBound = 'true';
    }

    function syncHlsfControls(wrapper) {
      if (!wrapper) return;

      const config = window.HLSF.config || {};
      const speedSlider = wrapper.querySelector('#hlsf-rotation-speed');
      const speedVal = wrapper.querySelector('#hlsf-speed-val');
      const omega = Number.isFinite(config.rotationOmega) ? config.rotationOmega : 0;
      window.HLSF.config.rotationOmega = omega;
      if (speedSlider) speedSlider.value = omega.toFixed(2);
      if (speedVal) speedVal.textContent = omega.toFixed(2);

      const alphaSlider = wrapper.querySelector('#hlsf-alpha');
      const alphaVal = wrapper.querySelector('#hlsf-alpha-val');
      const alpha = clampAlpha(config.alpha);
      window.HLSF.config.alpha = alpha;
      if (alphaSlider) alphaSlider.value = alpha.toFixed(2);
      if (alphaVal) alphaVal.textContent = alpha.toFixed(2);

      const edgeWidthSlider = wrapper.querySelector('#hlsf-edge-width');
      const edgeWidthVal = wrapper.querySelector('#hlsf-edge-width-val');
      const edgeWidth = clampEdgeWidth(config.edgeWidth);
      window.HLSF.config.edgeWidth = edgeWidth;
      if (edgeWidthSlider) edgeWidthSlider.value = edgeWidth.toFixed(1);
      if (edgeWidthVal) edgeWidthVal.textContent = edgeWidth.toFixed(1);

      const nodeSizeSlider = wrapper.querySelector('#hlsf-node-size');
      const nodeSizeVal = wrapper.querySelector('#hlsf-node-size-val');
      const nodeSize = clampNodeSize(config.nodeSize);
      window.HLSF.config.nodeSize = nodeSize;
      if (nodeSizeSlider) nodeSizeSlider.value = nodeSize.toFixed(1);
      if (nodeSizeVal) nodeSizeVal.textContent = nodeSize.toFixed(1);

      const relationInput = wrapper.querySelector('#hlsf-relation-cap');
      const relationVal = wrapper.querySelector('#hlsf-relation-cap-val');
      const relationCap = clampRelationTypeCap(config.relationTypeCap);
      window.HLSF.config.relationTypeCap = relationCap;
      if (relationInput) relationInput.value = String(relationCap);
      if (relationVal) relationVal.textContent = String(relationCap);

      const edgesInput = wrapper.querySelector('#hlsf-edges-per-type');
      const edgesVal = wrapper.querySelector('#hlsf-edges-per-type-val');
      const edgesPerType = clampEdgesPerType(config.edgesPerType);
      window.HLSF.config.edgesPerType = edgesPerType;
      if (edgesInput) edgesInput.value = String(edgesPerType);
      if (edgesVal) edgesVal.textContent = String(edgesPerType);

      const edgeColorSelect = wrapper.querySelector('#hlsf-edge-color-mode');
      const colorMode = normalizeEdgeColorMode(config.edgeColorMode);
      window.HLSF.config.edgeColorMode = colorMode;
      if (edgeColorSelect) edgeColorSelect.value = colorMode;

      const rotationBtn = wrapper.querySelector('#hlsf-toggle-rotation');
      if (rotationBtn) rotationBtn.textContent = config.rotationActive ? 'Stop Global' : 'Start Global';

      const emergentBtn = wrapper.querySelector('#hlsf-toggle-emergent');
      if (emergentBtn) emergentBtn.textContent = config.emergentActive ? 'Stop Emergent' : 'Start Emergent';

      const edgesBtn = wrapper.querySelector('#hlsf-toggle-edges');
      if (edgesBtn) edgesBtn.textContent = config.showEdges ? 'Edges: On' : 'Edges: Off';

      const labelsBtn = wrapper.querySelector('#hlsf-toggle-labels');
      if (labelsBtn) labelsBtn.textContent = config.showLabels ? 'Labels: On' : 'Labels: Off';

      const glowBtn = wrapper.querySelector('#hlsf-toggle-glow');
      if (glowBtn) glowBtn.textContent = config.showNodeGlow ? 'Glow: On' : 'Glow: Off';

      const bgBtn = wrapper.querySelector('#hlsf-toggle-bg');
      if (bgBtn) bgBtn.textContent = config.whiteBg ? 'BG: Light' : 'BG: Dark';
    }

    window.HLSF = window.HLSF || {};
    const existingConfig = window.HLSF.config || {};
    const DEFAULT_BOOTSTRAP_DB = "HLSF_Database_2025-10-15.json";
    window.HLSF.config = Object.assign({
      bootstrapDbUrl: existingConfig.bootstrapDbUrl || DEFAULT_BOOTSTRAP_DB,
      rotationActive: true,
      rotationOmega: 0.30,
      alpha: 0.10,
      scale: 1,
      tx: 0,
      ty: 0,
      emergentActive: false,
      showEdges: true,
      showLabels: true,
      fillFaces: false,
      whiteBg: false,
      showEnglish: true,
      fullSeedCap: 0,
      relationTypeCap: MAX_REL_TYPES,
      edgesPerType: 3,
      edgeWidth: 1.2,
      nodeSize: 1,
      edgeColorMode: 'theme',
      showNodeGlow: false,
    }, existingConfig);
    window.HLSF.config.relationTypeCap = clampRelationTypeCap(window.HLSF.config.relationTypeCap);
    window.HLSF.config.edgesPerType = clampEdgesPerType(window.HLSF.config.edgesPerType);
    window.HLSF.config.edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
    window.HLSF.config.nodeSize = clampNodeSize(window.HLSF.config.nodeSize);
    window.HLSF.config.edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
    window.HLSF.config.showNodeGlow = window.HLSF.config.showNodeGlow === true;
    window.HLSF.state = Object.assign({
      globalRot: 0,
      emergentRot: 0,
    }, window.HLSF.state || {});
    window.HLSF.canvas = window.HLSF.canvas || null;
    window.HLSF.ctx = window.HLSF.ctx || null;
    window.HLSF.nodes = window.HLSF.nodes || [];
    window.HLSF.animationFrame = window.HLSF.animationFrame || null;
    window.HLSF.geometry = window.HLSF.geometry || {};
    window.HLSF.rendering = window.HLSF.rendering || {};
    window.HLSF.__centerInit = window.HLSF.__centerInit || false;

    const clampAlpha = (value) => {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return NaN;
      return Math.min(0.99, Math.max(0.01, numeric));
    };
    window.HLSF.config.alpha = (() => {
      const initial = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(initial) ? initial : 0.1;
    })();
    const baseAlpha = () => {
      const resolved = clampAlpha(window.HLSF.config.alpha);
      return Number.isFinite(resolved) ? resolved : 0.1;
    };
    const edgeAlphaFromWeight = (w) => {
      const preferred = Number.isFinite(w) ? clampAlpha(w) : NaN;
      if (Number.isFinite(preferred)) return preferred;
      return baseAlpha();
    };

    const EDGE_COLOR_PALETTE = [
      '#00ff88', '#ffd54f', '#ff6f91', '#64b5f6', '#ce93d8',
      '#ff8a65', '#4dd0e1', '#9ccc65', '#f06292', '#ba68c8'
    ];

    function paletteColor(key) {
      if (!key) return EDGE_COLOR_PALETTE[0];
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = (hash * 33 + key.charCodeAt(i)) | 0;
      }
      const index = Math.abs(hash) % EDGE_COLOR_PALETTE.length;
      return EDGE_COLOR_PALETTE[index];
    }

    function normalizedIntensity(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(1, numeric));
    }

    function weightToColor(value) {
      const t = normalizedIntensity(value);
      const r = Math.round(255 - 90 * t);
      const g = Math.round(160 + 80 * t);
      const b = Math.round(120 + 16 * (1 - t));
      const alpha = 0.45 + 0.45 * t;
      return `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(2)})`;
    }

    function nodeEdgeStrokeColor(node, index, mode) {
      if (mode === 'relation') {
        return paletteColor(`${node.token}-${index}`);
      }
      if (mode === 'weight') {
        return weightToColor(node.attention ?? 0);
      }
      return null;
    }

    function compositeEdgeStrokeColor(edge, mode) {
      if (mode === 'relation') {
        return paletteColor(edge.rtype || `${edge.from}->${edge.to}`);
      }
      if (mode === 'weight') {
        return weightToColor(edge.w ?? 0);
      }
      return null;
    }

    function stepRotation(dt) {
      const w = window.HLSF.config.rotationOmega || 0;
      if ((!window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive) || !w) return;
      const tau = 2 * Math.PI;
      window.HLSF.state.globalRot = (window.HLSF.state.globalRot + dt * w) % tau;
      window.HLSF.state.emergentRot = (window.HLSF.state.emergentRot + dt * w) % tau;
    }

    let TokenToGlyph = new Map();
    let GlyphToToken = new Map();

    function loadGlyphMaps(db) {
      if (!db) return;
      if (!(TokenToGlyph instanceof Map)) TokenToGlyph = new Map();
      if (!(GlyphToToken instanceof Map)) GlyphToToken = new Map();
      TokenToGlyph.clear();
      GlyphToToken.clear();
      (db.token_glyph_map || []).forEach(({ token, glyph }) => {
        if (token && glyph) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
      (db.glyph_token_map || []).forEach(({ glyph, token }) => {
        if (glyph && token) {
          TokenToGlyph.set(token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(token);
        }
      });
    }

    window.CognitionEngine = window.CognitionEngine || {
      state: {},
      cache: {},
      api: {},
      processing: {},
    };

    window.GlyphSystem = window.GlyphSystem || {
      ledger: null,
      encode: () => '',
      decode: () => '',
      export: () => ({}),
    };

    // ---- Glyph crypto core ----
    const LEDGER_KEY = "HLSF_GLYPH_LEDGER_V1";
    const GLYPH_SET = Array.from("‚¨£‚¨ß‚¨©‚¨°‚¨™‚¨®‚¨§‚¨ü‚¨¢‚¨•‚¨†‚¨ô‚¨ò‚¨ó‚¨ñ‚¨ï‚¨î‚¨ì‚¨í‚¨ë"); // limited symbols
    const GLYPH_SEP = " "; // delimiter between glyph-weight pairs
    const NUM_FMT = n => Number(n).toString(); // unlimited precision as given

    function hydrateLedgerMaps(ledger) {
      TokenToGlyph.clear();
      GlyphToToken.clear();
      const map = ledger?.glyph_map || {};
      for (const glyph of Object.keys(map)) {
        const entries = Array.isArray(map[glyph]) ? map[glyph] : [];
        for (const entry of entries) {
          if (!entry || !entry.token) continue;
          TokenToGlyph.set(entry.token, glyph);
          if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
          GlyphToToken.get(glyph).add(entry.token);
        }
      }
    }

    // Load/save ledger
    function loadLedger() {
      let ledger;
      try {
        const raw = localStorage.getItem(LEDGER_KEY);
        ledger = raw ? JSON.parse(raw) : null;
      } catch {
        ledger = null;
      }
      if (!ledger || typeof ledger !== 'object') {
        ledger = { version: "1.0", created_at: new Date().toISOString(), glyph_map: {} };
      } else {
        ledger.version = ledger.version || "1.0";
        ledger.created_at = ledger.created_at || new Date().toISOString();
        ledger.glyph_map = ledger.glyph_map || {};
      }
      hydrateLedgerMaps(ledger);
      return ledger;
    }
    function saveLedger(ledger) {
      try {
        localStorage.setItem(LEDGER_KEY, JSON.stringify(ledger));
      } catch (err) {
        console.warn('Failed to persist glyph ledger:', err);
      }
    }

    // ---- HLSF constants
    const TOKEN_CACHE_PREFIX = 'hlsf_token_';
    const DB_RAW_KEY = 'HLSF_DB_RAW';        // stores JSON export text
    const API_KEY_STORAGE_KEY = 'HLSF_API_KEY';
    const DB_INDEX_KEY = 'HLSF_DB_INDEX';    // array of token strings

    function parseMaybeNdjson(text) {
      try { return JSON.parse(text); } catch {}
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const rows = [];
      for (const ln of lines) {
        try { rows.push(JSON.parse(ln)); } catch {}
      }
      return rows.length ? rows : null;
    }

    function coerceDb(input) {
      const data = (typeof input === 'string') ? parseMaybeNdjson(input.replace(/^\uFEFF/, '')) : input;
      if (!data) throw new Error('Unparseable JSON/NDJSON');
      if (data && !Array.isArray(data) && Array.isArray(data.full_token_data)) {
        return Object.assign({}, data, { full_token_data: data.full_token_data });
      }
      if (Array.isArray(data)) return { full_token_data: data };
      throw new Error('Invalid database format. Expected full_token_data array.');
    }

    function normalizeRecord(rec) {
      if (!rec || typeof rec.token !== 'string') return null;
      const rels = rec.relationships && typeof rec.relationships === 'object' ? rec.relationships : {};
      const out = { token: rec.token, relationships: rels, cached_at: rec.cached_at || null };
      for (const [key, value] of Object.entries(rec)) {
        if (key === 'token' || key === 'relationships' || key === 'cached_at') continue;
        out[key] = value;
      }
      return out;
    }

    function loadDbObject(dbLike) {
      const db = coerceDb(dbLike);
      const raw = Array.from(db.full_token_data || []);
      const clean = raw.map(normalizeRecord).filter(Boolean);
      if (!clean.length) throw new Error('No valid token records');
      const out = Object.assign({}, db, { full_token_data: clean });
      localStorage.setItem(DB_RAW_KEY, JSON.stringify(out));
      const index = clean.map(r => r.token);
      localStorage.setItem(DB_INDEX_KEY, JSON.stringify(index));
      window.HLSF.dbCache = out;
      window.HLSF.matrices = null;
      window.HLSF.layoutCache = null;
      state.hlsfReady = false;
      if (typeof buildHLSFMatrices === 'function') {
        try {
          buildHLSFMatrices(out);
        } catch (err) {
          console.warn('Failed to rebuild HLSF matrices:', err);
        }
      }
      updateHeaderCounts();
      return clean.length;
    }

    function getDb() {
      if (window.HLSF.dbCache) return window.HLSF.dbCache;
      let raw = null;
      try {
        raw = localStorage.getItem(DB_RAW_KEY);
        if (!raw) {
          const legacy = localStorage.getItem('hlsf_db_raw');
          if (legacy) {
            localStorage.setItem(DB_RAW_KEY, legacy);
            localStorage.removeItem('hlsf_db_raw');
            raw = legacy;
          }
        }
      } catch (err) {
        console.warn('Failed to read DB from storage:', err);
        raw = null;
      }
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        window.HLSF.dbCache = parsed;
        return parsed;
      } catch (err) {
        console.warn('Stored DB is not valid JSON:', err);
        return null;
      }
    }

    // Symbolic glyphs for complex number representation
    const GLYPH_LIBRARY = [
      '‚óâ', '‚óà', '‚óá', '‚óÜ', '‚óä', '‚óã', '‚óè', '‚óê', '‚óë', '‚óí',
      '‚óì', '‚òâ', '‚äô', '‚äö', '‚äõ', '‚äú', '‚äù', '‚óé', '‚óç', '‚óå',
      '‚ñ≥', '‚ñ≤', '‚ñΩ', '‚ñº', '‚óÅ', '‚ñ∑', '‚óÄ', '‚ñ∂', '‚¨ü', '‚¨†',
      '‚¨°', '‚¨¢', '‚¨£', '‚¨§', '‚¨•', '‚¨¶', '‚¨ß', '‚¨®', '‚¨©', '‚¨™',
      '‚¨´', '‚¨¨', '‚¨≠', '‚¨Æ', '‚¨Ø', '‚≠ê', '‚òÖ', '‚òÜ', '‚ú¶', '‚úß',
      '‚ú∂', '‚ú∑', '‚ú∏', '‚úπ', '‚ú∫', '‚úª', '‚úº', '‚úΩ', '‚úæ', '‚úø',
      '‚ùÄ', '‚ùÅ', '‚ùÇ', '‚ùÉ', '‚ùÑ', '‚ùÖ', '‚ùÜ', '‚ùá', '‚ùà', '‚ùâ',
      '‚öô', '‚öõ', '‚öù', '‚öû', '‚öü', '‚ö¨', '‚ö≠', '‚öÆ', '‚öØ', '‚ö∞'
    ];

    const RELATIONSHIP_PRIORITIES = new Map([
      ['‚â°', 1.0], ['‚äÉ', 1.0], ['‚äÇ', 0.8], ['‚âà', 0.7], ['‚àà', 0.9], ['‚àã', 0.9],
      ['‚ä§', 0.9], ['‚ä•', 0.9], ['‚äè', 0.8], ['‚äê', 0.8], ['‚Üî', 0.7], ['‚áå', 0.7],
      ['‚à•', 0.6], ['‚àº', 0.5], ['‚Üí', 0.5], ['‚áí', 0.5], ['‚áê', 0.5], ['‚Ü†', 0.5],
      ['‚Üó', 0.4], ['‚Üò', 0.4], ['‚áù', 1.0], ['‚áÇ', 0.7], ['‚â†', 0.8], ['‚äï', 0.8],
      ['‚äõ', 0.7], ['‚àù', 0.7], ['‚áù Causes', 1.0], ['‚áê Caused By', 0.9],
      ['‚àó', 0.7], ['‚âú', 0.9], ['‚ãÜ', 0.8], ['7‚Üí', 0.7], ['‚ä¢', 0.9], ['‚ä£', 0.9],
      ['‚Ü∑', 0.8], ['‚Ü∂', 0.8], ['‚ó¶', 0.9], ['|=', 0.9], ['‚óÅ', 0.6], ['‚áÑ', 0.6],
      ['‚äó', 0.9], ['√∑', 0.7], ['‚äò', 0.8], ['√ó', 0.8], ['¬¨', 0.8], ['‚Ä†', 0.8],
      ['‚ä†', 0.8], ['/‚àà', 0.8], ['‚ä¨', 0.8], ['‚ä©', 0.9], ['‚ä®', 0.9], ['?', 0.5],
      ['‚ö°', 0.7], ['‚áí Attention', 0.7], ['‚Ü∂ Self-Reference', 0.7], ['‚àß', 0.6],
      ['‚Ü≠', 0.6], ['‚ñ∑‚óÅ', 0.6]
    ]);

    // ============================================
    // STATE
    // ============================================
    const state = {
      apiKey: '',
      isProcessing: false,
      sessionStats: {
        totalApiCalls: 0,
        totalCacheHits: 0,
        totalCostCents: 0,
      },
      hlsfReady: false,
    };

    state.hlsfReady = false;
    window.CognitionEngine.state = state;

    let currentAbortController = null;

    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      log: document.getElementById('log'),
      input: document.getElementById('command-input'),
      sendBtn: document.getElementById('send-btn'),
      cancelBtn: document.getElementById('cancel-btn'),
      apiModal: document.getElementById('api-modal'),
      apiKeyInput: document.getElementById('api-key-input'),
      apiConfirmBtn: document.getElementById('api-confirm'),
      apiCancelBtn: document.getElementById('api-cancel'),
      cacheHitRate: document.getElementById('cache-hit-rate'),
      cachedTokens: document.getElementById('cached-tokens'),
      sessionCost: document.getElementById('session-cost'),
      dbFileInput: document.getElementById('db-file'),
    };

    // ============================================
    // UTILITIES
    // ============================================
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validatePrompt(prompt) {
      if (!prompt || typeof prompt !== 'string') {
        throw new Error('Invalid prompt: must be non-empty string');
      }
      if (prompt.length > 10000) {
        throw new Error('Prompt too long: max 10000 characters');
      }
      return prompt.trim();
    }

    function safeStorageGet(key, defaultValue = null) {
      try {
        const item = localStorage.getItem(key);
        if (item == null) return defaultValue;
        try {
          return JSON.parse(item);
        } catch {
          return item;
        }
      } catch (err) {
        console.warn(`Storage read failed for ${key}:`, err);
        return defaultValue;
      }
    }

    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        console.warn(`Storage write failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.warn(`Storage remove failed for ${key}:`, err);
        return false;
      }
    }

    function safeStorageKeys(prefix = '') {
      try {
        return Object.keys(localStorage).filter(k => k.startsWith(prefix));
      } catch (err) {
        console.warn('Storage keys enumeration failed:', err);
        return [];
      }
    }

    function isValidApiKey(key) {
      if (typeof key !== 'string') return false;
      const trimmed = key.trim();
      if (!trimmed) return false;
      if (!trimmed.startsWith('sk-')) return false;
      return trimmed.length >= 20;
    }

    function tokenize(text) {
      if (!text) return [];
      return text.trim()
        .split(/[^\p{L}\p{N}\-']+/u)
        .filter(Boolean)
        .map(t => t.toLowerCase());
    }

    const Session = (() => {
      const existing = window.Session && typeof window.Session === 'object'
        ? window.Session
        : {};
      const session = Object.assign({ tokens: new Set() }, existing);
      window.Session = session;
      return session;
    })();

    function addConversationTokens(arr) {
      for (const token of arr || []) {
        if (token) Session.tokens.add(token);
      }
    }

    function onUserPromptSubmitted(text) {
      const toks = text.trim().split(/\s+/).filter(Boolean);
      addConversationTokens(toks);
    }

    function formatCurrency(cents) {
      return `$${(cents / 100).toFixed(2)}`;
    }

    function getCachedTokenCount() {
      return safeStorageKeys(TOKEN_CACHE_PREFIX).length;
    }

    // ============================================
    // COMPLEX NUMBER ENCODING & GLYPH SYSTEM
    // ============================================
    
    // Convert token to complex number representation
    // Magnitude = attention score, Phase = semantic hash
    function tokenToComplexNumber(token, tokenData) {
      const attentionScore = tokenData?.attention_score || 0.5;
      const magnitude = attentionScore; // 0.0 to 1.0
      
      // Generate phase from token's semantic properties
      let phaseHash = 0;
      for (let i = 0; i < token.length; i++) {
        phaseHash = ((phaseHash << 5) - phaseHash) + token.charCodeAt(i);
        phaseHash = phaseHash & phaseHash;
      }
      
      // Normalize phase to 0-2œÄ
      const phase = (Math.abs(phaseHash) % 360) * (Math.PI / 180);
      
      // Calculate real and imaginary parts
      const real = magnitude * Math.cos(phase);
      const imaginary = magnitude * Math.sin(phase);
      
      return { real, imaginary, magnitude, phase };
    }

    const memoizedComplexNumber = (() => {
      const cache = new Map();
      return (token, tokenData) => {
        const score = tokenData?.attention_score ?? 0;
        const key = `${token}_${score}`;
        if (cache.has(key)) return cache.get(key);
        const result = tokenToComplexNumber(token, tokenData);
        cache.set(key, result);
        return result;
      };
    })();

    // Map complex number to glyph from library
    function complexToGlyph(complex) {
      // Use magnitude and phase to select glyph
      const magnitudeIndex = Math.floor(complex.magnitude * 7); // 0-7 range
      const phaseIndex = Math.floor((complex.phase / (2 * Math.PI)) * 10); // 0-9 range
      const glyphIndex = (magnitudeIndex * 10 + phaseIndex) % GLYPH_LIBRARY.length;
      return GLYPH_LIBRARY[glyphIndex];
    }

    // Generate glyph ledger for all cached tokens
    function generateGlyphLedger() {
      const ledger = new Map();
      const reverseMap = new Map(); // glyph -> tokens
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);

      for (const key of keys) {
        try {
          const tokenData = safeStorageGet(key);
          if (!tokenData?.token) continue;
          const token = tokenData.token;
          const complex = memoizedComplexNumber(token, tokenData);
          const glyph = complexToGlyph(complex);

          ledger.set(token, {
            glyph,
            complex: {
              real: complex.real.toFixed(4),
              imaginary: complex.imaginary.toFixed(4),
              magnitude: complex.magnitude.toFixed(4),
              phase: complex.phase.toFixed(4)
            },
            attention_score: tokenData.attention_score || 0
          });
          
          // Track consolidation - multiple tokens per glyph
          if (!reverseMap.has(glyph)) {
            reverseMap.set(glyph, []);
          }
          reverseMap.get(glyph).push(token);
        } catch (err) {
          console.error('Failed to process token:', key, err);
        }
      }
      
      return { ledger, reverseMap };
    }

    // Consolidate similar tokens to same glyph
    function findConsolidatedTokens(reverseMap) {
      const consolidated = [];
      for (const [glyph, tokens] of reverseMap.entries()) {
        if (tokens.length > 1) {
          consolidated.push({ glyph, tokens, count: tokens.length });
        }
      }
      return consolidated.sort((a, b) => b.count - a.count);
    }

    // Encode message using glyph ledger
    function encodeMessage(message, ledger) {
      const tokens = tokenize(message);
      const encoded = [];
      const unknown = [];
      
      for (const token of tokens) {
        const entry = ledger.get(token);
        if (entry) {
          encoded.push(entry.glyph);
        } else {
          encoded.push('‚óå'); // Unknown token marker
          unknown.push(token);
        }
      }
      
      return {
        encoded: encoded.join(''),
        coverage: ((tokens.length - unknown.length) / tokens.length * 100).toFixed(1),
        unknown
      };
    }

    // Decode message using reverse glyph map
    function decodeMessage(encoded, reverseMap) {
      const glyphs = Array.from(encoded);
      const decoded = [];
      
      for (const glyph of glyphs) {
        const tokens = reverseMap.get(glyph);
        if (tokens && tokens.length > 0) {
          // Use first token (could use most common or context-aware selection)
          decoded.push(tokens[0]);
        } else {
          decoded.push('[?]');
        }
      }
      
      return decoded.join(' ');
    }

    // Export glyph ledger for inter-system transmission
    function exportGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        ledger_version: "1.0",
        description: "HLSF Symbolic Glyph Encryption Ledger - Complex Number Token Encoding",
        specification: {
          encoding: "Complex numbers (magnitude=attention, phase=semantic_hash)",
          glyph_library_size: GLYPH_LIBRARY.length,
          representation: "Unicode symbolic glyphs",
          consolidation: "Similar tokens map to same glyph based on complex number proximity"
        },
        statistics: {
          total_tokens: ledger.size,
          unique_glyphs: reverseMap.size,
          consolidation_ratio: (ledger.size / reverseMap.size).toFixed(2),
          consolidated_groups: consolidated.length
        },
        glyph_ledger: Object.fromEntries(ledger),
        reverse_mapping: Object.fromEntries(
          Array.from(reverseMap.entries()).map(([glyph, tokens]) => [glyph, tokens])
        ),
        consolidated_tokens: consolidated,
        encryption_examples: generateEncryptionExamples(ledger, reverseMap)
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Glyph_Ledger_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return exportData;
    }

    window.GlyphSystem.ledger = null;
    window.GlyphSystem.encode = function encode(message) {
      const result = encryptTextToGlyphs(message || '');
      window.GlyphSystem.ledger = loadLedger();
      return { encoded: result.encrypted, coverage: result.coverage, unknown: result.unknown };
    };
    window.GlyphSystem.decode = function decode(encoded) {
      return decryptGlyphsToText(encoded || '');
    };
    window.GlyphSystem.export = function exportLedgerSnapshot() {
      return loadLedger();
    };

    function generateEncryptionExamples(ledger, reverseMap) {
      const examples = [
        "hello world",
        "consciousness",
        "quantum entanglement"
      ];
      
      return examples.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          plaintext: msg,
          encoded: result.encoded,
          coverage: result.coverage + '%',
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
    }

    function showGlyphLedger() {
      const { ledger, reverseMap } = generateGlyphLedger();
      const consolidated = findConsolidatedTokens(reverseMap);
      
      // Show sample encoded messages
      const sampleMessages = [
        "What is consciousness?",
        "Explain quantum mechanics",
        "The nature of reality"
      ];
      
      const encodedSamples = sampleMessages.map(msg => {
        const result = encodeMessage(msg, ledger);
        return {
          original: msg,
          encoded: result.encoded,
          coverage: result.coverage,
          decoded: decodeMessage(result.encoded, reverseMap)
        };
      });
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">üîê Symbolic Glyph Encryption Ledger</div>
        
        <div class="adjacency-insight">
          <strong>üìê Complex Number Encoding:</strong><br>
          ‚Ä¢ Each token ‚Üí Complex number (magnitude + phase)<br>
          ‚Ä¢ Magnitude = Attention score (0.0-1.0)<br>
          ‚Ä¢ Phase = Semantic hash (0-2œÄ radians)<br>
          ‚Ä¢ Glyph = Visual representation of complex coordinates
        </div>

        <div class="adjacency-insight">
          <strong>üìä Ledger Statistics:</strong><br>
          ‚Ä¢ Total tokens: <strong>${ledger.size}</strong><br>
          ‚Ä¢ Unique glyphs: <strong>${reverseMap.size}</strong><br>
          ‚Ä¢ Consolidation ratio: <strong>${(ledger.size / reverseMap.size).toFixed(2)}:1</strong><br>
          ‚Ä¢ Efficiency gain: <strong>${(100 - (reverseMap.size / ledger.size * 100)).toFixed(1)}%</strong>
        </div>

        <div class="adjacency-insight">
          <strong>üîÑ Token Consolidation (Similar tokens ‚Üí Same glyph):</strong><br>
          ${consolidated.slice(0, 5).map(c => 
            `‚Ä¢ <span style="font-size: 1.5em;">${c.glyph}</span> ‚Üí ${c.tokens.slice(0, 3).join(', ')}${c.tokens.length > 3 ? '...' : ''} (${c.count} tokens)`
          ).join('<br>')}
          ${consolidated.length === 0 ? '<em>No consolidation yet - need more diverse tokens</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>üîê Encrypted Message Examples:</strong><br>
          ${encodedSamples.map(s => `
            <div style="margin: 0.75rem 0; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px;">
              <div style="opacity: 0.7; font-size: 0.85em;">Original:</div>
              <div style="margin: 0.25rem 0;">${s.original}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Encrypted (${s.coverage}% coverage):</div>
              <div style="font-size: 1.3em; letter-spacing: 0.1em; color: var(--accent); margin: 0.25rem 0;">${s.encoded}</div>
              <div style="opacity: 0.7; font-size: 0.85em; margin-top: 0.5rem;">Decoded:</div>
              <div style="margin: 0.25rem 0;">${s.decoded}</div>
            </div>
          `).join('')}
        </div>

        <details>
          <summary>üìñ View full glyph mapping (first 20 tokens)</summary>
          <pre>${JSON.stringify(
            Object.fromEntries(Array.from(ledger.entries()).slice(0, 20)),
            null, 2
          )}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          üí° <strong>Usage:</strong> This ledger enables secure inter-system communication. 
          Messages encoded with glyphs can be transmitted efficiently and decoded by any system 
          with the same ledger. The consolidation reduces message size while maintaining semantic meaning.
        </div>
      `);
    }

    // ============================================
    // LOGGING
    // ============================================
    function batchLogUpdates(entries) {
      const fragment = document.createDocumentFragment();
      entries.forEach(entry => fragment.appendChild(entry));
      elements.log.appendChild(fragment);
      elements.log.scrollTop = elements.log.scrollHeight;
    }

    function addLog(content, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>${content}`;
      batchLogUpdates([entry]);
      return entry;
    }

    function appendLog(msg, type = 'info') {
      if (typeof msg === 'string') return addLog(msg, type);
      return addLog(sanitize(String(msg)), type);
    }

    function logStatus(msg) {
      return appendLog(`<div class="processing-indicator"><span class="spinner"></span>${sanitize(msg)}</div>`, 'status');
    }
    function logError(msg) { return appendLog(`üî¥ ${sanitize(msg)}`, 'error'); }
    function logSuccess(msg) { return appendLog(`‚úÖ ${sanitize(msg)}`, 'success'); }
    function logWarning(msg) { return appendLog(`‚ö†Ô∏è ${sanitize(msg)}`, 'warning'); }
    function logFinal(msg) { return appendLog(`‚úÖ ${sanitize(msg)}`, 'success'); }

    function debounce(fn, delay) {
      let timeout;
      return function debounced(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    async function safeAsync(fn, errorMsg) {
      try {
        return await fn();
      } catch (err) {
        logError(`${errorMsg}: ${err.message}`);
        console.error(errorMsg, err);
        return null;
      }
    }

    // ============================================
    // STATS
    // ============================================
    function updateStats() {
      const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
      const total = totalApiCalls + totalCacheHits;
      const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) + '%' : '‚Äî';

      const cachedCount = getCachedTokenCount();

      elements.cacheHitRate.textContent = hitRate;
      elements.cachedTokens.textContent = cachedCount;
      elements.sessionCost.textContent = formatCurrency(totalCostCents);

      // Visual feedback for database growth
      if (cachedCount > 0) {
        elements.cachedTokens.style.color = cachedCount > 50 ? '#00ff88' : '#ffd54f';
      }
    }

    function updateHeaderCounts() {
      updateStats();
    }

    // ============================================
    // CACHE
    // ============================================
    function getCacheKey(token) {
      const normalized = token == null ? '' : String(token);
      return `${TOKEN_CACHE_PREFIX}${normalized.toLowerCase()}`;
    }

    function updateTokenIndex(token) {
      if (!token) return;

      let index = safeStorageGet(DB_INDEX_KEY, []);
      if (!Array.isArray(index)) index = [];
      if (!index.includes(token)) {
        index.push(token);
        safeStorageSet(DB_INDEX_KEY, JSON.stringify(index));
      }
    }

    function getFromCache(token) {
      try {
        const raw = safeStorageGet(getCacheKey(token));
        if (!raw) return null;
        state.sessionStats.totalCacheHits++;
        updateStats();
        return raw;
      } catch { return null; }
    }

    function saveToCache(token, data) {
      try {
        const payloadData = {
          ...data,
          cached_at: new Date().toISOString(),
        };
        const payload = JSON.stringify(payloadData);
        const ok = safeStorageSet(getCacheKey(token), payload);
        if (!ok) return;
        updateTokenIndex(token);
      } catch (err) {
        if (err.name === 'QuotaExceededError') {
          logWarning('Cache full. Use /reset to clear old data.');
        }
      }
    }

    window.CognitionEngine.cache = {
      get: getFromCache,
      set: saveToCache,
      key: getCacheKey,
    };

    // ============================================
    // OPENAI API
    // ============================================
    async function callOpenAI(messages, options = {}) {
      if (!state.apiKey) throw new Error('No API key configured');

      const body = {
        model: options.model || CONFIG.DEFAULT_MODEL,
        messages,
        max_tokens: options.max_tokens || 1000,
        temperature: options.temperature || 0.7,
      };

      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
        if (currentAbortController?.signal.aborted) {
          const error = new Error('Cancelled');
          error.name = 'AbortError';
          throw error;
        }

        attempt++;
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.apiKey}`,
            },
            body: JSON.stringify(body),
          });

          if (response.status === 429 && attempt < CONFIG.MAX_RETRY_ATTEMPTS) {
            await new Promise(r => setTimeout(r, CONFIG.RETRY_BASE_DELAY_MS * Math.pow(2, attempt - 1)));
            continue;
          }

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `API error (${response.status})`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error?.message) errorMessage = errorData.error.message;
            } catch (e) {
              if (errorText) errorMessage = errorText;
            }
            
            if (response.status === 401) errorMessage = 'Invalid API key';
            else if (response.status === 403) errorMessage = 'Access forbidden - check billing setup';
            else if (response.status === 429) errorMessage = 'Rate limit exceeded';
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          state.sessionStats.totalApiCalls++;
          state.sessionStats.totalCostCents += Math.ceil(CONFIG.ESTIMATED_COST_PER_API_CALL * 100);
          updateStats();

          return data.choices?.[0]?.message?.content?.trim() || '';
        } catch (err) {
          if (err.name === 'AbortError') throw err;
          if (err.message === 'Failed to fetch') {
            throw new Error('Network error - check connection or download HTML to run locally');
          }
          if (attempt === CONFIG.MAX_RETRY_ATTEMPTS) throw err;
        }
      }
    }

    window.CognitionEngine.api = {
      callOpenAI,
    };

    // ============================================
    // ADJACENCY
    // ============================================
    class ProgressTracker {
      constructor(total, label) {
        this.total = total;
        this.current = 0;
        this.label = label;
        this.element = logStatus(`‚è≥ ${label} (0/${total})`);
      }

      increment(count = 1) {
        this.current += count;
        const percent = this.total === 0 ? 100 : Math.round((this.current / this.total) * 100);
        if (this.element) {
          this.element.innerHTML = `‚è≥ ${this.label} (${this.current}/${this.total}) - ${percent}%`;
        }
      }

      complete(message) {
        if (this.element) {
          this.element.innerHTML = `‚úÖ ${message || `${this.label} complete`}`;
        }
      }
    }

    async function fetchAdjacency(token, context) {
      if (currentAbortController?.signal.aborted) {
        throw new Error('AbortError');
      }

      const cached = getFromCache(token);
      if (cached) {
        return { ...cached, cache_hit: true };
      }

      if (!state.apiKey) return { token, relationships: {}, offline: true };

      const prompt = `Token: "${token}"
Context: "${context}"

For this token, identify the most relevant adjacent tokens across relationship types. For each that applies, provide related tokens with weights 0.01-1.00.

Relationship types: ‚â° Identity, ‚äÉ Contains, ‚äÇ Is Contained By, ‚âà Variant, ‚àà Is Instance Of, ‚àã Has Instance, ‚ä§ Is Type Of, ‚ä• Has Type, ‚äè Part Of, ‚äê Composes, ‚Üî Mirrors, ‚áå Inverts, ‚à• Parallel To, ‚àº Adjacent To, ‚Üí Next, ‚áí Sequence Of, ‚áê Preceded By, ‚Ü† Follows, ‚Üó Spatially Above, ‚Üò Spatially Below, ‚áù Symbolically Supports, ‚áÇ Symbolically Depends, ‚â† Contrasts, ‚äï Complements, ‚äõ Associated With, ‚àù Correlates With, ‚áù Causes, ‚áê Caused By, ‚àó Evokes, ‚âú Represents, ‚ãÜ Symbolizes, 7‚Üí Refers To, ‚ä¢ Defines, ‚ä£ Is Defined By, ‚Ü∑ Transforms To, ‚Ü∂ Transformed From, ‚ó¶ Functions As, |= Interpreted As, ‚óÅ Used With, ‚áÑ Co-occurs With, ‚äó Synthesizes, √∑ Divides Into, ‚äò Opposes, √ó Rejects, ¬¨ Negates, ‚Ä† Destroys, ‚ä† Blocks, /‚àà Invalidates, ‚ä¨ Contradicts, ‚ä© Asserts, ‚ä® Provides Evidence, ? Uncertainty, ‚ö° Memory, ‚áí Attention, ‚Ü∂ Self-Reference, ‚àß Perspective, ‚Ü≠ Continuity, ‚ñ∑‚óÅ Relationality

Return JSON: {"token": "${token}", "relationships": {"‚â°": [{"token": "...", "weight": 0.95}], ...}}`;

      let safePrompt;
      try {
        safePrompt = validatePrompt(prompt);
      } catch (err) {
        logError(`Prompt validation failed for ${token}: ${err.message}`);
        return { token, relationships: {}, error: 'invalid_prompt' };
      }

      const content = await safeAsync(
        () => callOpenAI([
          { role: 'system', content: 'You are an HLSF token adjacency analyzer.' },
          { role: 'user', content: safePrompt },
        ]),
        `Adjacency fetch failed for ${token}`
      );

      if (!content) {
        return { token, relationships: {}, error: 'request_failed' };
      }

      try {
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const parsed = JSON.parse(content.slice(jsonStart, jsonEnd + 1));
        saveToCache(token, parsed);
        return { ...parsed, cache_hit: false };
      } catch {
        return { token, relationships: {}, error: 'Parse failed' };
      }
    }

    async function batchFetchAdjacencies(tokens, context, label) {
      const results = new Map();
      const unique = [...new Set(tokens)];

      const progress = new ProgressTracker(unique.length, label);

      let processed = 0;
      for (let i = 0; i < unique.length; i += CONFIG.MAX_CONCURRENCY) {
        if (currentAbortController?.signal.aborted) {
          progress.complete(`${label} cancelled (${processed}/${unique.length})`);
          break;
        }

        const batch = unique.slice(i, i + CONFIG.MAX_CONCURRENCY);
        const settled = await Promise.allSettled(batch.map(t => fetchAdjacency(t, context)));
        
        settled.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            results.set(batch[idx], result.value);
          }
        });

        processed += batch.length;
        progress.increment(batch.length);
      }

      const hits = Array.from(results.values()).filter(r => r.cache_hit).length;
      progress.complete(`${label}: ${hits} cached, ${results.size - hits} new`);
      return results;
    }

    window.CognitionEngine.processing = {
      fetchAdjacency,
      batchFetchAdjacencies,
    };

    function calculateAttention(matrices) {
      for (const entry of matrices.values()) {
        let weightSum = 0, totalEdges = 0;
        const rels = entry?.relationships || {};
        
        for (const [rel, edges] of Object.entries(rels)) {
          const priority = RELATIONSHIP_PRIORITIES.get(rel) || 0.3;
          if (Array.isArray(edges)) {
            edges.forEach(edge => {
              weightSum += (edge.weight || 0) * priority;
              totalEdges++;
            });
          }
        }
        
        entry.attention_score = totalEdges > 0 ? Number((weightSum / totalEdges).toFixed(3)) : 0;
        entry.total_relationships = totalEdges;
      }
      return matrices;
    }

    function summarizeAttention(matrices) {
      const summary = [];
      for (const [token, data] of matrices.entries()) {
        summary.push({ 
          token, 
          attention: data.attention_score || 0, 
          total: data.total_relationships || 0 
        });
      }
      return summary.sort((a, b) => b.attention - a.attention).slice(0, 10);
    }

    function formatTopTokens(topTokens) {
      const { ledger } = generateGlyphLedger();
      return topTokens.map(t => {
        const glyphEntry = ledger.get(t.token);
        const glyph = glyphEntry ? glyphEntry.glyph : '‚óå';
        return `<span class="token-highlight">${glyph} ${t.token}</span> (${t.attention.toFixed(2)})`;
      }).join(', ');
    }

    function extractKeyRelationships(matrices) {
      const relationships = [];
      let count = 0;
      for (const [token, data] of matrices.entries()) {
        if (count >= 5) break;
        const rels = data?.relationships || {};
        for (const [rel, edges] of Object.entries(rels)) {
          if (!Array.isArray(edges) || edges.length === 0) continue;
          const topEdge = edges.sort((a, b) => b.weight - a.weight)[0];
          relationships.push(`${token} ${rel} ${topEdge.token} (${topEdge.weight.toFixed(2)})`);
          count++;
          if (count >= 5) break;
        }
      }
      return relationships;
    }

    // ============================================
    // HLSF VISUALIZATION
    // ============================================

    function polygonVertices(center, radius, sides) {
      const vertices = [];
      const angleStep = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep - Math.PI / 2;
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return vertices;
    }

    function deriveAdjacencyPolygon(center, baseRadius, relationships) {
      const entries = Object.entries(relationships || {})
        .filter(([, edges]) => Array.isArray(edges) && edges.length > 0)
        .map(([relType, edges]) => {
          const weightSum = edges.reduce((sum, edge) => {
            const weight = typeof edge.weight === 'number' ? edge.weight : 0;
            return sum + weight;
          }, 0);
          const avgWeight = edges.length > 0 ? weightSum / edges.length : 0;
          return {
            relType,
            count: edges.length,
            avgWeight
          };
        })
        .sort((a, b) => a.relType.localeCompare(b.relType));

      if (entries.length === 0) {
        return {
          vertices: polygonVertices(center, baseRadius * 0.8, 3),
          anchorIndex: 0,
          adjacencyTypes: 0
        };
      }

      const vertexCount = Math.max(entries.length + 1, 3);
      const baseAngle = -Math.PI / 2;
      const angleStep = (2 * Math.PI) / vertexCount;
      const maxCount = Math.max(...entries.map(entry => entry.count));

      const vertices = [];
      const anchor = [center[0], center[1] - baseRadius];
      vertices.push(anchor);

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const normalizedWeight = Math.min(1, Math.max(0, entry.avgWeight));
        const countFactor = maxCount > 0 ? entry.count / maxCount : 0;
        const radialFactor = 0.85 + normalizedWeight * 0.35 + countFactor * 0.25;
        const radius = baseRadius * radialFactor;
        const angle = baseAngle + angleStep * (i + 1);
        vertices.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }

      let fillerIndex = entries.length;
      while (vertices.length < 3) {
        const angle = baseAngle + angleStep * (fillerIndex + 1);
        vertices.push([
          center[0] + baseRadius * 0.75 * Math.cos(angle),
          center[1] + baseRadius * 0.75 * Math.sin(angle)
        ]);
        fillerIndex++;
      }

      return {
        vertices,
        anchorIndex: 0,
        adjacencyTypes: entries.length
      };
    }

    function buildBaseTriangles(vertices, sides) {
      if (sides < 3) return [];
      const triangles = [];
      const center = vertices.reduce((acc, v) =>
        [acc[0] + v[0] / sides, acc[1] + v[1] / sides], [0, 0]);

      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        triangles.push([center, vertices[i], vertices[next]]);
      }
      return triangles;
    }

    function rotateTrianglesAround(triangles, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return triangles.map(tri => tri.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      }));
    }

    function rotatePointsAround(points, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * cos - dy * sin,
          center[1] + dx * sin + dy * cos
        ];
      });
    }

    function scalePointsAround(points, center, scale) {
      if (!Array.isArray(points)) return [];
      return points.map(vertex => {
        const dx = vertex[0] - center[0];
        const dy = vertex[1] - center[1];
        return [
          center[0] + dx * scale,
          center[1] + dy * scale
        ];
      });
    }

    function scaleTrianglesAround(triangles, center, scale) {
      if (!Array.isArray(triangles)) return [];
      return triangles.map(tri => scalePointsAround(tri, center, scale));
    }

    window.HLSF.geometry = {
      polygonVertices,
      buildBaseTriangles,
      rotateTrianglesAround,
      rotatePointsAround,
      scalePointsAround,
      scaleTrianglesAround,
      deriveAdjacencyPolygon,
    };

    let hlsfNodes = [];

    function buildHLSFNodes() {
      const graph = window.HLSF_GRAPH;
      let tokenRecords = [];

      if (graph?.tokens instanceof Map) {
        tokenRecords = Array.from(graph.tokens.values());
      } else if (graph?.tokens && typeof graph.tokens === 'object') {
        tokenRecords = Object.values(graph.tokens);
      }

      let sourceLabel = '';

      if (tokenRecords.length === 0) {
        const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
        console.log(`Scanning ${keys.length} cached tokens from storage for HLSF build`);

        for (const key of keys) {
          try {
            const tokenData = safeStorageGet(key);
            if (!tokenData?.token) {
              console.warn('Token missing from data:', key);
              continue;
            }
            tokenRecords.push(tokenData);
          } catch (err) {
            console.error('Failed to process token:', key, err);
          }
        }

        if (graph) {
          graph.tokens = new Map(tokenRecords.map(record => [record.token, record]));
        }

        sourceLabel = '(storage scan)';
      } else {
        sourceLabel = '(graph cache)';
      }

      console.log(`Building HLSF nodes from ${tokenRecords.length} cached tokens ${sourceLabel}`.trim());

      const nodes = [];

      for (const tokenData of tokenRecords) {
        try {
          const token = tokenData.token;

          if (!token) {
            console.warn('Token missing from data:', tokenData);
            continue;
          }

          const rels = tokenData.relationships || {};

          // Count adjacencies
          let adjacencyCount = 0;
          for (const edges of Object.values(rels)) {
            if (Array.isArray(edges)) adjacencyCount += edges.length;
          }
          const adjacencyTypes = Object.values(rels)
            .filter(edges => Array.isArray(edges) && edges.length > 0)
            .length;

          const attention = typeof tokenData.attention_score === 'number'
            ? tokenData.attention_score
            : 0.5;
          const complex = memoizedComplexNumber(token, { ...tokenData, attention_score: attention });
          const glyph = complexToGlyph(complex);

          // Position based on complex number
          const x = complex.real * 2;
          const y = complex.imaginary * 2;

          // Radius based on attention
          const radius = 0.3 + attention * 0.4;

          // Build polygon derived from adjacency structure
          const shape = deriveAdjacencyPolygon([x, y], radius, rels);
          const sides = shape.vertices.length;

          // Color based on attention
          let color;
          if (attention >= 0.8) color = [0, 255, 136];
          else if (attention >= 0.5) color = [255, 213, 79];
          else color = [255, 119, 119];

          nodes.push({
            token,
            glyph,
            center: [x, y],
            radius,
            sides,
            attention,
            adjacencyCount,
            adjacencyTypes,
            anchorIndex: shape.anchorIndex,
            color,
            vertices: shape.vertices,
            triangles: null // Will be computed
          });
        } catch (err) {
          console.error('Failed to process token for HLSF:', tokenData, err);
        }
      }

      console.log(`Built ${nodes.length} HLSF nodes`);
      
      // Generate triangles for each node
      for (const node of nodes) {
        try {
          node.triangles = buildBaseTriangles(node.vertices, node.sides);
        } catch (err) {
          console.error(`Failed to build triangles for ${node.token}:`, err);
          node.triangles = [];
        }
      }
      
      return nodes;
    }

    function initHLSFCanvas() {
      console.log('Initializing HLSF Canvas...');
      
      try {
        // Build nodes first to check if we have data
        hlsfNodes = buildHLSFNodes();
        
        if (hlsfNodes.length === 0) {
          logWarning('No cached tokens found for HLSF. Process some queries first to populate the database.');
          return;
        }
        
        console.log(`Creating canvas UI for ${hlsfNodes.length} nodes`);
        
        const container = document.createElement('div');
        container.className = 'hlsf-canvas-container';
      container.innerHTML = `
        <div style="margin-bottom: 1rem;">
          <div class="section-title">üåå HLSF: Hierarchical-Level Semantic Framework</div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">
            Geometric token visualization. Each polygon fans outward from a primary corner based on
            adjacency types, forming unique base-level shapes per matrix. Triangular subdivisions show
            hierarchical structure.
          </div>
        </div>
        <canvas id="hlsf-canvas" width="1200" height="600"></canvas>
        <div class="hlsf-controls">
          <div class="hlsf-control-group">
            <label>Rotation Speed</label>
            <input type="range" id="hlsf-rotation-speed" min="0" max="5" step="0.01" value="0.30">
            <span id="hlsf-speed-val">0.30</span>
          </div>

          <div class="hlsf-control-group">
            <label>Alpha Transparency</label>
            <input type="range" id="hlsf-alpha" min="0.01" max="0.99" step="0.01" value="0.10">
            <span id="hlsf-alpha-val">0.10</span>
          </div>
          
          <div class="hlsf-control-group">
            <label>View Controls</label>
            <div class="hlsf-button-row">
              <button id="hlsf-zoom-in" class="btn btn-secondary">Zoom +</button>
              <button id="hlsf-zoom-out" class="btn btn-secondary">Zoom ‚àí</button>
              <button id="hlsf-reset-view" class="btn btn-secondary">Reset</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Rotation Modes</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-rotation" class="btn btn-primary">Start Global</button>
              <button id="hlsf-toggle-emergent" class="btn btn-success">Start Emergent</button>
            </div>
          </div>
          
          <div class="hlsf-control-group">
            <label>Display Options</label>
            <div class="hlsf-button-row">
              <button id="hlsf-toggle-edges" class="btn btn-neutral">Edges: On</button>
              <button id="hlsf-toggle-labels" class="btn btn-neutral">Labels: On</button>
              <button id="hlsf-toggle-bg" class="btn btn-neutral">BG: Dark</button>
            </div>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.85rem;">
          <strong>Controls:</strong> Drag to pan ‚Ä¢ Scroll to zoom ‚Ä¢ Each polygon = token matrix ‚Ä¢
          Fan vertices = adjacency types ‚Ä¢ Color = attention score<br>
          <strong>Modes:</strong> Global rotation = all polygons rotate around center ‚Ä¢ 
          Emergent rotation = each polygon rotates around its own center
        </div>
      `;
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
      entry.appendChild(container);
      elements.log.appendChild(entry);
      elements.log.scrollTop = elements.log.scrollHeight;
      
      // Initialize canvas
      window.HLSF.canvas = document.getElementById('hlsf-canvas');
      window.HLSF.ctx = window.HLSF.canvas.getContext('2d');
      
      console.log('Canvas initialized:', window.HLSF.canvas ? 'success' : 'failed');
      
      // Setup controls
      const speedSlider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (speedSlider && speedVal) {
        const omega = Number.isFinite(window.HLSF.config.rotationOmega)
          ? window.HLSF.config.rotationOmega
          : 0;
        speedSlider.value = omega.toFixed(2);
        speedVal.textContent = omega.toFixed(2);
        speedSlider.addEventListener('input', (e) => {
          const next = parseFloat(e.target.value);
          if (!Number.isFinite(next)) return;
          window.HLSF.config.rotationOmega = next;
          speedVal.textContent = next.toFixed(2);
          debouncedLegacyRender();
        });
      }

      const alphaSlider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (alphaSlider && alphaVal) {
        const alpha = baseAlpha();
        alphaSlider.value = alpha.toFixed(2);
        alphaVal.textContent = alpha.toFixed(2);
        window.HLSF.config.alpha = alpha;
        alphaSlider.addEventListener('input', (e) => {
          const raw = parseFloat(e.target.value);
          const next = clampAlpha(raw);
          if (!Number.isFinite(next)) {
            logError('Alpha value must be numeric.');
            return;
          }
          window.HLSF.config.alpha = next;
          alphaVal.textContent = next.toFixed(2);
          if (Math.abs(next - parseFloat(alphaSlider.value)) > 1e-6) {
            alphaSlider.value = next.toFixed(2);
          }
          debouncedLegacyRender();
        });
      }
      
      document.getElementById('hlsf-zoom-in').addEventListener('click', () => {
        window.HLSF.config.scale *= 1.2;
        debouncedLegacyRender();
      });

      document.getElementById('hlsf-zoom-out').addEventListener('click', () => {
        window.HLSF.config.scale *= 0.8;
        debouncedLegacyRender();
      });

      document.getElementById('hlsf-reset-view').addEventListener('click', () => {
        window.HLSF.config.scale = 1;
        window.HLSF.config.tx = window.HLSF.canvas.width / 2;
        window.HLSF.config.ty = window.HLSF.canvas.height / 2;
        debouncedLegacyRender();
      });
      
      const rotationBtn = document.getElementById('hlsf-toggle-rotation');
      rotationBtn.addEventListener('click', () => {
        window.HLSF.config.rotationActive = !window.HLSF.config.rotationActive;
        window.HLSF.config.emergentActive = false;
        rotationBtn.textContent = window.HLSF.config.rotationActive ? 'Stop Global' : 'Start Global';
        document.getElementById('hlsf-toggle-emergent').textContent = 'Start Emergent';
      });
      
      const emergentBtn = document.getElementById('hlsf-toggle-emergent');
      emergentBtn.addEventListener('click', () => {
        window.HLSF.config.emergentActive = !window.HLSF.config.emergentActive;
        window.HLSF.config.rotationActive = false;
        emergentBtn.textContent = window.HLSF.config.emergentActive ? 'Stop Emergent' : 'Start Emergent';
        document.getElementById('hlsf-toggle-rotation').textContent = 'Start Global';
      });
      
      const edgesBtn = document.getElementById('hlsf-toggle-edges');
      edgesBtn.addEventListener('click', () => {
        window.HLSF.config.showEdges = !window.HLSF.config.showEdges;
        edgesBtn.textContent = window.HLSF.config.showEdges ? 'Edges: On' : 'Edges: Off';
        debouncedLegacyRender();
      });

      const labelsBtn = document.getElementById('hlsf-toggle-labels');
      labelsBtn.addEventListener('click', () => {
        window.HLSF.config.showLabels = !window.HLSF.config.showLabels;
        labelsBtn.textContent = window.HLSF.config.showLabels ? 'Labels: On' : 'Labels: Off';
        debouncedLegacyRender();
      });

      const bgBtn = document.getElementById('hlsf-toggle-bg');
      bgBtn.addEventListener('click', () => {
        window.HLSF.config.whiteBg = !window.HLSF.config.whiteBg;
        bgBtn.textContent = window.HLSF.config.whiteBg ? 'BG: Light' : 'BG: Dark';
        debouncedLegacyRender();
      });
      
      // Mouse interaction
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      
      window.HLSF.canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      window.HLSF.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          window.HLSF.config.tx += dx;
          window.HLSF.config.ty += dy;
          lastX = e.clientX;
          lastY = e.clientY;
          debouncedLegacyRender();
        }
      });
      
      window.HLSF.canvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      window.HLSF.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        window.HLSF.config.scale *= factor;
        debouncedLegacyRender();
      }, { passive: false });
      
      // Center view
      window.HLSF.config.tx = window.HLSF.canvas.width / 2;
      window.HLSF.config.ty = window.HLSF.canvas.height / 2;
      
      // Build nodes
      window.HLSF.nodes = hlsfNodes;
      
      // Initial render
      renderLegacyHLSF();

      // Start animation
      animateLegacyHLSF();
      
      logSuccess(`HLSF visualization initialized with ${hlsfNodes.length} token matrices`);
      
      } catch (err) {
        logError(`Failed to initialize HLSF canvas: ${err.message}`);
        console.error('HLSF canvas error:', err);
        throw err;
      }
    }

    function strokePolygon(ctx, verts) {
      if (!verts || verts.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(verts[0][0], verts[0][1]);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i][0], verts[i][1]);
      ctx.closePath();
      ctx.stroke();
    }

    function strokeTriangles(ctx, tris) {
      if (!tris) return;
      for (const t of tris) strokePolygon(ctx, t);
    }

    function worldToScreen(x, y) {
      const sx = x * (200 * window.HLSF.config.scale) + window.HLSF.config.tx;
      const sy = -y * (200 * window.HLSF.config.scale) + window.HLSF.config.ty;
      return [sx, sy];
    }

    function renderLegacyHLSF() {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not initialized for renderHLSF');
        return;
      }

      try {
        const ctx = window.HLSF.ctx;
        const width = window.HLSF.canvas.width;
        const height = window.HLSF.canvas.height;
        const theme = window.HLSF.config.whiteBg
          ? { bg: '#ffffff', fg: '#000000', grid: 'rgba(0, 0, 0, 0.05)' }
          : { bg: '#0a0a0a', fg: '#ffffff', grid: 'rgba(0, 255, 136, 0.05)' };
        const nodeScale = clampNodeSize(window.HLSF.config.nodeSize);
        const edgeColorMode = normalizeEdgeColorMode(window.HLSF.config.edgeColorMode);
        const edgeWidth = clampEdgeWidth(window.HLSF.config.edgeWidth);
        const effectiveEdgeWidth = edgeWidth * Math.max(0.6, window.HLSF.config.scale || 1);

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = theme.bg;
        ctx.strokeStyle = theme.fg;
        ctx.lineWidth = 1;

        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = theme.grid;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        ctx.strokeStyle = theme.fg;
        if (window.HLSF.config.fillFaces === true) {
          /* intentionally unused now */
        }

        for (const node of window.HLSF.nodes) {
          let triangles = Array.isArray(node.triangles) ? node.triangles : [];
          let vertices = Array.isArray(node.vertices) ? node.vertices : [];
          let centerPoint = Array.isArray(node.center) ? node.center : [0, 0];
          const nodeColor = Array.isArray(node.color) ? node.color : [0, 255, 136];
          const [r, g, b] = nodeColor;

          if (window.HLSF.config.emergentActive) {
            const angle = window.HLSF.state?.emergentRot ?? 0;
            triangles = rotateTrianglesAround(triangles, node.center, angle);
            vertices = rotatePointsAround(vertices, node.center, angle);
          } else if (window.HLSF.config.rotationActive) {
            const angle = window.HLSF.state?.globalRot ?? 0;
            triangles = rotateTrianglesAround(triangles, [0, 0], angle);
            vertices = rotatePointsAround(vertices, [0, 0], angle);
            centerPoint = rotatePointsAround([node.center], [0, 0], angle)[0];
          }

          const scalePivot = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
            ? centerPoint
            : node.center;
          if (Math.abs(nodeScale - 1) > 1e-3) {
            triangles = scaleTrianglesAround(triangles, scalePivot, nodeScale);
            vertices = scalePointsAround(vertices, scalePivot, nodeScale);
          }

          triangles = Array.isArray(triangles) ? triangles : [];
          vertices = Array.isArray(vertices) ? vertices : [];

          const screenTriangles = triangles.map(tri => tri.map(([x, y]) => worldToScreen(x, y)));
          const screenVertices = vertices.map(([x, y]) => worldToScreen(x, y));

          ctx.globalAlpha = baseAlpha();
          ctx.strokeStyle = theme.fg;
          ctx.lineWidth = effectiveEdgeWidth;
          ctx.save();
          if (window.HLSF.config.showNodeGlow) {
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.35)`;
            ctx.shadowBlur = 16 * Math.max(1, window.HLSF.config.scale || 1);
          }

          strokePolygon(ctx, screenVertices);
          strokeTriangles(ctx, screenTriangles);
          ctx.restore();

          if (window.HLSF.config.showEdges && screenVertices.length > 1) {
            const anchorIndex = typeof node.anchorIndex === 'number' ? node.anchorIndex : 0;
            const anchor = screenVertices[anchorIndex];
            for (let i = 0; i < screenVertices.length; i++) {
              if (i === anchorIndex) continue;
              const [vx, vy] = screenVertices[i];
              const strokeColor = nodeEdgeStrokeColor(node, i, edgeColorMode) || theme.fg;
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = effectiveEdgeWidth;
              ctx.beginPath();
              ctx.moveTo(anchor[0], anchor[1]);
              ctx.lineTo(vx, vy);
              ctx.stroke();
            }
            ctx.strokeStyle = theme.fg;
          }

          ctx.globalAlpha = 1.0;

          if (window.HLSF.config.showLabels) {
            const centerForLabel = (window.HLSF.config.rotationActive && !window.HLSF.config.emergentActive)
              ? centerPoint
              : node.center;
            const [sx, sy] = worldToScreen(centerForLabel[0], centerForLabel[1]);
            ctx.save();
            if (window.HLSF.config.showNodeGlow) {
              ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
              ctx.shadowBlur = 18 * Math.max(1, window.HLSF.config.scale || 1);
            }
            ctx.globalAlpha = baseAlpha();
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
            ctx.font = `${Math.max(12, 20 * window.HLSF.config.scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.glyph, sx, sy);
            ctx.restore();

            ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.font = `${Math.max(9, 11 * window.HLSF.config.scale)}px Fira Code, monospace`;
            ctx.fillText(node.token, sx, sy + 25 * window.HLSF.config.scale);
            ctx.globalAlpha = 1.0;
          }
        }

        ctx.globalAlpha = 1.0;
        ctx.fillStyle = window.HLSF.config.whiteBg ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
        ctx.font = '12px Fira Code, monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Nodes: ${window.HLSF.nodes.length} | Zoom: ${window.HLSF.config.scale.toFixed(2)}x`, 10, 20);

      } catch (err) {
        console.error('Error rendering HLSF:', err);
      }
    }

    const debouncedLegacyRender = debounce(() => {
      if (window.HLSF?.currentGraph) {
        drawComposite(window.HLSF.currentGraph, { glyphOnly: window.HLSF.currentGlyphOnly === true });
      } else {
        renderLegacyHLSF();
      }
    }, 16);

    let _legacyLast = null;
    function animateLegacyHLSF(now) {
      if (!window.HLSF.canvas || !window.HLSF.ctx) {
        console.warn('Canvas not ready for animation');
        return;
      }

      try {
        const timestamp = typeof now === 'number' ? now : performance.now();
        const last = _legacyLast ?? timestamp;
        const dt = (timestamp - last) / 1000;
        _legacyLast = timestamp;
        stepRotation(dt);

        if (window.HLSF.config.rotationActive || window.HLSF.config.emergentActive) {
          renderLegacyHLSF();
        }
      } catch (err) {
        console.error('Error in HLSF animation:', err);
      }

      window.HLSF.animationFrame = requestAnimationFrame(animateLegacyHLSF);
    }

    function stopLegacyHLSFAnimation() {
      try {
        if (window.HLSF && window.HLSF.animationFrame) {
          cancelAnimationFrame(window.HLSF.animationFrame);
          window.HLSF.animationFrame = null;
        }
        if (window.HLSF && window.HLSF.config) {
          window.HLSF.config.rotationActive = false;
          window.HLSF.config.emergentActive = false;
        }
        _legacyLast = null;
      } catch (err) {
        console.warn('Error stopping HLSF animation:', err);
      }
    }

    window.HLSF.rendering = {
      render: renderLegacyHLSF,
      animate: animateLegacyHLSF,
      stop: stopLegacyHLSFAnimation,
    };
    function computeRelHistogramEntries(db) {
      const hist = new Map();
      for (const rec of db.full_token_data || []) {
        const rels = rec?.relationships || {};
        for (const key of Object.keys(rels)) {
          const glyph = normalizeRelKeyForStats(key);
          if (!glyph) continue;
          const edges = Array.isArray(rels[key]) ? rels[key] : [];
          if (!edges.length) continue;
          hist.set(glyph, (hist.get(glyph) || 0) + edges.length);
        }
      }
      return [...hist.entries()].sort((a, b) => b[1] - a[1]);
    }

    function computeRelHistogram(db, entries){
      const base = Array.isArray(entries) ? entries : computeRelHistogramEntries(db);
      return base.map(([glyph, count]) => renderRelTypeRow(glyph, count));
    }

    function analyzeDatabaseMetadata() {
      const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
      const tokens = [];
      const tokenFrequency = new Map();
      let totalAttentionScore = 0;
      let oldestToken = null;
      let newestToken = null;

      for (const key of keys) {
        try {
          const data = safeStorageGet(key);
          tokens.push(data);

          // Track oldest and newest
          if (data.cached_at) {
            const timestamp = new Date(data.cached_at);
            if (!oldestToken || timestamp < new Date(oldestToken.cached_at)) {
              oldestToken = data;
            }
            if (!newestToken || timestamp > new Date(newestToken.cached_at)) {
              newestToken = data;
            }
          }

          // Count relationships
          const rels = data.relationships || {};
          for (const [relType, edges] of Object.entries(rels)) {
            if (!Array.isArray(edges)) continue;
            const glyph = normalizeRelKeyForStats(relType);
            if (!glyph) continue;

            // Track token frequency across relationships
            for (const edge of edges) {
              const token = edge.token?.toLowerCase();
              if (token) {
                tokenFrequency.set(token, (tokenFrequency.get(token) || 0) + 1);
              }
            }
          }

          if (data.attention_score) {
            totalAttentionScore += data.attention_score;
          }
        } catch (err) {
          console.error('Failed to parse token:', key, err);
        }
      }

      const relHistogramEntries = computeRelHistogramEntries({ full_token_data: tokens });
      const relHistogramRows = computeRelHistogram(null, relHistogramEntries);
      const totalRelationships = relHistogramEntries.reduce((sum, [, count]) => sum + count, 0);
      const topRelationships = relHistogramEntries.slice(0, 10);
      const topRelationshipRows = relHistogramRows.slice(0, 10);

      const topTokens = Array.from(tokenFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);

      const highAttentionTokens = tokens
        .filter(t => t.attention_score)
        .sort((a, b) => b.attention_score - a.attention_score)
        .slice(0, 10);

      return {
        totalTokens: tokens.length,
        totalRelationships,
        avgAttentionScore: tokens.length > 0 ? (totalAttentionScore / tokens.length).toFixed(3) : 0,
        topRelationships,
        topRelationshipRows,
        relHistogramRows,
        topTokens,
        highAttentionTokens,
        oldestToken,
        newestToken,
        estimatedValue: tokens.length * CONFIG.ESTIMATED_COST_PER_API_CALL,
        rawData: tokens
      };
    }

    function showDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const maturityLevel = metadata.totalTokens > 100 ? 'Mature' : metadata.totalTokens > 20 ? 'Growing' : 'Early';
      const maturityColor = metadata.totalTokens > 100 ? 'var(--success)' : metadata.totalTokens > 20 ? 'var(--warning)' : 'var(--accent)';
      
      addLog(`
        <div class="section-divider"></div>
        <div class="section-title">üìä Collective Database Metadata</div>
        
        <div class="adjacency-insight">
          <strong>üåê Knowledge Base Status:</strong> <span style="color: ${maturityColor}; font-weight: bold;">${maturityLevel}</span><br>
          <small style="opacity: 0.8;">
            ${metadata.totalTokens < 20 ? 
              'Building foundational knowledge. Each query adds to the collective intelligence.' :
              metadata.totalTokens < 100 ?
              'Database is maturing. Cache hit rate improving with each session.' :
              'Mature knowledge base. Most queries benefit from cached insights.'}
          </small>
        </div>

        <div class="adjacency-insight">
          <strong>üíæ Database Size:</strong><br>
          ‚Ä¢ Total cached tokens: <strong>${metadata.totalTokens}</strong><br>
          ‚Ä¢ Total relationships: <strong>${metadata.totalRelationships}</strong><br>
          ‚Ä¢ Average attention score: <strong>${metadata.avgAttentionScore}</strong><br>
          ‚Ä¢ Network density: <strong>${(metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)}</strong> edges/token<br>
          ‚Ä¢ Estimated saved cost: <strong>${formatCurrency(Math.ceil(metadata.estimatedValue * 100))}</strong>
        </div>

        <div class="adjacency-insight">
          <strong>üìà Most Common Relationship Types:</strong><br>
          ${metadata.topRelationshipRows.map(row =>
            `‚Ä¢ <span class="token-highlight">${row}</span>`
          ).join('<br>')}
          ${metadata.topRelationshipRows.length === 0 ? '<em>No relationships cached yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>üî• Most Referenced Tokens (Hub Concepts):</strong><br>
          <small style="opacity: 0.8;">These tokens appear most frequently across relationships - they represent core concepts in the knowledge graph.</small><br><br>
          ${metadata.topTokens.slice(0, 10).map(([token, count]) => 
            `‚Ä¢ <span class="token-highlight">${token}</span>: ${count} references`
          ).join('<br>')}
          ${metadata.topTokens.length === 0 ? '<em>No hub concepts identified yet</em>' : ''}
        </div>

        <div class="adjacency-insight">
          <strong>‚≠ê Highest Attention Tokens:</strong><br>
          <small style="opacity: 0.8;">Tokens with the strongest weighted relationships - highly salient concepts.</small><br><br>
          ${metadata.highAttentionTokens.map(t => 
            `‚Ä¢ <span class="token-highlight">${t.token}</span>: ${t.attention_score} (${t.total_relationships || 0} edges)`
          ).join('<br>')}
          ${metadata.highAttentionTokens.length === 0 ? '<em>No high-attention tokens yet</em>' : ''}
        </div>

        ${metadata.oldestToken ? `
        <div class="adjacency-insight">
          <strong>üìÖ Database Timeline:</strong><br>
          ‚Ä¢ Oldest entry: <strong>${metadata.oldestToken.token}</strong> (${new Date(metadata.oldestToken.cached_at).toLocaleString()})<br>
          ‚Ä¢ Newest entry: <strong>${metadata.newestToken.token}</strong> (${new Date(metadata.newestToken.cached_at).toLocaleString()})
        </div>
        ` : ''}

        <details>
          <summary>üìä View knowledge graph analytics</summary>
          <pre>${JSON.stringify({
            database_maturity: maturityLevel,
            network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
            top_5_relationship_types: metadata.topRelationships.slice(0, 5).map(([rel]) => relDisplay(rel)),
            relationship_histogram_named: metadata.relHistogramRows,
            top_5_hub_concepts: metadata.topTokens.slice(0, 5).map(([token]) => token),
            growth_metrics: {
              tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
              avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2)
            }
          }, null, 2)}</pre>
        </details>

        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,255,136,0.05); border-radius: 8px; font-size: 0.9rem;">
          üí° <strong>Insight:</strong> This metadata represents the collective intelligence being built. 
          In a server deployment, this would be shared across all users, with each query contributing 
          to a growing knowledge base that makes future queries faster and cheaper. The database also 
          powers the symbolic glyph encryption system for secure inter-system communication.
        </div>
      `);
    }

    function exportDatabaseMetadata() {
      const metadata = analyzeDatabaseMetadata();
      
      const exportData = {
        export_timestamp: new Date().toISOString(),
        readme: {
          description: "HLSF Cognition Engine - Collective Database Metadata Export",
          purpose: "This export contains the complete adjacency token database and analytics. It represents the collective intelligence built through token relationship analysis.",
          usage: "This data can be imported into a server-side database to bootstrap a new deployment or shared for analysis.",
          version: "2.0"
        },
        database_stats: {
          total_tokens: metadata.totalTokens,
          total_relationships: metadata.totalRelationships,
          avg_attention_score: metadata.avgAttentionScore,
          estimated_value_usd: metadata.estimatedValue.toFixed(2),
          maturity_level: metadata.totalTokens > 100 ? 'mature' : metadata.totalTokens > 20 ? 'growing' : 'early'
        },
        relationship_distribution: Object.fromEntries(metadata.topRelationships),
        relationship_distribution_named: Object.fromEntries(metadata.topRelationships.map(([glyph, count]) => [relDisplay(glyph), count])),
        hub_concepts: Object.fromEntries(metadata.topTokens),
        high_attention_tokens: metadata.highAttentionTokens.map(t => ({
          token: t.token,
          attention_score: t.attention_score,
          total_relationships: t.total_relationships
        })),
        knowledge_graph_metrics: {
          network_density: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(3),
          avg_edges_per_token: (metadata.totalRelationships / Math.max(metadata.totalTokens, 1)).toFixed(2),
          tokens_per_relationship: (metadata.totalTokens / Math.max(metadata.totalRelationships, 1)).toFixed(3),
          oldest_entry: metadata.oldestToken?.cached_at,
          newest_entry: metadata.newestToken?.cached_at,
          date_range_days: metadata.oldestToken && metadata.newestToken ? 
            Math.ceil((new Date(metadata.newestToken.cached_at) - new Date(metadata.oldestToken.cached_at)) / (1000 * 60 * 60 * 24)) : 0
        },
        full_token_data: metadata.rawData
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `HLSF_Database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      logSuccess(`Database metadata exported: ${metadata.totalTokens} tokens, ${metadata.totalRelationships} relationships, ${(new Blob([JSON.stringify(exportData)]).size / 1024).toFixed(1)}KB`);
    }

    async function importHLSFDBFromFile(file) {
      const txt = await file.text();
      const count = loadDbObject(txt);
      const db = getDb();
      if (!db) return;
      const seen = [];
      for (const rec of db.full_token_data || []) {
        safeStorageSet(TOKEN_CACHE_PREFIX + rec.token, JSON.stringify(rec));
        seen.push(rec.token);
      }
      safeStorageSet(DB_INDEX_KEY, JSON.stringify(seen));
      state.hlsfReady = false;
      window.HLSF_GRAPH = null;
      updateStats();
      addLog(`üìä Import: ${seen.length} tokens (${count} normalized).`);
      updateHeaderCounts();
    }

    function importDatabaseData(data, source = 'file') {
      try {
        const normalizedCount = loadDbObject(data);
        const db = getDb();
        if (!db) throw new Error('Failed to hydrate database');

        state.hlsfReady = false;
        let totalTokens = 0;
        try {
          totalTokens = loadDbObject(data);
        } catch (err) {
          console.warn('Failed to persist raw DB snapshot:', err);
        }

        const tokenData = data.full_token_data;
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        const seen = new Set();

        for (const token of tokenData) {
          if (!token?.token) continue;

          const key = getCacheKey(token.token);
          const existing = safeStorageGet(key);
          seen.add(token.token);

          if (existing) {
            const existingData = typeof existing === 'string' ? JSON.parse(existing) : existing;
            const importedDate = new Date(token.cached_at || 0);
            const existingDate = new Date(existingData?.cached_at || 0);

            if (importedDate > existingDate) {
              safeStorageSet(key, JSON.stringify(token));
              updated++;
            } else {
              skipped++;
            }
          } else {
            safeStorageSet(key, JSON.stringify(token));
            imported++;
          }
        }

        if (!totalTokens) {
          safeStorageSet(DB_INDEX_KEY, JSON.stringify(Array.from(seen)));
        }
        updateStats();

        const summary = [];
        if (imported > 0) summary.push(`${imported} new tokens imported`);
        if (updated > 0) summary.push(`${updated} tokens updated`);
        if (skipped > 0) summary.push(`${skipped} existing tokens kept`);
        if (!summary.length) summary.push('no cache changes');

        logSuccess(`Database imported from ${source}: ${summary.join(', ')}, normalized ${normalizedCount} tokens`);

        if (data?.database_stats) {
          addLog(`<div class="adjacency-insight">
            üìä <strong>Import Summary:</strong><br>
            ‚Ä¢ Source maturity: ${data.database_stats.maturity_level}<br>
            ‚Ä¢ Total tokens in source: ${data.database_stats.total_tokens}<br>
            ‚Ä¢ Total relationships: ${data.database_stats.total_relationships}<br>
            ‚Ä¢ Estimated value: ${data.database_stats.estimated_value_usd}
          </div>`);
        }

        return { imported, skipped, updated, seen: Array.from(seen), normalizedCount };
      } catch (err) {
        logError(`Import failed: ${err.message || err}`);
        return null;
      }
    }

    // ============================================
    // COMMANDS
    // ============================================
    const COMMANDS = window.COMMANDS = window.COMMANDS || Object.create(null);

    function registerCommand(name, handler) {
      if (!name || typeof handler !== 'function') return;
      const key = name.startsWith('/') ? name.toLowerCase() : `/${name.toLowerCase()}`;
      COMMANDS[key] = handler;
    }

    async function tryBootstrapDb() {
      if (getDb()) return true;

      let href = null;
      try {
        const url = new URL(location.href);
        href = url.searchParams.get('db') || window.HLSF.config.bootstrapDbUrl;
      } catch (err) {
        console.warn('Failed to parse bootstrap URL:', err);
      }

      if (!href) return false;

      try {
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
        return true;
      } catch (e) {
        logStatus(`Bootstrap DB fetch failed: ${String(e.message || e)}`);
        return false;
      }
    }

    function dbIndex() {
      const db = getDb();
      const idx = new Map();
      (db?.full_token_data || []).forEach(record => {
        if (record?.token) idx.set(record.token, record);
      });
      return idx;
    }

    function tokenWeight(token, idx) {
      const rec = idx.get(token);
      if (!rec) return 0.5;
      const relationships = Object.values(rec.relationships || {});
      const weights = [];
      for (const arr of relationships) {
        if (!Array.isArray(arr)) continue;
        for (const rel of arr) {
          const w = rel?.weight;
          if (typeof w === 'number' && Number.isFinite(w)) weights.push(w);
        }
      }
      if (!weights.length) return 0.5;
      const maxW = Math.max(...weights);
      const meanW = weights.reduce((sum, value) => sum + value, 0) / weights.length;
      return Math.max(0.01, Math.min(1.0, 0.6 * maxW + 0.4 * meanW));
    }

    function hashGlyphForToken(token) {
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i = 0; i < token.length; i++) {
        h ^= token.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return GLYPH_SET[h % GLYPH_SET.length];
    }

    function glyphForToken(token) {
      if (!TokenToGlyph.has(token)) {
        // Ensure existing ledger mappings are available before hashing
        if (!TokenToGlyph.size) loadLedger();
      }
      return TokenToGlyph.get(token) || hashGlyphForToken(token);
    }

    function ledgerAdd(ledger, glyph, token, weight) {
      if (!ledger.glyph_map[glyph]) ledger.glyph_map[glyph] = [];
      const arr = ledger.glyph_map[glyph];
      const numericWeight = Number(weight);
      const now = Date.now();
      const found = arr.find(entry => entry.token === token);
      if (found) {
        found.w = numericWeight;
        found.t = now;
      } else {
        arr.push({ token, w: numericWeight, t: now });
      }
      TokenToGlyph.set(token, glyph);
      if (!GlyphToToken.has(glyph)) GlyphToToken.set(glyph, new Set());
      GlyphToToken.get(glyph).add(token);
      return ledger;
    }

    function ledgerBestToken(ledger, glyph, weight) {
      const arr = Array.isArray(ledger.glyph_map[glyph]) ? ledger.glyph_map[glyph] : [];
      if (!arr.length) return null;
      let best = arr[0];
      let bestDistance = Math.abs((best?.w ?? 0) - weight);
      for (let i = 1; i < arr.length; i++) {
        const candidate = arr[i];
        const distance = Math.abs((candidate?.w ?? 0) - weight);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = candidate;
        }
      }
      return best?.token || null;
    }

    function parseGlyphFloatSequence(input) {
      const tokens = [];
      if (!input) return tokens;
      const segments = input.trim().split(/\s+/);
      for (const segment of segments) {
        if (!segment) continue;
        let cursor = 0;
        while (cursor < segment.length) {
          let glyph = null;
          for (const candidate of GLYPH_SET) {
            if (segment.startsWith(candidate, cursor)) {
              if (!glyph || candidate.length > glyph.length) glyph = candidate;
            }
          }
          if (!glyph) break;
          cursor += glyph.length;
          let nextGlyphIndex = segment.length;
          for (const candidate of GLYPH_SET) {
            const idx = segment.indexOf(candidate, cursor);
            if (idx !== -1 && idx < nextGlyphIndex) nextGlyphIndex = idx;
          }
          const numberPortion = segment.slice(cursor, nextGlyphIndex);
          cursor = nextGlyphIndex;
          let weight = parseFloat(numberPortion);
          if (!Number.isFinite(weight)) weight = 0.5;
          tokens.push({ glyph, weightStr: numberPortion, weight });
        }
      }
      return tokens;
    }

    function encryptTextToGlyphs(plain, options = {}) {
      const { persistUnknown = true } = options || {};
      const idx = dbIndex();
      const ledger = loadLedger();
      const words = (plain || '').trim().split(/\s+/).filter(Boolean);
      const out = [];
      const unknown = [];
      let covered = 0;
      let mutated = false;

      for (const word of words) {
        const glyph = glyphForToken(word);
        const weight = tokenWeight(word, idx);
        if (persistUnknown || idx.has(word)) {
          ledgerAdd(ledger, glyph, word, weight);
          mutated = true;
        }
        out.push(glyph + NUM_FMT(weight));
        if (idx.has(word)) covered++;
        else unknown.push(word);
      }

      if (mutated) saveLedger(ledger);
      const encrypted = out.join(GLYPH_SEP);
      const coverage = words.length ? (100 * covered / words.length).toFixed(1) : '0.0';
      return { encrypted, coverage, unknown };
    }

    function decryptGlyphsToText(cipher) {
      const ledger = loadLedger();
      const pairs = parseGlyphFloatSequence(cipher || '');
      const out = [];
      const unresolved = [];
      let resolved = 0;

      for (const pair of pairs) {
        const token = ledgerBestToken(ledger, pair.glyph, pair.weight);
        if (token) {
          out.push(token);
          resolved++;
        } else {
          out.push('<?>');
          unresolved.push({ glyph: pair.glyph, weight: pair.weight });
        }
      }

      const coverage = pairs.length ? (100 * resolved / pairs.length).toFixed(1) : '0.0';
      return { decrypted: out.join(' '), coverage, unresolved };
    }

    function cmdLedger(arg) {
      const ledger = loadLedger();
      const [sub] = (arg || '').trim().split(/\s+/);
      if (sub === 'export') {
        const blob = new Blob([JSON.stringify(ledger, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `glyph_ledger_${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);
        return logFinal('Ledger exported.');
      }
      if (sub === 'import') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = async e => {
          try {
            const file = e.target.files?.[0];
            if (!file) return;
            const text = await file.text();
            const imported = JSON.parse(text);
            hydrateLedgerMaps(imported);
            saveLedger(imported);
            logFinal('Ledger imported.');
          } catch (err) {
            logError(`Ledger import failed: ${err.message}`);
          }
        };
        input.click();
        return;
      }

      const lines = [];
      const map = ledger.glyph_map || {};
      const glyphs = Object.keys(map).sort();
      for (const glyph of glyphs) {
        const arr = Array.isArray(map[glyph]) ? map[glyph] : [];
        if (!arr.length) continue;
        const latest = [...arr].sort((a, b) => (b?.t ?? 0) - (a?.t ?? 0))[0];
        const weightStr = NUM_FMT(latest?.w ?? 0);
        lines.push(`${glyph} ${weightStr} ‚Üí ${latest?.token || ''}`.trim());
      }
      return logFinal(lines.length ? lines.join('\n') : 'Ledger empty.');
    }

    function cmdGlyph(argsStr) {
      const idx = dbIndex();
      const tokens = (argsStr || '').trim().split(/\s+/).filter(Boolean);
      if (!tokens.length) {
        logError('Usage: /glyph <token1 token2 ...>');
        return;
      }
      const ledger = loadLedger();
      const outputs = [];
      for (const token of tokens) {
        const glyph = glyphForToken(token);
        const weight = tokenWeight(token, idx);
        ledgerAdd(ledger, glyph, token, weight);
        outputs.push(glyph + NUM_FMT(weight));
      }
      saveLedger(ledger);
      logFinal(outputs.join(GLYPH_SEP));
    }

    function cmdEncrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /encrypt <text>');
        return;
      }
      const { encrypted, coverage } = encryptTextToGlyphs(text, { persistUnknown: true });
      logFinal(`üîê ${encrypted}\nCoverage: ${coverage}%`);
    }

    function cmdDecrypt(rest) {
      const text = (rest || '').trim();
      if (!text) {
        logError('Usage: /decrypt <glyph+float sequence>');
        return;
      }
      const { decrypted, coverage } = decryptGlyphsToText(text);
      logFinal(`üîì ${decrypted}\nCoverage: ${coverage}%`);
    }


    async function cmdImport() {
      const input = document.getElementById('db-file');
      if (!input) {
        logError('File input unavailable');
        return;
      }
      input.value = '';
      input.onchange = async e => {
        try {
          const f = e.target.files?.[0];
          if (!f) return;
          const text = await f.text();
          const n = loadDbObject(text);
          logFinal(`DB loaded. Tokens: ${n}`);
        } catch (err) {
          logError(String(err.message || err));
        } finally {
          e.target.value = '';
          input.onchange = null;
        }
      };
      input.click();
    }

    async function cmdLoadDb(arg) {
      try {
        const href = (arg || '').trim() || window.HLSF.config.bootstrapDbUrl;
        if (!href) throw new Error('Usage: /loaddb <url-or-path>');
        const res = await fetch(href, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const n = loadDbObject(text);
        logFinal(`DB loaded. Tokens: ${n}`);
      } catch (e) {
        logError(`load failed: ${String(e.message || e)}`);
      }
    }

    async function cmdHlsf(rawArgs) {
      if (!getDb()) {
        const ok = await tryBootstrapDb();
        if (!ok) {
          logError('No DB loaded. Use /loaddb or /import.');
          return;
        }
      }

      const args = parseHlsfArgs(rawArgs);
      const { seeds, idx, glyphOnly } = seedsForMode(args);
      if (!seeds?.length) {
        logError('DB is empty. Use /loaddb or /import.');
        return;
      }
      if (!ensureHLSFCanvas()) {
        logError('Unable to initialize canvas for HLSF rendering.');
        return;
      }
      const depth = Number.isFinite(args.depth) ? args.depth : 3;
      const graph = assembleGraphFromSeeds(seeds, depth, idx);
      window.HLSF.lastCommand = {
        rawArgs,
        args,
        seeds: [...seeds],
        idx,
        glyphOnly: glyphOnly === true,
        depth,
      };
      animateComposite(graph, glyphOnly === true);
      syncHlsfControls(document.getElementById('hlsf-canvas-container'));
      const suffix = rawArgs ? ` ${rawArgs}` : '';
      logFinal(`/hlsf${suffix} ‚Üí nodes ${graph.nodes.size}, edges ${graph.edges.length}, seeds ${seeds.length}`);
    }

    function rebuildHlsfFromLastCommand(logUpdate = false) {
      const last = window.HLSF?.lastCommand;
      if (!last || !last.idx || !Array.isArray(last.seeds) || !last.seeds.length) return null;
      const depth = Number.isFinite(last.depth) ? last.depth : 3;
      const graph = assembleGraphFromSeeds(last.seeds, depth, last.idx);
      animateComposite(graph, last.glyphOnly === true);
      syncHlsfControls(document.getElementById('hlsf-canvas-container'));
      if (logUpdate) {
        const suffix = last.rawArgs ? ` ${last.rawArgs}` : '';
        logStatus(`‚Üª /hlsf${suffix} ‚Üí nodes ${graph.nodes.size}, edges ${graph.edges.length}, seeds ${last.seeds.length}`);
      }
      return graph;
    }

    function cmdScheme(arg) {
      const mode = (arg || '').toLowerCase();
      window.HLSF.config.whiteBg = mode === 'white';
      if (window.HLSF.currentGraph) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Scheme: ${window.HLSF.config.whiteBg ? 'Black lines on white' : 'White lines on black'}`);
    }

    function cmdSpin(arg) {
      const value = (arg || '').toLowerCase();
      window.HLSF.config.rotationActive = /^(on|true|1)$/i.test(value) || (!value && true);
      if (window.HLSF.currentGraph && !_anim) {
        animateHLSF(window.HLSF.currentGraph, window.HLSF.currentGlyphOnly === true);
      }
      logStatus(`Rotation: ${window.HLSF.config.rotationActive ? 'on' : 'off'}`);
    }

    function cmdOmega(arg) {
      const w = parseFloat(arg);
      if (!Number.isFinite(w)) {
        logError('Usage: /omega <rad/s>');
        return;
      }
      window.HLSF.config.rotationOmega = w;
      const slider = document.getElementById('hlsf-rotation-speed');
      const speedVal = document.getElementById('hlsf-speed-val');
      if (slider) slider.value = w.toFixed(2);
      if (speedVal) speedVal.textContent = w.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Rotation omega = ${w.toFixed(2)} rad/s`);
    }

    function cmdAlpha(arg) {
      const parsed = parseFloat(arg);
      if (!Number.isFinite(parsed)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      const a = clampAlpha(parsed);
      if (!Number.isFinite(a)) {
        logError('Usage: /alpha <0.01..0.99>');
        return;
      }
      window.HLSF.config.alpha = a;
      const slider = document.getElementById('hlsf-alpha');
      const alphaVal = document.getElementById('hlsf-alpha-val');
      if (slider) slider.value = a.toFixed(2);
      if (alphaVal) alphaVal.textContent = a.toFixed(2);
      debouncedLegacyRender();
      logFinal(`Alpha = ${a.toFixed(2)}`);
    }

    async function cmd_import() {
      await cmdImport();
    }

    async function cmd_loaddb(args) {
      const joined = Array.isArray(args) ? args.join(' ') : args;
      await cmdLoadDb(joined);
    }

    function getRelationshipPriority(relType) {
      if (RELATIONSHIP_PRIORITIES instanceof Map) {
        return RELATIONSHIP_PRIORITIES.get(relType) ?? 1;
      }
      if (typeof RELATIONSHIP_PRIORITIES === 'object' && RELATIONSHIP_PRIORITIES !== null) {
        return RELATIONSHIP_PRIORITIES[relType] ?? 1;
      }
      return 1;
    }

    function* iterTokenRecords() {
      const db = getDb();
      if (db?.full_token_data?.length) {
        for (const rec of db.full_token_data) yield rec;
        return;
      }
      const idxRaw = safeStorageGet(DB_INDEX_KEY, []);
      const idx = Array.isArray(idxRaw) ? idxRaw : [];
      const keys = idx.length ? idx.map(t => TOKEN_CACHE_PREFIX + t)
                              : safeStorageKeys(TOKEN_CACHE_PREFIX);
      for (const k of keys) {
        const rec = safeStorageGet(k);
        if (rec) yield rec;
      }
    }

    function buildHLSF() {
      const pri = RELATIONSHIP_PRIORITIES || {};
      const nodes = [];
      const edges = [];
      let maxAttention = 0;

      for (const rec of iterTokenRecords()) {
        if (!rec || !rec.token || !rec.relationships) continue;
        let attention = 0;

        for (const rawKey of Object.keys(rec.relationships)) {
          const type = normRelKey(rawKey);
          const p = (pri[type] ?? pri.get?.(type)) ?? 1;
          for (const rel of rec.relationships[rawKey]) {
            const w = rel.weight ?? 0;
            attention += w * p;
            edges.push({ source: rec.token, target: rel.token, type, w });
          }
        }
        maxAttention = Math.max(maxAttention, attention);
        nodes.push({ id: rec.token, attention });
      }

      const norm = maxAttention || 1;
      for (const n of nodes) n.attention = +(n.attention / norm).toFixed(3);

      return { nodes, edges, meta: { nodeCount: nodes.length, edgeCount: edges.length } };
    }

    async function cmd_hlsf() {
      await cmdHlsf('');
    }

    registerCommand('/import', cmd_import);
    registerCommand('/loaddb', cmd_loaddb);
    window.COMMANDS = COMMANDS;
    // Router guard (prevents duplicate logs)
    if (!COMMANDS.__hlsf_bound) {
      COMMANDS['/hlsf'] = cmd_hlsf;
      COMMANDS.__hlsf_bound = true;
    }
    registerCommand('/visualize', cmd_hlsf);

    async function dispatchCommand(input) {
      const trimmed = (input || '').trim();
      if (!trimmed) return false;

      const parts = trimmed.split(/\s+/);
      const [raw, ...rest] = parts;
      const command = raw.startsWith('/') ? raw.toLowerCase() : `/${raw.toLowerCase()}`;
      const arg = rest.join(' ').trim();

      if (command === '/import') { await cmdImport(); return true; }
      if (command === '/loaddb') { await cmdLoadDb(arg); return true; }
      if (command === '/hlsf') { await cmdHlsf(arg); return true; }
      if (command === '/scheme') { cmdScheme(arg || 'black'); return true; }
      if (command === '/spin') { cmdSpin(arg || 'on'); return true; }
      if (command === '/omega') { cmdOmega(arg); return true; }
      if (command === '/alpha') { cmdAlpha(arg); return true; }

      return false;
    }

    function isCommand(input) { return input.startsWith('/'); }

    async function handleCommand(cmd) {
      const trimmed = cmd.trim();
      const handled = await safeAsync(() => dispatchCommand(trimmed), `Command dispatch failed for ${trimmed}`);
      if (handled) return;

      const segments = trimmed.slice(1).split(/\s+/);
      const [command, ...args] = segments;

      if (!command) {
        logError('Unknown command');
        return;
      }

      const normalized = `/${command.toLowerCase()}`;
      const mapped = COMMANDS[normalized];
      if (mapped) {
        await mapped(args, trimmed);
        return;
      }

      switch (command.toLowerCase()) {
        case 'clear':
          elements.log.innerHTML = '';
          logSuccess('Log cleared');
          break;
        case 'reset':
          if (confirm('Clear all cached data?')) {
            const keys = safeStorageKeys(TOKEN_CACHE_PREFIX);
            keys.forEach(k => safeStorageRemove(k));
            safeStorageRemove(DB_INDEX_KEY);
            state.hlsfReady = false;
            window.HLSF_GRAPH = null;
            if (window.HLSF) {
              window.HLSF.matrices = null;
              window.HLSF.layoutCache = null;
              window.HLSF.dbCache = null;
              window.HLSF.currentGraph = null;
              window.HLSF.currentGlyphOnly = false;
              window.HLSF.__centerInit = false;
            }
            Session.tokens.clear();
            updateStats();
            logSuccess(`Cleared ${keys.length} tokens`);
          }
          break;
        case 'stats':
          const { totalApiCalls, totalCacheHits, totalCostCents } = state.sessionStats;
          const total = totalApiCalls + totalCacheHits;
          const hitRate = total > 0 ? ((totalCacheHits / total) * 100).toFixed(1) : 0;
          addLog(`<strong>Session Stats:</strong><br>
            ‚Ä¢ Requests: ${total}<br>
            ‚Ä¢ Cache hits: ${totalCacheHits} (${hitRate}%)<br>
            ‚Ä¢ API calls: ${totalApiCalls}<br>
            ‚Ä¢ Cost: ${formatCurrency(totalCostCents)}<br>
            ‚Ä¢ Cached tokens: ${getCachedTokenCount()}`);
          break;
        case 'database':
        case 'db':
          showDatabaseMetadata();
          break;
        case 'export':
          exportDatabaseMetadata();
          break;
        case 'glyph':
          cmdGlyph(args.join(' '));
          break;
        case 'ledger':
          cmdLedger(args.join(' '));
          break;
        case 'encrypt':
          cmdEncrypt(args.join(' '));
          break;
        case 'decrypt':
          cmdDecrypt(args.join(' '));
          break;
        case 'exportledger':
          cmdLedger('export');
          break;
        case 'help':
          addLog(`<strong>Commands:</strong><br>
            /clear - Clear log<br>
            /reset - Clear cache<br>
            /stats - Session statistics<br>
            /database or /db - View database metadata<br>
            /export - Export database metadata as JSON<br>
            /import - Import database from JSON file<br>
            /loaddb &lt;url&gt; - Load database JSON from URL<br>
            /glyph &lt;token1 token2 ...&gt; - Show weighted glyph assignments<br>
            /ledger [show|export|import] - Manage private glyph ledger<br>
            /encrypt &lt;text&gt; - Encrypt text into weighted glyphs<br>
            /decrypt &lt;glyph+float&gt; - Decrypt using private ledger<br>
            /exportledger - Shortcut for /ledger export<br>
            /hlsf or /visualize - Visualize database as Hierarchical-Level Semantic Framework<br>
            /help - Show commands`);
          break;
        default:
          logError(`Unknown: ${command}`);
      }
    }

    // ============================================
    // MAIN PROCESSING
    // ============================================
    async function processPrompt(prompt) {
      if (state.isProcessing) return;
      
      state.isProcessing = true;
      currentAbortController = new AbortController();
      elements.sendBtn.disabled = true;
      elements.cancelBtn.style.display = 'inline-block';
      elements.input.disabled = true;

      const startTime = performance.now();

      try {
        const tokens = tokenize(prompt);
        if (tokens.length === 0) {
          logError('Prompt cannot be empty');
          return;
        }
        addConversationTokens(tokens);
        if (tokens.length > CONFIG.MAX_TOKENS_PER_PROMPT) {
          logError(`Exceeds ${CONFIG.MAX_TOKENS_PER_PROMPT} token limit (${tokens.length})`);
          return;
        }

        const estimatedCalls = tokens.length * 2 + 3;
        const estimatedCost = estimatedCalls * CONFIG.ESTIMATED_COST_PER_API_CALL;
        addLog(`<div class="cost-estimate">
          üìä <strong>Estimate:</strong> ${tokens.length} tokens, ~${estimatedCalls} API calls, ~${formatCurrency(Math.ceil(estimatedCost * 100))}
        </div>`);

        // Step 1: Initial response
        let initialResponse = '';
        if (state.apiKey) {
          const s1 = logStatus('‚è≥ Generating initial response...');
          initialResponse = await callOpenAI([
            { role: 'system', content: 'You are an expert assistant.' },
            { role: 'user', content: prompt },
          ]);
          s1.innerHTML = `‚úÖ Initial response generated`;
        } else {
          initialResponse = '‚ö†Ô∏è Offline mode';
          logWarning('Skipped (offline)');
        }

        // Step 2: Adjacency analysis
        const responseTokens = tokenize(initialResponse);
        addConversationTokens(responseTokens);
        const [inputMatrices, outputMatrices] = await Promise.all([
          batchFetchAdjacencies(tokens, prompt, 'input'),
          batchFetchAdjacencies(responseTokens, initialResponse, 'output'),
        ]);

        calculateAttention(inputMatrices);
        calculateAttention(outputMatrices);

        const allMatrices = new Map([...inputMatrices, ...outputMatrices]);
        const topTokens = summarizeAttention(allMatrices);
        const keyRels = extractKeyRelationships(allMatrices);

        addLog(`<div class="adjacency-insight">
          <strong>üéØ High Attention:</strong> ${formatTopTokens(topTokens)}
        </div>
        <div class="adjacency-insight">
          <strong>üîó Key Relationships:</strong><br>
          ${keyRels.map(r => `‚Ä¢ ${r}`).join('<br>')}
        </div>`);

        // Step 3: Thought stream
        let thoughtStream = '';
        if (state.apiKey) {
          const s2 = logStatus('‚è≥ Synthesizing thought stream...');
          thoughtStream = await callOpenAI([
            { role: 'system', content: 'You create reflective thought streams from analytical insights.' },
            { role: 'user', content: `Based on these adjacency insights, generate a stream-of-consciousness internal monologue:\n\nTop tokens: ${JSON.stringify(topTokens)}\nRelationships: ${keyRels.join('; ')}\n\nWrite as flowing natural thought connecting these elements.` },
          ]);
          s2.innerHTML = '‚úÖ Thought stream captured';
          
          addLog(`<div class="section-divider"></div>
            <div class="section-title">üí≠ Emergent Thought Stream</div>
            <div class="thought-stream">${sanitize(thoughtStream)}</div>`);
        }

        // Step 4: Refined response
        let refinedResponse = initialResponse;
        if (state.apiKey) {
          const s3 = logStatus('‚è≥ Refining response...');
          refinedResponse = await callOpenAI([
            { role: 'system', content: 'You refine responses based on adjacency insights.' },
            { role: 'user', content: `Original: "${initialResponse}"\n\nInsights: ${thoughtStream}\n\nRevise by: 1) Incorporating emergent insights 2) Restructuring based on token relationships 3) Enhancing coherence. Provide revised response only.` },
          ]);
          s3.innerHTML = '‚úÖ Response refined';
        }
        addConversationTokens(tokenize(refinedResponse));

        // Display final output
        const time = ((performance.now() - startTime) / 1000).toFixed(1);
        addLog(`<div class="section-divider"></div>
          <div class="final-output">
            <h3>‚ú® REFINED RESPONSE</h3>
            <pre>${sanitize(refinedResponse)}</pre>
            
            <details>
              <summary>Compare with original response</summary>
              <pre>${sanitize(initialResponse)}</pre>
            </details>
            
            <details>
              <summary>View adjacency data (${allMatrices.size} tokens)</summary>
              <pre>${JSON.stringify(Array.from(allMatrices.entries()).slice(0, 5), null, 2)}</pre>
            </details>
          </div>
        `);
        
        logSuccess(`Processing complete (${time}s)`);

      } catch (err) {
        if (err.name === 'AbortError' || err.message === 'AbortError') {
          logWarning('Processing cancelled');
        } else {
          logError(err.message || 'Processing failed');
          console.error(err);
        }
      } finally {
        state.isProcessing = false;
        currentAbortController = null;
        elements.sendBtn.disabled = false;
        elements.cancelBtn.style.display = 'none';
        elements.input.disabled = false;
        elements.input.value = '';
        elements.input.focus();
      }
    }

    // ============================================
    // EVENTS
    // ============================================
    function applyApiKeyFromModal() {
      const key = elements.apiKeyInput.value.trim();
      if (!isValidApiKey(key)) {
        logError('Invalid API key format');
        return;
      }
      state.apiKey = key.trim();
      const persisted = safeStorageSet(API_KEY_STORAGE_KEY, state.apiKey);
      elements.apiModal.classList.add('hidden');
      if (!persisted) {
        logWarning('API key configured but not saved to storage');
      }
      logSuccess('API key configured');
    }

    elements.apiConfirmBtn.addEventListener('click', applyApiKeyFromModal);

    elements.apiKeyInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        applyApiKeyFromModal();
      }
    });

    elements.apiCancelBtn.addEventListener('click', () => {
      elements.apiModal.classList.add('hidden');
      logWarning('Offline mode - limited functionality');
    });

    elements.sendBtn.addEventListener('click', () => {
      const input = elements.input.value.trim();
      if (!input) return;
      
      addLog(`> ${sanitize(input)}`);
      
      if (isCommand(input)) {
        handleCommand(input);
        elements.input.value = '';
      } else {
        onUserPromptSubmitted(input);
        processPrompt(input);
      }
    });

    elements.cancelBtn.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
        logWarning('Cancelling...');
      }
    });

    elements.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.sendBtn.click();
      }
    });

    // ============================================
    // INIT
    // ============================================
    window.addEventListener('beforeunload', () => {
      state.apiKey = '';
      stopHLSFAnimation();
    });

    async function initialize() {
      updateStats();

      const storedKey = safeStorageGet(API_KEY_STORAGE_KEY, '');
      if (isValidApiKey(storedKey)) {
        state.apiKey = storedKey.trim();
        elements.apiKeyInput.value = state.apiKey;
        elements.apiModal.classList.add('hidden');
        logSuccess('Loaded stored API key');
      } else if (storedKey) {
        safeStorageRemove(API_KEY_STORAGE_KEY);
      }

      await tryBootstrapDb();

      const cachedCount = getCachedTokenCount();
      
      addLog(`<strong>üß† HLSF Cognition Engine v2.0</strong><br><br>
        This engine performs:<br>
        1. Token adjacency mapping (50 relationship types)<br>
        2. Attention score calculation<br>
        3. Emergent thought stream synthesis<br>
        4. Response refinement based on insights<br>
        5. <strong>Symbolic glyph encryption</strong> (complex number encoding)<br>
        6. <strong>HLSF visualization</strong> (hierarchical semantic framework)<br><br>
        <strong>Commands:</strong> /help, /hlsf, /glyph, /encrypt, /decrypt<br>
        ${cachedCount > 0 ? `<br>‚úÖ Loaded with ${cachedCount} cached tokens` : ''}
        <br><small>‚ö†Ô∏è Note: Download HTML and run locally for API calls to work.</small>
      `);
      
      elements.input.focus();
    }

    window.addEventListener('load', () => {
      tryBootstrapDb();
    });

    initialize();
  </script>
</body>
</html>